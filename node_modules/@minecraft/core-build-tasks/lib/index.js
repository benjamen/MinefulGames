var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/dotenv/package.json
var require_package = __commonJS({
  "../../node_modules/dotenv/package.json"(exports, module) {
    module.exports = {
      name: "dotenv",
      version: "16.4.7",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        pretest: "npm run lint && npm run dts-check",
        test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
        "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^18.11.3",
        decache: "^4.6.2",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-version": "^9.5.0",
        tap: "^19.2.0",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// ../../node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "../../node_modules/dotenv/lib/main.js"(exports, module) {
    "use strict";
    var fs3 = __require("fs");
    var path9 = __require("path");
    var os = __require("os");
    var crypto = __require("crypto");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse2(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs3.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path9.resolve(process.cwd(), ".env.vault");
      }
      if (fs3.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path9.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path9.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path10 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs3.readFileSync(path10, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${path10} ${e.message}`);
          }
          lastError = e;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse: parse2,
      populate
    };
    module.exports.configDotenv = DotenvModule.configDotenv;
    module.exports._configVault = DotenvModule._configVault;
    module.exports._parseVault = DotenvModule._parseVault;
    module.exports.config = DotenvModule.config;
    module.exports.decrypt = DotenvModule.decrypt;
    module.exports.parse = DotenvModule.parse;
    module.exports.populate = DotenvModule.populate;
    module.exports = DotenvModule;
  }
});

// ../../node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "../../node_modules/fs.realpath/old.js"(exports) {
    "use strict";
    var pathModule = __require("path");
    var isWindows = process.platform === "win32";
    var fs3 = __require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs3.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs3.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs3.statSync(base);
            linkTarget = fs3.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs3.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs3.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs3.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs3.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// ../../node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "../../node_modules/fs.realpath/index.js"(exports, module) {
    "use strict";
    module.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs3 = __require("fs");
    var origRealpath = fs3.realpath;
    var origRealpathSync = fs3.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs3.realpath = realpath;
      fs3.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs3.realpath = origRealpath;
      fs3.realpathSync = origRealpathSync;
    }
  }
});

// ../../node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "../../node_modules/concat-map/index.js"(exports, module) {
    "use strict";
    module.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../node_modules/brace-expansion/index.js"(exports, module) {
    "use strict";
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand2(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand2(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand2(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand2(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../../node_modules/rimraf/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../../node_modules/rimraf/node_modules/minimatch/minimatch.js"(exports, module) {
    "use strict";
    module.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path9 = function() {
      try {
        return __require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path9.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand2 = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path9.sep !== "/") {
        pattern = pattern.split(path9.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand2(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path9.sep !== "/") {
        f = f.split(path9.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/inherits/inherits_browser.js"(exports, module) {
    "use strict";
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../../node_modules/inherits/inherits.js"(exports, module) {
    "use strict";
    try {
      util = __require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module.exports = util.inherits;
    } catch (e) {
      module.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../../node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "../../node_modules/path-is-absolute/index.js"(exports, module) {
    "use strict";
    function posix(path9) {
      return path9.charAt(0) === "/";
    }
    function win32(path9) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path9);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module.exports = process.platform === "win32" ? win32 : posix;
    module.exports.posix = posix;
    module.exports.win32 = win32;
  }
});

// ../../node_modules/rimraf/node_modules/glob/common.js
var require_common = __commonJS({
  "../../node_modules/rimraf/node_modules/glob/common.js"(exports) {
    "use strict";
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs3 = __require("fs");
    var path9 = __require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs3;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path9.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path9.resolve(self2.cwd, "/");
      self2.root = path9.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      options.allowWindowsEscape = false;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path9.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path9.resolve(self2.cwd, f);
      } else {
        abs = path9.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path10) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path10) || !!(item.gmatcher && item.gmatcher.match(path10));
      });
    }
    function childrenIgnored(self2, path10) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path10));
      });
    }
  }
});

// ../../node_modules/rimraf/node_modules/glob/sync.js
var require_sync = __commonJS({
  "../../node_modules/rimraf/node_modules/glob/sync.js"(exports, module) {
    "use strict";
    module.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = __require("util");
    var path9 = __require("path");
    var assert = __require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path9.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path9.join(this.root, prefix);
        } else {
          prefix = path9.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// ../../node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "../../node_modules/wrappy/wrappy.js"(exports, module) {
    "use strict";
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// ../../node_modules/once/once.js
var require_once = __commonJS({
  "../../node_modules/once/once.js"(exports, module) {
    "use strict";
    var wrappy = require_wrappy();
    module.exports = wrappy(once);
    module.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// ../../node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "../../node_modules/inflight/inflight.js"(exports, module) {
    "use strict";
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// ../../node_modules/rimraf/node_modules/glob/glob.js
var require_glob = __commonJS({
  "../../node_modules/rimraf/node_modules/glob/glob.js"(exports, module) {
    "use strict";
    module.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = __require("events").EventEmitter;
    var path9 = __require("path");
    var assert = __require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = __require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path9.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path9.join(this.root, prefix);
        } else {
          prefix = path9.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// ../../node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "../../node_modules/rimraf/rimraf.js"(exports, module) {
    "use strict";
    var assert = __require("assert");
    var path9 = __require("path");
    var fs3 = __require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    var defaults = (options) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs3[m];
        m = m + "Sync";
        options[m] = options[m] || fs3[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    };
    var rimraf3 = (p, options, cb) => {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(() => rimraf_(p2, options, CB), timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          };
          rimraf_(p2, options, CB);
        });
      };
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, (er, stat) => {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options, er, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options, er) => {
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    };
    var rmdir = (p, options, originalEr, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf3(path9.join(p, f), options, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options) => {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      let results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p2, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options, null);
          else
            options.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options, er);
        }
      }
    };
    var rmdirSync = (p, options, originalEr) => {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    };
    var rmkidsSync = (p, options) => {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path9.join(p, f), options));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module.exports = rimraf3;
    rimraf3.sync = rimrafSync;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/InternalError.js
var require_InternalError = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/InternalError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InternalError = void 0;
    var InternalError = class _InternalError extends Error {
      /**
       * Constructs a new instance of the {@link InternalError} class.
       *
       * @param message - A message describing the error.  This will be assigned to
       * {@link InternalError.unformattedMessage}.  The `Error.message` field will have additional boilerplate
       * explaining that the user has encountered a software defect.
       */
      constructor(message) {
        super(_InternalError._formatMessage(message));
        this.__proto__ = _InternalError.prototype;
        this.unformattedMessage = message;
        if (_InternalError.breakInDebugger) {
          debugger;
        }
      }
      static _formatMessage(unformattedMessage) {
        return `Internal Error: ${unformattedMessage}

You have encountered a software defect. Please consider reporting the issue to the maintainers of this application.`;
      }
      /** @override */
      toString() {
        return this.message;
      }
    };
    exports.InternalError = InternalError;
    InternalError.breakInDebugger = true;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/TypeUuid.js
var require_TypeUuid = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/TypeUuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeUuid = void 0;
    var InternalError_1 = require_InternalError();
    var classPrototypeUuidSymbol = Symbol.for("TypeUuid.classPrototypeUuid");
    var TypeUuid = class _TypeUuid {
      /**
       * Registers a JavaScript class as having a type identified by the specified UUID.
       * @privateRemarks
       * We cannot use a construct signature for `targetClass` because it may be an abstract class.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static registerClass(targetClass, typeUuid) {
        if (typeof targetClass !== "function") {
          throw new Error("The targetClass parameter must be a JavaScript class");
        }
        if (!_TypeUuid._uuidRegExp.test(typeUuid)) {
          throw new Error(`The type UUID must be specified as lowercase hexadecimal with dashes: "${typeUuid}"`);
        }
        const targetClassPrototype = targetClass.prototype;
        if (Object.hasOwnProperty.call(targetClassPrototype, classPrototypeUuidSymbol)) {
          const existingUuid = targetClassPrototype[classPrototypeUuidSymbol];
          throw new InternalError_1.InternalError(`Cannot register the target class ${targetClass.name || ""} typeUuid=${typeUuid} because it was already registered with typeUuid=${existingUuid}`);
        }
        targetClassPrototype[classPrototypeUuidSymbol] = typeUuid;
      }
      /**
       * Returns true if the `targetObject` is an instance of a JavaScript class that was previously
       * registered using the specified `typeUuid`.  Base classes are also considered.
       */
      static isInstanceOf(targetObject, typeUuid) {
        if (targetObject === void 0 || targetObject === null) {
          return false;
        }
        let objectPrototype = Object.getPrototypeOf(targetObject);
        while (objectPrototype !== void 0 && objectPrototype !== null) {
          const registeredUuid = objectPrototype[classPrototypeUuidSymbol];
          if (registeredUuid === typeUuid) {
            return true;
          }
          objectPrototype = Object.getPrototypeOf(objectPrototype);
        }
        return false;
      }
    };
    exports.TypeUuid = TypeUuid;
    TypeUuid._uuidRegExp = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/AlreadyReportedError.js
var require_AlreadyReportedError = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/AlreadyReportedError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlreadyReportedError = void 0;
    var TypeUuid_1 = require_TypeUuid();
    var uuidAlreadyReportedError = "f26b0640-a49b-49d1-9ead-1a516d5920c7";
    var AlreadyReportedError = class _AlreadyReportedError extends Error {
      constructor() {
        super("An error occurred.");
        this.__proto__ = _AlreadyReportedError.prototype;
      }
      static [Symbol.hasInstance](instance) {
        return TypeUuid_1.TypeUuid.isInstanceOf(instance, uuidAlreadyReportedError);
      }
    };
    exports.AlreadyReportedError = AlreadyReportedError;
    TypeUuid_1.TypeUuid.registerClass(AlreadyReportedError, uuidAlreadyReportedError);
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Terminal/Colors.js
var require_Colors = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Terminal/Colors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Colors = exports.ConsoleColorCodes = exports.TextAttribute = exports.ColorValue = exports.eolSequence = void 0;
    exports.eolSequence = {
      isEol: true
    };
    var ColorValue;
    (function(ColorValue2) {
      ColorValue2[ColorValue2["Black"] = 0] = "Black";
      ColorValue2[ColorValue2["Red"] = 1] = "Red";
      ColorValue2[ColorValue2["Green"] = 2] = "Green";
      ColorValue2[ColorValue2["Yellow"] = 3] = "Yellow";
      ColorValue2[ColorValue2["Blue"] = 4] = "Blue";
      ColorValue2[ColorValue2["Magenta"] = 5] = "Magenta";
      ColorValue2[ColorValue2["Cyan"] = 6] = "Cyan";
      ColorValue2[ColorValue2["White"] = 7] = "White";
      ColorValue2[ColorValue2["Gray"] = 8] = "Gray";
    })(ColorValue || (exports.ColorValue = ColorValue = {}));
    var TextAttribute;
    (function(TextAttribute2) {
      TextAttribute2[TextAttribute2["Bold"] = 0] = "Bold";
      TextAttribute2[TextAttribute2["Dim"] = 1] = "Dim";
      TextAttribute2[TextAttribute2["Underline"] = 2] = "Underline";
      TextAttribute2[TextAttribute2["Blink"] = 3] = "Blink";
      TextAttribute2[TextAttribute2["InvertColor"] = 4] = "InvertColor";
      TextAttribute2[TextAttribute2["Hidden"] = 5] = "Hidden";
    })(TextAttribute || (exports.TextAttribute = TextAttribute = {}));
    var ConsoleColorCodes;
    (function(ConsoleColorCodes2) {
      ConsoleColorCodes2[ConsoleColorCodes2["BlackForeground"] = 30] = "BlackForeground";
      ConsoleColorCodes2[ConsoleColorCodes2["RedForeground"] = 31] = "RedForeground";
      ConsoleColorCodes2[ConsoleColorCodes2["GreenForeground"] = 32] = "GreenForeground";
      ConsoleColorCodes2[ConsoleColorCodes2["YellowForeground"] = 33] = "YellowForeground";
      ConsoleColorCodes2[ConsoleColorCodes2["BlueForeground"] = 34] = "BlueForeground";
      ConsoleColorCodes2[ConsoleColorCodes2["MagentaForeground"] = 35] = "MagentaForeground";
      ConsoleColorCodes2[ConsoleColorCodes2["CyanForeground"] = 36] = "CyanForeground";
      ConsoleColorCodes2[ConsoleColorCodes2["WhiteForeground"] = 37] = "WhiteForeground";
      ConsoleColorCodes2[ConsoleColorCodes2["GrayForeground"] = 90] = "GrayForeground";
      ConsoleColorCodes2[ConsoleColorCodes2["DefaultForeground"] = 39] = "DefaultForeground";
      ConsoleColorCodes2[ConsoleColorCodes2["BlackBackground"] = 40] = "BlackBackground";
      ConsoleColorCodes2[ConsoleColorCodes2["RedBackground"] = 41] = "RedBackground";
      ConsoleColorCodes2[ConsoleColorCodes2["GreenBackground"] = 42] = "GreenBackground";
      ConsoleColorCodes2[ConsoleColorCodes2["YellowBackground"] = 43] = "YellowBackground";
      ConsoleColorCodes2[ConsoleColorCodes2["BlueBackground"] = 44] = "BlueBackground";
      ConsoleColorCodes2[ConsoleColorCodes2["MagentaBackground"] = 45] = "MagentaBackground";
      ConsoleColorCodes2[ConsoleColorCodes2["CyanBackground"] = 46] = "CyanBackground";
      ConsoleColorCodes2[ConsoleColorCodes2["WhiteBackground"] = 47] = "WhiteBackground";
      ConsoleColorCodes2[ConsoleColorCodes2["GrayBackground"] = 100] = "GrayBackground";
      ConsoleColorCodes2[ConsoleColorCodes2["DefaultBackground"] = 49] = "DefaultBackground";
      ConsoleColorCodes2[ConsoleColorCodes2["Bold"] = 1] = "Bold";
      ConsoleColorCodes2[ConsoleColorCodes2["Dim"] = 2] = "Dim";
      ConsoleColorCodes2[ConsoleColorCodes2["NormalColorOrIntensity"] = 22] = "NormalColorOrIntensity";
      ConsoleColorCodes2[ConsoleColorCodes2["Underline"] = 4] = "Underline";
      ConsoleColorCodes2[ConsoleColorCodes2["UnderlineOff"] = 24] = "UnderlineOff";
      ConsoleColorCodes2[ConsoleColorCodes2["Blink"] = 5] = "Blink";
      ConsoleColorCodes2[ConsoleColorCodes2["BlinkOff"] = 25] = "BlinkOff";
      ConsoleColorCodes2[ConsoleColorCodes2["InvertColor"] = 7] = "InvertColor";
      ConsoleColorCodes2[ConsoleColorCodes2["InvertColorOff"] = 27] = "InvertColorOff";
      ConsoleColorCodes2[ConsoleColorCodes2["Hidden"] = 8] = "Hidden";
      ConsoleColorCodes2[ConsoleColorCodes2["HiddenOff"] = 28] = "HiddenOff";
    })(ConsoleColorCodes || (exports.ConsoleColorCodes = ConsoleColorCodes = {}));
    var Colors = class _Colors {
      static black(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Black });
      }
      static red(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Red });
      }
      static green(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Green });
      }
      static yellow(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Yellow });
      }
      static blue(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Blue });
      }
      static magenta(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Magenta });
      }
      static cyan(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Cyan });
      }
      static white(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.White });
      }
      static gray(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Gray });
      }
      static blackBackground(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Black });
      }
      static redBackground(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Red });
      }
      static greenBackground(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Green });
      }
      static yellowBackground(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Yellow });
      }
      static blueBackground(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Blue });
      }
      static magentaBackground(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Magenta });
      }
      static cyanBackground(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Cyan });
      }
      static whiteBackground(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.White });
      }
      static grayBackground(text) {
        return Object.assign(Object.assign({}, _Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Gray });
      }
      static bold(text) {
        return _Colors._applyTextAttribute(text, TextAttribute.Bold);
      }
      static dim(text) {
        return _Colors._applyTextAttribute(text, TextAttribute.Dim);
      }
      static underline(text) {
        return _Colors._applyTextAttribute(text, TextAttribute.Underline);
      }
      static blink(text) {
        return _Colors._applyTextAttribute(text, TextAttribute.Blink);
      }
      static invertColor(text) {
        return _Colors._applyTextAttribute(text, TextAttribute.InvertColor);
      }
      static hidden(text) {
        return _Colors._applyTextAttribute(text, TextAttribute.Hidden);
      }
      /**
       * If called with a string, returns the string wrapped in a {@link IColorableSequence}.
       * If called with a {@link IColorableSequence}, returns the {@link IColorableSequence}.
       *
       * @internal
       */
      static _normalizeStringOrColorableSequence(value) {
        if (typeof value === "string") {
          return {
            text: value
          };
        } else {
          return value;
        }
      }
      static _applyTextAttribute(text, attribute) {
        const sequence = _Colors._normalizeStringOrColorableSequence(text);
        if (!sequence.textAttributes) {
          sequence.textAttributes = [];
        }
        sequence.textAttributes.push(attribute);
        return sequence;
      }
    };
    exports.Colors = Colors;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Terminal/AnsiEscape.js
var require_AnsiEscape = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Terminal/AnsiEscape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnsiEscape = void 0;
    var Colors_1 = require_Colors();
    var AnsiEscape = class _AnsiEscape {
      /**
       * Returns the input text with all ANSI escape codes removed.  For example, this is useful when saving
       * colorized console output to a log file.
       */
      static removeCodes(text) {
        return text.replace(_AnsiEscape._csiRegExp, "");
      }
      /**
       * Replaces ANSI escape codes with human-readable tokens.  This is useful for unit tests
       * that compare text strings in test assertions or snapshot files.
       */
      static formatForTests(text, options) {
        if (!options) {
          options = {};
        }
        let result = text.replace(_AnsiEscape._csiRegExp, (capture, csiCode) => {
          const match = csiCode.match(_AnsiEscape._sgrRegExp);
          if (match) {
            const sgrParameter = parseInt(match[1], 10);
            const sgrParameterName = _AnsiEscape._tryGetSgrFriendlyName(sgrParameter);
            if (sgrParameterName) {
              return `[${sgrParameterName}]`;
            }
          }
          return `[${csiCode}]`;
        });
        if (options.encodeNewlines) {
          result = result.replace(_AnsiEscape._backslashNRegExp, "[n]").replace(_AnsiEscape._backslashRRegExp, `[r]`);
        }
        return result;
      }
      // Returns a human-readable token representing an SGR parameter, or undefined for parameter that is not well-known.
      // The SGR parameter numbers are documented in this table:
      // https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters
      static _tryGetSgrFriendlyName(sgiParameter) {
        switch (sgiParameter) {
          case Colors_1.ConsoleColorCodes.BlackForeground:
            return "black";
          case Colors_1.ConsoleColorCodes.RedForeground:
            return "red";
          case Colors_1.ConsoleColorCodes.GreenForeground:
            return "green";
          case Colors_1.ConsoleColorCodes.YellowForeground:
            return "yellow";
          case Colors_1.ConsoleColorCodes.BlueForeground:
            return "blue";
          case Colors_1.ConsoleColorCodes.MagentaForeground:
            return "magenta";
          case Colors_1.ConsoleColorCodes.CyanForeground:
            return "cyan";
          case Colors_1.ConsoleColorCodes.WhiteForeground:
            return "white";
          case Colors_1.ConsoleColorCodes.GrayForeground:
            return "gray";
          case Colors_1.ConsoleColorCodes.DefaultForeground:
            return "default";
          case Colors_1.ConsoleColorCodes.BlackBackground:
            return "black-bg";
          case Colors_1.ConsoleColorCodes.RedBackground:
            return "red-bg";
          case Colors_1.ConsoleColorCodes.GreenBackground:
            return "green-bg";
          case Colors_1.ConsoleColorCodes.YellowBackground:
            return "yellow-bg";
          case Colors_1.ConsoleColorCodes.BlueBackground:
            return "blue-bg";
          case Colors_1.ConsoleColorCodes.MagentaBackground:
            return "magenta-bg";
          case Colors_1.ConsoleColorCodes.CyanBackground:
            return "cyan-bg";
          case Colors_1.ConsoleColorCodes.WhiteBackground:
            return "white-bg";
          case Colors_1.ConsoleColorCodes.GrayBackground:
            return "gray-bg";
          case Colors_1.ConsoleColorCodes.DefaultBackground:
            return "default-bg";
          case Colors_1.ConsoleColorCodes.Bold:
            return "bold";
          case Colors_1.ConsoleColorCodes.Dim:
            return "dim";
          case Colors_1.ConsoleColorCodes.NormalColorOrIntensity:
            return "normal";
          case Colors_1.ConsoleColorCodes.Underline:
            return "underline";
          case Colors_1.ConsoleColorCodes.UnderlineOff:
            return "underline-off";
          case Colors_1.ConsoleColorCodes.Blink:
            return "blink";
          case Colors_1.ConsoleColorCodes.BlinkOff:
            return "blink-off";
          case Colors_1.ConsoleColorCodes.InvertColor:
            return "invert";
          case Colors_1.ConsoleColorCodes.InvertColorOff:
            return "invert-off";
          case Colors_1.ConsoleColorCodes.Hidden:
            return "hidden";
          case Colors_1.ConsoleColorCodes.HiddenOff:
            return "hidden-off";
          default:
            return void 0;
        }
      }
    };
    exports.AnsiEscape = AnsiEscape;
    AnsiEscape._csiRegExp = /\x1b\[([\x30-\x3f]*[\x20-\x2f]*[\x40-\x7e])/gu;
    AnsiEscape._sgrRegExp = /([0-9]+)m/u;
    AnsiEscape._backslashNRegExp = /\n/g;
    AnsiEscape._backslashRRegExp = /\r/g;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Async.js
var require_Async = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Async.js"(exports) {
    "use strict";
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncQueue = exports.Async = void 0;
    var Async = class _Async {
      /**
       * Given an input array and a `callback` function, invoke the callback to start a
       * promise for each element in the array.  Returns an array containing the results.
       *
       * @remarks
       * This API is similar to the system `Array#map`, except that the loop is asynchronous,
       * and the maximum number of concurrent promises can be throttled
       * using {@link IAsyncParallelismOptions.concurrency}.
       *
       * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
       * then the loop stops immediately.  Any remaining array items will be skipped, and
       * overall operation will reject with the first error that was encountered.
       *
       * @param iterable - the array of inputs for the callback function
       * @param callback - a function that starts an asynchronous promise for an element
       *   from the array
       * @param options - options for customizing the control flow
       * @returns an array containing the result for each callback, in the same order
       *   as the original input `array`
       */
      static async mapAsync(iterable, callback, options) {
        const result = [];
        await _Async.forEachAsync(iterable, async (item, arrayIndex) => {
          result[arrayIndex] = await callback(item, arrayIndex);
        }, options);
        return result;
      }
      /**
       * Given an input array and a `callback` function, invoke the callback to start a
       * promise for each element in the array.
       *
       * @remarks
       * This API is similar to the system `Array#forEach`, except that the loop is asynchronous,
       * and the maximum number of concurrent promises can be throttled
       * using {@link IAsyncParallelismOptions.concurrency}.
       *
       * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
       * then the loop stops immediately.  Any remaining array items will be skipped, and
       * overall operation will reject with the first error that was encountered.
       *
       * @param iterable - the array of inputs for the callback function
       * @param callback - a function that starts an asynchronous promise for an element
       *   from the array
       * @param options - options for customizing the control flow
       */
      static async forEachAsync(iterable, callback, options) {
        await new Promise((resolve4, reject) => {
          const concurrency = (options === null || options === void 0 ? void 0 : options.concurrency) && options.concurrency > 0 ? options.concurrency : Infinity;
          let operationsInProgress = 0;
          const iterator2 = (iterable[Symbol.iterator] || iterable[Symbol.asyncIterator]).call(iterable);
          let arrayIndex = 0;
          let iteratorIsComplete = false;
          let promiseHasResolvedOrRejected = false;
          async function queueOperationsAsync() {
            while (operationsInProgress < concurrency && !iteratorIsComplete && !promiseHasResolvedOrRejected) {
              operationsInProgress++;
              const currentIteratorResult = await iterator2.next();
              iteratorIsComplete = !!currentIteratorResult.done;
              if (!iteratorIsComplete) {
                Promise.resolve(callback(currentIteratorResult.value, arrayIndex++)).then(async () => {
                  operationsInProgress--;
                  await onOperationCompletionAsync();
                }).catch((error) => {
                  promiseHasResolvedOrRejected = true;
                  reject(error);
                });
              } else {
                operationsInProgress--;
              }
            }
            if (iteratorIsComplete) {
              await onOperationCompletionAsync();
            }
          }
          async function onOperationCompletionAsync() {
            if (!promiseHasResolvedOrRejected) {
              if (operationsInProgress === 0 && iteratorIsComplete) {
                promiseHasResolvedOrRejected = true;
                resolve4();
              } else if (!iteratorIsComplete) {
                await queueOperationsAsync();
              }
            }
          }
          queueOperationsAsync().catch((error) => {
            promiseHasResolvedOrRejected = true;
            reject(error);
          });
        });
      }
      /**
       * Return a promise that resolves after the specified number of milliseconds.
       */
      static async sleep(ms) {
        await new Promise((resolve4) => {
          setTimeout(resolve4, ms);
        });
      }
      /**
       * Executes an async function and optionally retries it if it fails.
       */
      static async runWithRetriesAsync({ action, maxRetries, retryDelayMs = 0 }) {
        let retryCounter = 0;
        while (true) {
          try {
            return await action();
          } catch (e) {
            if (++retryCounter > maxRetries) {
              throw e;
            } else if (retryDelayMs > 0) {
              await _Async.sleep(retryDelayMs);
            }
          }
        }
      }
      /**
       * Returns a Signal, a.k.a. a "deferred promise".
       */
      static getSignal() {
        return getSignal();
      }
    };
    exports.Async = Async;
    function getSignal() {
      let resolver;
      let rejecter;
      const promise = new Promise((resolve4, reject) => {
        resolver = resolve4;
        rejecter = reject;
      });
      return [promise, resolver, rejecter];
    }
    var AsyncQueue = class {
      constructor(iterable) {
        this._queue = iterable ? Array.from(iterable) : [];
        const [promise, resolver] = getSignal();
        this._onPushSignal = promise;
        this._onPushResolve = resolver;
      }
      [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
          let activeIterations = 0;
          let [callbackSignal, callbackResolve] = getSignal();
          const callback = () => {
            if (--activeIterations === 0) {
              callbackResolve();
              const [newCallbackSignal, newCallbackResolve] = getSignal();
              callbackSignal = newCallbackSignal;
              callbackResolve = newCallbackResolve;
            }
          };
          let position = 0;
          while (this._queue.length > position || activeIterations > 0) {
            if (this._queue.length > position) {
              activeIterations++;
              yield yield __await([this._queue[position++], callback]);
            } else {
              yield __await(Promise.race([this._onPushSignal, callbackSignal]));
            }
          }
        });
      }
      /**
       * Adds an item to the queue.
       *
       * @param item - The item to push into the queue.
       */
      push(item) {
        this._queue.push(item);
        this._onPushResolve();
        const [onPushSignal, onPushResolve] = getSignal();
        this._onPushSignal = onPushSignal;
        this._onPushResolve = onPushResolve;
      }
    };
    exports.AsyncQueue = AsyncQueue;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Constants.js
var require_Constants = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FolderConstants = exports.FileConstants = void 0;
    var FileConstants;
    (function(FileConstants2) {
      FileConstants2["PackageJson"] = "package.json";
    })(FileConstants || (exports.FileConstants = FileConstants = {}));
    var FolderConstants;
    (function(FolderConstants2) {
      FolderConstants2["Git"] = ".git";
      FolderConstants2["NodeModules"] = "node_modules";
    })(FolderConstants || (exports.FolderConstants = FolderConstants = {}));
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Enum.js
var require_Enum = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Enum = void 0;
    var Enum = class {
      constructor() {
      }
      /**
       * Returns an enum value, given its key. Returns `undefined` if no matching key is found.
       *
       * @example
       *
       * Example usage:
       * ```ts
       * enum Colors {
       *   Red = 1
       * }
       *
       * // Prints "1"
       * console.log(Enum.tryGetValueByKey(Colors, "Red"));
       *
       * // Prints "undefined"
       * console.log(Enum.tryGetValueByKey(Colors, "Black"));
       * ```
       */
      static tryGetValueByKey(enumObject, key) {
        return enumObject[key];
      }
      /**
       * This API is similar to {@link Enum.tryGetValueByKey}, except that it throws an exception
       * if the key is undefined.
       */
      static getValueByKey(enumObject, key) {
        const result = enumObject[key];
        if (result === void 0) {
          throw new Error(`The lookup key ${JSON.stringify(key)} is not defined`);
        }
        return result;
      }
      /**
       * Returns an enum string key, given its numeric value.  Returns `undefined` if no matching value
       * is found.
       *
       * @remarks
       * The TypeScript compiler only creates a reverse mapping for enum members whose value is numeric.
       * For example:
       *
       * ```ts
       * enum E {
       *   A = 1,
       *   B = 'c'
       * }
       *
       * // Prints "A"
       * console.log(E[1]);
       *
       * // Prints "undefined"
       * console.log(E["c"]);
       * ```
       *
       * @example
       *
       * Example usage:
       * ```ts
       * enum Colors {
       *   Red = 1,
       *   Blue = 'blue'
       * }
       *
       * // Prints "Red"
       * console.log(Enum.tryGetKeyByNumber(Colors, 1));
       *
       * // Prints "undefined"
       * console.log(Enum.tryGetKeyByNumber(Colors, -1));
       * ```
       */
      static tryGetKeyByNumber(enumObject, value) {
        return enumObject[value];
      }
      /**
       * This API is similar to {@link Enum.tryGetKeyByNumber}, except that it throws an exception
       * if the key is undefined.
       */
      static getKeyByNumber(enumObject, value) {
        const result = enumObject[value];
        if (result === void 0) {
          throw new Error(`The value ${value} does not exist in the mapping`);
        }
        return result;
      }
    };
    exports.Enum = Enum;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/EnvironmentMap.js
var require_EnvironmentMap = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/EnvironmentMap.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnvironmentMap = void 0;
    var process_1 = __importDefault(__require("process"));
    var InternalError_1 = require_InternalError();
    var EnvironmentMap = class {
      constructor(environmentObject = {}) {
        this._map = /* @__PURE__ */ new Map();
        Object.defineProperty(this, "_sanityCheck", {
          enumerable: true,
          get: function() {
            throw new InternalError_1.InternalError("Attempt to read EnvironmentMap class as an object");
          }
        });
        this.caseSensitive = process_1.default.platform !== "win32";
        this.mergeFromObject(environmentObject);
      }
      /**
       * Clears all entries, resulting in an empty map.
       */
      clear() {
        this._map.clear();
      }
      /**
       * Assigns the variable to the specified value.  A previous value will be overwritten.
       *
       * @remarks
       * The value can be an empty string.  To completely remove the entry, use
       * {@link EnvironmentMap.unset} instead.
       */
      set(name, value) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.set(key, { name, value });
      }
      /**
       * Removes the key from the map, if present.
       */
      unset(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.delete(key);
      }
      /**
       * Returns the value of the specified variable, or `undefined` if the map does not contain that name.
       */
      get(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        const entry = this._map.get(key);
        if (entry === void 0) {
          return void 0;
        }
        return entry.value;
      }
      /**
       * Returns the map keys, which are environment variable names.
       */
      names() {
        return this._map.keys();
      }
      /**
       * Returns the map entries.
       */
      entries() {
        return this._map.values();
      }
      /**
       * Adds each entry from `environmentMap` to this map.
       */
      mergeFrom(environmentMap) {
        for (const entry of environmentMap.entries()) {
          this.set(entry.name, entry.value);
        }
      }
      /**
       * Merges entries from a plain JavaScript object, such as would be used with the `process.env` API.
       */
      mergeFromObject(environmentObject = {}) {
        for (const [name, value] of Object.entries(environmentObject)) {
          if (value !== void 0) {
            this.set(name, value);
          }
        }
      }
      /**
       * Returns the keys as a plain JavaScript object similar to the object returned by the `process.env` API.
       */
      toObject() {
        const result = {};
        for (const entry of this.entries()) {
          result[entry.name] = entry.value;
        }
        return result;
      }
    };
    exports.EnvironmentMap = EnvironmentMap;
  }
});

// ../../node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function() {
        if (typeof arguments[arguments.length - 1] === "function")
          fn.apply(this, arguments);
        else {
          return new Promise((resolve4, reject) => {
            arguments[arguments.length] = (err, res) => {
              if (err)
                return reject(err);
              resolve4(res);
            };
            arguments.length++;
            fn.apply(this, arguments);
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function() {
        const cb = arguments[arguments.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, arguments);
        else
          fn.apply(this, arguments).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/graceful-fs/polyfills.js"(exports, module) {
    "use strict";
    var constants = __require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module.exports = patch;
    function patch(fs3) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs3);
      }
      if (!fs3.lutimes) {
        patchLutimes(fs3);
      }
      fs3.chown = chownFix(fs3.chown);
      fs3.fchown = chownFix(fs3.fchown);
      fs3.lchown = chownFix(fs3.lchown);
      fs3.chmod = chmodFix(fs3.chmod);
      fs3.fchmod = chmodFix(fs3.fchmod);
      fs3.lchmod = chmodFix(fs3.lchmod);
      fs3.chownSync = chownFixSync(fs3.chownSync);
      fs3.fchownSync = chownFixSync(fs3.fchownSync);
      fs3.lchownSync = chownFixSync(fs3.lchownSync);
      fs3.chmodSync = chmodFixSync(fs3.chmodSync);
      fs3.fchmodSync = chmodFixSync(fs3.fchmodSync);
      fs3.lchmodSync = chmodFixSync(fs3.lchmodSync);
      fs3.stat = statFix(fs3.stat);
      fs3.fstat = statFix(fs3.fstat);
      fs3.lstat = statFix(fs3.lstat);
      fs3.statSync = statFixSync(fs3.statSync);
      fs3.fstatSync = statFixSync(fs3.fstatSync);
      fs3.lstatSync = statFixSync(fs3.lstatSync);
      if (fs3.chmod && !fs3.lchmod) {
        fs3.lchmod = function(path9, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs3.lchmodSync = function() {
        };
      }
      if (fs3.chown && !fs3.lchown) {
        fs3.lchown = function(path9, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs3.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs3.rename = typeof fs3.rename !== "function" ? fs3.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs3.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs3.rename);
      }
      fs3.read = typeof fs3.read !== "function" ? fs3.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _2, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs3.read);
      fs3.readSync = typeof fs3.readSync !== "function" ? fs3.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs3, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs3.readSync);
      function patchLchmod(fs4) {
        fs4.lchmod = function(path9, mode, callback) {
          fs4.open(
            path9,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs4.fchmod(fd, mode, function(err2) {
                fs4.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs4.lchmodSync = function(path9, mode) {
          var fd = fs4.openSync(path9, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs4.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs4.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs4.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs4) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs4.futimes) {
          fs4.lutimes = function(path9, at, mt, cb) {
            fs4.open(path9, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs4.futimes(fd, at, mt, function(er2) {
                fs4.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs4.lutimesSync = function(path9, at, mt) {
            var fd = fs4.openSync(path9, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs4.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs4.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs4.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs4.futimes) {
          fs4.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs4.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs3, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs3, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs3, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs3, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs3, target, options, callback) : orig.call(fs3, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs3, target, options) : orig.call(fs3, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/graceful-fs/legacy-streams.js"(exports, module) {
    "use strict";
    var Stream = __require("stream").Stream;
    module.exports = legacy;
    function legacy(fs3) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path9, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path9, options);
        Stream.call(this);
        var self2 = this;
        this.path = path9;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs3.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path9, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path9, options);
        Stream.call(this);
        this.path = path9;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs3.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/graceful-fs/clone.js"(exports, module) {
    "use strict";
    module.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/graceful-fs/graceful-fs.js"(exports, module) {
    "use strict";
    var fs3 = __require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = __require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop2() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop2;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs3[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs3, queue);
      fs3.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs3, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs3.close);
      fs3.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs3, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs3.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs3[gracefulQueue]);
          __require("assert").equal(fs3[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs3[gracefulQueue]);
    }
    module.exports = patch(clone(fs3));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs3.__patched) {
      module.exports = patch(fs3);
      fs3.__patched = true;
    }
    function patch(fs4) {
      polyfills(fs4);
      fs4.gracefulify = patch;
      fs4.createReadStream = createReadStream;
      fs4.createWriteStream = createWriteStream2;
      var fs$readFile = fs4.readFile;
      fs4.readFile = readFile2;
      function readFile2(path9, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path9, options, cb);
        function go$readFile(path10, options2, cb2, startTime) {
          return fs$readFile(path10, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path10, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs4.writeFile;
      fs4.writeFile = writeFile;
      function writeFile(path9, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path9, data, options, cb);
        function go$writeFile(path10, data2, options2, cb2, startTime) {
          return fs$writeFile(path10, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path10, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs4.appendFile;
      if (fs$appendFile)
        fs4.appendFile = appendFile;
      function appendFile(path9, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path9, data, options, cb);
        function go$appendFile(path10, data2, options2, cb2, startTime) {
          return fs$appendFile(path10, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path10, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs4.copyFile;
      if (fs$copyFile)
        fs4.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs4.readdir;
      fs4.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path9, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path10, options2, cb2, startTime) {
          return fs$readdir(path10, fs$readdirCallback(
            path10,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path10, options2, cb2, startTime) {
          return fs$readdir(path10, options2, fs$readdirCallback(
            path10,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path9, options, cb);
        function fs$readdirCallback(path10, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path10, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs4);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs4.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs4.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs4, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs4, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs4, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs4, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path9, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path9, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path9, options) {
        return new fs4.ReadStream(path9, options);
      }
      function createWriteStream2(path9, options) {
        return new fs4.WriteStream(path9, options);
      }
      var fs$open = fs4.open;
      fs4.open = open;
      function open(path9, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path9, flags, mode, cb);
        function go$open(path10, flags2, mode2, cb2, startTime) {
          return fs$open(path10, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path10, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs4;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs3[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs3[gracefulQueue].length; ++i) {
        if (fs3[gracefulQueue][i].length > 2) {
          fs3[gracefulQueue][i][3] = now;
          fs3[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs3[gracefulQueue].length === 0)
        return;
      var elem = fs3[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs3[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/fs-extra/lib/fs/index.js
var require_fs2 = __commonJS({
  "../../node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs3 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchown",
      "lchmod",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "readFile",
      "readdir",
      "readlink",
      "realpath",
      "rename",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs3[key] === "function";
    });
    Object.keys(fs3).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports[key] = fs3[key];
    });
    api.forEach((method) => {
      exports[method] = u(fs3[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs3.exists(filename, callback);
      }
      return new Promise((resolve4) => {
        return fs3.exists(filename, resolve4);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs3.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve4, reject) => {
        fs3.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve4({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs3.write(fd, buffer, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs3.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve4({ bytesWritten, buffer: buffer2 });
        });
      });
    };
  }
});

// ../../node_modules/fs-extra/lib/mkdirs/win32.js
var require_win32 = __commonJS({
  "../../node_modules/fs-extra/lib/mkdirs/win32.js"(exports, module) {
    "use strict";
    var path9 = __require("path");
    function getRootPath(p) {
      p = path9.normalize(path9.resolve(p)).split(path9.sep);
      if (p.length > 0)
        return p[0];
      return null;
    }
    var INVALID_PATH_CHARS = /[<>:"|?*]/;
    function invalidWin32Path(p) {
      const rp = getRootPath(p);
      p = p.replace(rp, "");
      return INVALID_PATH_CHARS.test(p);
    }
    module.exports = {
      getRootPath,
      invalidWin32Path
    };
  }
});

// ../../node_modules/fs-extra/lib/mkdirs/mkdirs.js
var require_mkdirs = __commonJS({
  "../../node_modules/fs-extra/lib/mkdirs/mkdirs.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path9 = __require("path");
    var invalidWin32Path = require_win32().invalidWin32Path;
    var o777 = parseInt("0777", 8);
    function mkdirs(p, opts, callback, made) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      if (process.platform === "win32" && invalidWin32Path(p)) {
        const errInval = new Error(p + " contains invalid WIN32 path characters.");
        errInval.code = "EINVAL";
        return callback(errInval);
      }
      let mode = opts.mode;
      const xfs = opts.fs || fs3;
      if (mode === void 0) {
        mode = o777 & ~process.umask();
      }
      if (!made)
        made = null;
      callback = callback || function() {
      };
      p = path9.resolve(p);
      xfs.mkdir(p, mode, (er) => {
        if (!er) {
          made = made || p;
          return callback(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path9.dirname(p) === p)
              return callback(er);
            mkdirs(path9.dirname(p), opts, (er2, made2) => {
              if (er2)
                callback(er2, made2);
              else
                mkdirs(p, opts, callback, made2);
            });
            break;
          default:
            xfs.stat(p, (er2, stat) => {
              if (er2 || !stat.isDirectory())
                callback(er, made);
              else
                callback(null, made);
            });
            break;
        }
      });
    }
    module.exports = mkdirs;
  }
});

// ../../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js
var require_mkdirs_sync = __commonJS({
  "../../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path9 = __require("path");
    var invalidWin32Path = require_win32().invalidWin32Path;
    var o777 = parseInt("0777", 8);
    function mkdirsSync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      let mode = opts.mode;
      const xfs = opts.fs || fs3;
      if (process.platform === "win32" && invalidWin32Path(p)) {
        const errInval = new Error(p + " contains invalid WIN32 path characters.");
        errInval.code = "EINVAL";
        throw errInval;
      }
      if (mode === void 0) {
        mode = o777 & ~process.umask();
      }
      if (!made)
        made = null;
      p = path9.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        if (err0.code === "ENOENT") {
          if (path9.dirname(p) === p)
            throw err0;
          made = mkdirsSync(path9.dirname(p), opts, made);
          mkdirsSync(p, opts, made);
        } else {
          let stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory())
            throw err0;
        }
      }
      return made;
    }
    module.exports = mkdirsSync;
  }
});

// ../../node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs2 = __commonJS({
  "../../node_modules/fs-extra/lib/mkdirs/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var mkdirs = u(require_mkdirs());
    var mkdirsSync = require_mkdirs_sync();
    module.exports = {
      mkdirs,
      mkdirsSync,
      // alias
      mkdirp: mkdirs,
      mkdirpSync: mkdirsSync,
      ensureDir: mkdirs,
      ensureDirSync: mkdirsSync
    };
  }
});

// ../../node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../../node_modules/fs-extra/lib/util/utimes.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var os = __require("os");
    var path9 = __require("path");
    function hasMillisResSync() {
      let tmpfile = path9.join("millis-test-sync" + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path9.join(os.tmpdir(), tmpfile);
      const d = /* @__PURE__ */ new Date(1435410243862);
      fs3.writeFileSync(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141");
      const fd = fs3.openSync(tmpfile, "r+");
      fs3.futimesSync(fd, d, d);
      fs3.closeSync(fd);
      return fs3.statSync(tmpfile).mtime > 1435410243e3;
    }
    function hasMillisRes(callback) {
      let tmpfile = path9.join("millis-test" + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path9.join(os.tmpdir(), tmpfile);
      const d = /* @__PURE__ */ new Date(1435410243862);
      fs3.writeFile(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141", (err) => {
        if (err)
          return callback(err);
        fs3.open(tmpfile, "r+", (err2, fd) => {
          if (err2)
            return callback(err2);
          fs3.futimes(fd, d, d, (err3) => {
            if (err3)
              return callback(err3);
            fs3.close(fd, (err4) => {
              if (err4)
                return callback(err4);
              fs3.stat(tmpfile, (err5, stats) => {
                if (err5)
                  return callback(err5);
                callback(null, stats.mtime > 1435410243e3);
              });
            });
          });
        });
      });
    }
    function timeRemoveMillis(timestamp) {
      if (typeof timestamp === "number") {
        return Math.floor(timestamp / 1e3) * 1e3;
      } else if (timestamp instanceof Date) {
        return new Date(Math.floor(timestamp.getTime() / 1e3) * 1e3);
      } else {
        throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
      }
    }
    function utimesMillis(path10, atime, mtime, callback) {
      fs3.open(path10, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs3.futimes(fd, atime, mtime, (futimesErr) => {
          fs3.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path10, atime, mtime) {
      const fd = fs3.openSync(path10, "r+");
      fs3.futimesSync(fd, atime, mtime);
      return fs3.closeSync(fd);
    }
    module.exports = {
      hasMillisRes,
      hasMillisResSync,
      timeRemoveMillis,
      utimesMillis,
      utimesMillisSync
    };
  }
});

// ../../node_modules/fs-extra/lib/util/buffer.js
var require_buffer = __commonJS({
  "../../node_modules/fs-extra/lib/util/buffer.js"(exports, module) {
    "use strict";
    module.exports = function(size) {
      if (typeof Buffer.allocUnsafe === "function") {
        try {
          return Buffer.allocUnsafe(size);
        } catch (e) {
          return new Buffer(size);
        }
      }
      return new Buffer(size);
    };
  }
});

// ../../node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync = __commonJS({
  "../../node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path9 = __require("path");
    var mkdirpSync = require_mkdirs2().mkdirsSync;
    var utimesSync = require_utimes().utimesMillisSync;
    var notExist = Symbol("notExist");
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      const destStat = checkPaths(src, dest);
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path9.dirname(dest);
      if (!fs3.existsSync(destParent))
        mkdirpSync(destParent);
      return startCopy(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync2 = opts.dereference ? fs3.statSync : fs3.lstatSync;
      const srcStat = statSync2(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (destStat === notExist)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs3.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      if (typeof fs3.copyFileSync === "function") {
        fs3.copyFileSync(src, dest);
        fs3.chmodSync(dest, srcStat.mode);
        if (opts.preserveTimestamps) {
          return utimesSync(dest, srcStat.atime, srcStat.mtime);
        }
        return;
      }
      return copyFileFallback(srcStat, src, dest, opts);
    }
    function copyFileFallback(srcStat, src, dest, opts) {
      const BUF_LENGTH = 64 * 1024;
      const _buff = require_buffer()(BUF_LENGTH);
      const fdr = fs3.openSync(src, "r");
      const fdw = fs3.openSync(dest, "w", srcStat.mode);
      let pos = 0;
      while (pos < srcStat.size) {
        const bytesRead = fs3.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        fs3.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
      }
      if (opts.preserveTimestamps)
        fs3.futimesSync(fdw, srcStat.atime, srcStat.mtime);
      fs3.closeSync(fdr);
      fs3.closeSync(fdw);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (destStat === notExist)
        return mkDirAndCopy(srcStat, src, dest, opts);
      if (destStat && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcStat, src, dest, opts) {
      fs3.mkdirSync(dest);
      copyDir(src, dest, opts);
      return fs3.chmodSync(dest, srcStat.mode);
    }
    function copyDir(src, dest, opts) {
      fs3.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path9.join(src, item);
      const destItem = path9.join(dest, item);
      const destStat = checkPaths(srcItem, destItem);
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs3.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path9.resolve(process.cwd(), resolvedSrc);
      }
      if (destStat === notExist) {
        return fs3.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs3.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs3.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path9.resolve(process.cwd(), resolvedDest);
        }
        if (isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs3.statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs3.unlinkSync(dest);
      return fs3.symlinkSync(resolvedSrc, dest);
    }
    function isSrcSubdir(src, dest) {
      const srcArray = path9.resolve(src).split(path9.sep);
      const destArray = path9.resolve(dest).split(path9.sep);
      return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true);
    }
    function checkStats(src, dest) {
      const srcStat = fs3.statSync(src);
      let destStat;
      try {
        destStat = fs3.statSync(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: notExist };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest) {
      const { srcStat, destStat } = checkStats(src, dest);
      if (destStat.ino && destStat.ino === srcStat.ino) {
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
      }
      return destStat;
    }
    module.exports = copySync;
  }
});

// ../../node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync2 = __commonJS({
  "../../node_modules/fs-extra/lib/copy-sync/index.js"(exports, module) {
    "use strict";
    module.exports = {
      copySync: require_copy_sync()
    };
  }
});

// ../../node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "../../node_modules/fs-extra/lib/path-exists/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs3 = require_fs2();
    function pathExists(path9) {
      return fs3.access(path9).then(() => true).catch(() => false);
    }
    module.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs3.existsSync
    };
  }
});

// ../../node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../../node_modules/fs-extra/lib/copy/copy.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path9 = __require("path");
    var mkdirp = require_mkdirs2().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimes = require_utimes().utimesMillis;
    var notExist = Symbol("notExist");
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      checkPaths(src, dest, (err, destStat) => {
        if (err)
          return cb(err);
        if (opts.filter)
          return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
        return checkParentDir(destStat, src, dest, opts, cb);
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path9.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return startCopy(destStat, src, dest, opts, cb);
        mkdirp(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return startCopy(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include) {
          if (destStat)
            return onInclude(destStat, src, dest, opts, cb);
          return onInclude(src, dest, opts, cb);
        }
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat = opts.dereference ? fs3.stat : fs3.lstat;
      stat(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (destStat === notExist)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs3.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      if (typeof fs3.copyFile === "function") {
        return fs3.copyFile(src, dest, (err) => {
          if (err)
            return cb(err);
          return setDestModeAndTimestamps(srcStat, dest, opts, cb);
        });
      }
      return copyFileFallback(srcStat, src, dest, opts, cb);
    }
    function copyFileFallback(srcStat, src, dest, opts, cb) {
      const rs = fs3.createReadStream(src);
      rs.on("error", (err) => cb(err)).once("open", () => {
        const ws = fs3.createWriteStream(dest, { mode: srcStat.mode });
        ws.on("error", (err) => cb(err)).on("open", () => rs.pipe(ws)).once("close", () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
      });
    }
    function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
      fs3.chmod(dest, srcStat.mode, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps) {
          return utimes(dest, srcStat.atime, srcStat.mtime, cb);
        }
        return cb();
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (destStat === notExist)
        return mkDirAndCopy(srcStat, src, dest, opts, cb);
      if (destStat && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcStat, src, dest, opts, cb) {
      fs3.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return fs3.chmod(dest, srcStat.mode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs3.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path9.join(src, item);
      const destItem = path9.join(dest, item);
      checkPaths(srcItem, destItem, (err, destStat) => {
        if (err)
          return cb(err);
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs3.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path9.resolve(process.cwd(), resolvedSrc);
        }
        if (destStat === notExist) {
          return fs3.symlink(resolvedSrc, dest, cb);
        } else {
          fs3.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs3.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path9.resolve(process.cwd(), resolvedDest);
            }
            if (isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs3.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs3.symlink(resolvedSrc, dest, cb);
      });
    }
    function isSrcSubdir(src, dest) {
      const srcArray = path9.resolve(src).split(path9.sep);
      const destArray = path9.resolve(dest).split(path9.sep);
      return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true);
    }
    function checkStats(src, dest, cb) {
      fs3.stat(src, (err, srcStat) => {
        if (err)
          return cb(err);
        fs3.stat(dest, (err2, destStat) => {
          if (err2) {
            if (err2.code === "ENOENT")
              return cb(null, { srcStat, destStat: notExist });
            return cb(err2);
          }
          return cb(null, { srcStat, destStat });
        });
      });
    }
    function checkPaths(src, dest, cb) {
      checkStats(src, dest, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat.ino && destStat.ino === srcStat.ino) {
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));
        }
        return cb(null, destStat);
      });
    }
    module.exports = copy;
  }
});

// ../../node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../../node_modules/fs-extra/lib/copy/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    module.exports = {
      copy: u(require_copy())
    };
  }
});

// ../../node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf2 = __commonJS({
  "../../node_modules/fs-extra/lib/remove/rimraf.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path9 = __require("path");
    var assert = __require("assert");
    var isWindows = process.platform === "win32";
    function defaults(options) {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs3[m];
        m = m + "Sync";
        options[m] = options[m] || fs3[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf3(p, options, cb) {
      let busyTries = 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      rimraf_(p, options, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p, options, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows) {
          return fixWinEPERM(p, options, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir(p, options, er, cb);
        }
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir(p, options, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      if (er) {
        assert(er instanceof Error);
      }
      options.chmod(p, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options, er, cb);
            } else {
              options.unlink(p, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p, options, er) {
      let stats;
      assert(p);
      assert(options);
      if (er) {
        assert(er instanceof Error);
      }
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync(p, options, er);
      } else {
        options.unlinkSync(p);
      }
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p, options, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options.rmdir(p, cb);
        files.forEach((f) => {
          rimraf3(path9.join(p, f), options, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options.rmdir(p, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p, options) {
      let st;
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows) {
          fixWinEPERMSync(p, options, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync(p, options, null);
        } else {
          options.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync(p, options, er);
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p, options);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path9.join(p, f), options));
      if (isWindows) {
        const startTime = Date.now();
        do {
          try {
            const ret = options.rmdirSync(p, options);
            return ret;
          } catch (er) {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options.rmdirSync(p, options);
        return ret;
      }
    }
    module.exports = rimraf3;
    rimraf3.sync = rimrafSync;
  }
});

// ../../node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../../node_modules/fs-extra/lib/remove/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var rimraf3 = require_rimraf2();
    module.exports = {
      remove: u(rimraf3),
      removeSync: rimraf3.sync
    };
  }
});

// ../../node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../../node_modules/fs-extra/lib/empty/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs3 = __require("fs");
    var path9 = __require("path");
    var mkdir = require_mkdirs2();
    var remove = require_remove();
    var emptyDir = u(function emptyDir2(dir, callback) {
      callback = callback || function() {
      };
      fs3.readdir(dir, (err, items) => {
        if (err)
          return mkdir.mkdirs(dir, callback);
        items = items.map((item) => path9.join(dir, item));
        deleteItem();
        function deleteItem() {
          const item = items.pop();
          if (!item)
            return callback();
          remove.remove(item, (err2) => {
            if (err2)
              return callback(err2);
            deleteItem();
          });
        }
      });
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs3.readdirSync(dir);
      } catch (err) {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path9.join(dir, item);
        remove.removeSync(item);
      });
    }
    module.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/file.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path9 = __require("path");
    var fs3 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function createFile(file, callback) {
      function makeFile() {
        fs3.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs3.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path9.dirname(file);
        pathExists(dir, (err2, dirExists) => {
          if (err2)
            return callback(err2);
          if (dirExists)
            return makeFile();
          mkdir.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeFile();
          });
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs3.statSync(file);
      } catch (e) {
      }
      if (stats && stats.isFile())
        return;
      const dir = path9.dirname(file);
      if (!fs3.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs3.writeFileSync(file, "");
    }
    module.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/link.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path9 = __require("path");
    var fs3 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs3.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        fs3.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureLink");
            return callback(err2);
          }
          const dir = path9.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      const destinationExists = fs3.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      try {
        fs3.lstatSync(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path9.dirname(dstpath);
      const dirExists = fs3.existsSync(dir);
      if (dirExists)
        return fs3.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs3.linkSync(srcpath, dstpath);
    }
    module.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module) {
    "use strict";
    var path9 = __require("path");
    var fs3 = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path9.isAbsolute(srcpath)) {
        return fs3.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            "toCwd": srcpath,
            "toDst": srcpath
          });
        });
      } else {
        const dstdir = path9.dirname(dstpath);
        const relativeToDst = path9.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              "toCwd": relativeToDst,
              "toDst": srcpath
            });
          } else {
            return fs3.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                "toCwd": srcpath,
                "toDst": path9.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path9.isAbsolute(srcpath)) {
        exists = fs3.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          "toCwd": srcpath,
          "toDst": srcpath
        };
      } else {
        const dstdir = path9.dirname(dstpath);
        const relativeToDst = path9.join(dstdir, srcpath);
        exists = fs3.existsSync(relativeToDst);
        if (exists) {
          return {
            "toCwd": relativeToDst,
            "toDst": srcpath
          };
        } else {
          exists = fs3.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            "toCwd": srcpath,
            "toDst": path9.relative(dstdir, srcpath)
          };
        }
      }
    }
    module.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs3.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs3.lstatSync(srcpath);
      } catch (e) {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/symlink.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path9 = __require("path");
    var fs3 = require_graceful_fs();
    var _mkdirs = require_mkdirs2();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        symlinkPaths(srcpath, dstpath, (err2, relative) => {
          if (err2)
            return callback(err2);
          srcpath = relative.toDst;
          symlinkType(relative.toCwd, type, (err3, type2) => {
            if (err3)
              return callback(err3);
            const dir = path9.dirname(dstpath);
            pathExists(dir, (err4, dirExists) => {
              if (err4)
                return callback(err4);
              if (dirExists)
                return fs3.symlink(srcpath, dstpath, type2, callback);
              mkdirs(dir, (err5) => {
                if (err5)
                  return callback(err5);
                fs3.symlink(srcpath, dstpath, type2, callback);
              });
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      const destinationExists = fs3.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path9.dirname(dstpath);
      const exists = fs3.existsSync(dir);
      if (exists)
        return fs3.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs3.symlinkSync(srcpath, dstpath, type);
    }
    module.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/index.js"(exports, module) {
    "use strict";
    var file = require_file();
    var link = require_link();
    var symlink = require_symlink();
    module.exports = {
      // file
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      // link
      createLink: link.createLink,
      createLinkSync: link.createLinkSync,
      ensureLink: link.createLink,
      ensureLinkSync: link.createLinkSync,
      // symlink
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };
  }
});

// ../../node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../../node_modules/jsonfile/index.js"(exports, module) {
    "use strict";
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_2) {
      _fs = __require("fs");
    }
    function readFile2(file, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      if (typeof options === "string") {
        options = { encoding: options };
      }
      options = options || {};
      var fs3 = options.fs || _fs;
      var shouldThrow = true;
      if ("throws" in options) {
        shouldThrow = options.throws;
      }
      fs3.readFile(file, options, function(err, data) {
        if (err)
          return callback(err);
        data = stripBom(data);
        var obj;
        try {
          obj = JSON.parse(data, options ? options.reviver : null);
        } catch (err2) {
          if (shouldThrow) {
            err2.message = file + ": " + err2.message;
            return callback(err2);
          } else {
            return callback(null, null);
          }
        }
        callback(null, obj);
      });
    }
    function readFileSync2(file, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { encoding: options };
      }
      var fs3 = options.fs || _fs;
      var shouldThrow = true;
      if ("throws" in options) {
        shouldThrow = options.throws;
      }
      try {
        var content = fs3.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = file + ": " + err.message;
          throw err;
        } else {
          return null;
        }
      }
    }
    function stringify(obj, options) {
      var spaces;
      var EOL = "\n";
      if (typeof options === "object" && options !== null) {
        if (options.spaces) {
          spaces = options.spaces;
        }
        if (options.EOL) {
          EOL = options.EOL;
        }
      }
      var str = JSON.stringify(obj, options ? options.replacer : null, spaces);
      return str.replace(/\n/g, EOL) + EOL;
    }
    function writeFile(file, obj, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      options = options || {};
      var fs3 = options.fs || _fs;
      var str = "";
      try {
        str = stringify(obj, options);
      } catch (err) {
        if (callback)
          callback(err, null);
        return;
      }
      fs3.writeFile(file, str, options, callback);
    }
    function writeFileSync(file, obj, options) {
      options = options || {};
      var fs3 = options.fs || _fs;
      var str = stringify(obj, options);
      return fs3.writeFileSync(file, str, options);
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      content = content.replace(/^\uFEFF/, "");
      return content;
    }
    var jsonfile = {
      readFile: readFile2,
      readFileSync: readFileSync2,
      writeFile,
      writeFileSync
    };
    module.exports = jsonfile;
  }
});

// ../../node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../../node_modules/fs-extra/lib/json/jsonfile.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var jsonFile = require_jsonfile();
    module.exports = {
      // jsonfile exports
      readJson: u(jsonFile.readFile),
      readJsonSync: jsonFile.readFileSync,
      writeJson: u(jsonFile.writeFile),
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../../node_modules/fs-extra/lib/json/output-json.js"(exports, module) {
    "use strict";
    var path9 = __require("path");
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    var jsonFile = require_jsonfile2();
    function outputJson(file, data, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      const dir = path9.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return jsonFile.writeJson(file, data, options, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          jsonFile.writeJson(file, data, options, callback);
        });
      });
    }
    module.exports = outputJson;
  }
});

// ../../node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../../node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path9 = __require("path");
    var mkdir = require_mkdirs2();
    var jsonFile = require_jsonfile2();
    function outputJsonSync(file, data, options) {
      const dir = path9.dirname(file);
      if (!fs3.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      jsonFile.writeJsonSync(file, data, options);
    }
    module.exports = outputJsonSync;
  }
});

// ../../node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../../node_modules/fs-extra/lib/json/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module.exports = jsonFile;
  }
});

// ../../node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync = __commonJS({
  "../../node_modules/fs-extra/lib/move-sync/index.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path9 = __require("path");
    var copySync = require_copy_sync2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs2().mkdirsSync;
    var buffer = require_buffer();
    function moveSync(src, dest, options) {
      options = options || {};
      const overwrite = options.overwrite || options.clobber || false;
      src = path9.resolve(src);
      dest = path9.resolve(dest);
      if (src === dest)
        return fs3.accessSync(src);
      if (isSrcSubdir(src, dest))
        throw new Error(`Cannot move '${src}' into itself '${dest}'.`);
      mkdirpSync(path9.dirname(dest));
      tryRenameSync();
      function tryRenameSync() {
        if (overwrite) {
          try {
            return fs3.renameSync(src, dest);
          } catch (err) {
            if (err.code === "ENOTEMPTY" || err.code === "EEXIST" || err.code === "EPERM") {
              removeSync(dest);
              options.overwrite = false;
              return moveSync(src, dest, options);
            }
            if (err.code !== "EXDEV")
              throw err;
            return moveSyncAcrossDevice(src, dest, overwrite);
          }
        } else {
          try {
            fs3.linkSync(src, dest);
            return fs3.unlinkSync(src);
          } catch (err) {
            if (err.code === "EXDEV" || err.code === "EISDIR" || err.code === "EPERM" || err.code === "ENOTSUP") {
              return moveSyncAcrossDevice(src, dest, overwrite);
            }
            throw err;
          }
        }
      }
    }
    function moveSyncAcrossDevice(src, dest, overwrite) {
      const stat = fs3.statSync(src);
      if (stat.isDirectory()) {
        return moveDirSyncAcrossDevice(src, dest, overwrite);
      } else {
        return moveFileSyncAcrossDevice(src, dest, overwrite);
      }
    }
    function moveFileSyncAcrossDevice(src, dest, overwrite) {
      const BUF_LENGTH = 64 * 1024;
      const _buff = buffer(BUF_LENGTH);
      const flags = overwrite ? "w" : "wx";
      const fdr = fs3.openSync(src, "r");
      const stat = fs3.fstatSync(fdr);
      const fdw = fs3.openSync(dest, flags, stat.mode);
      let pos = 0;
      while (pos < stat.size) {
        const bytesRead = fs3.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        fs3.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
      }
      fs3.closeSync(fdr);
      fs3.closeSync(fdw);
      return fs3.unlinkSync(src);
    }
    function moveDirSyncAcrossDevice(src, dest, overwrite) {
      const options = {
        overwrite: false
      };
      if (overwrite) {
        removeSync(dest);
        tryCopySync();
      } else {
        tryCopySync();
      }
      function tryCopySync() {
        copySync(src, dest, options);
        return removeSync(src);
      }
    }
    function isSrcSubdir(src, dest) {
      try {
        return fs3.statSync(src).isDirectory() && src !== dest && dest.indexOf(src) > -1 && dest.split(path9.dirname(src) + path9.sep)[1].split(path9.sep)[0] === path9.basename(src);
      } catch (e) {
        return false;
      }
    }
    module.exports = {
      moveSync
    };
  }
});

// ../../node_modules/fs-extra/lib/move/index.js
var require_move = __commonJS({
  "../../node_modules/fs-extra/lib/move/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs3 = require_graceful_fs();
    var path9 = __require("path");
    var copy = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp = require_mkdirs2().mkdirp;
    var pathExists = require_path_exists().pathExists;
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const overwrite = opts.overwrite || opts.clobber || false;
      src = path9.resolve(src);
      dest = path9.resolve(dest);
      if (src === dest)
        return fs3.access(src, cb);
      fs3.stat(src, (err, st) => {
        if (err)
          return cb(err);
        if (st.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`));
        }
        mkdirp(path9.dirname(dest), (err2) => {
          if (err2)
            return cb(err2);
          return doRename(src, dest, overwrite, cb);
        });
      });
    }
    function doRename(src, dest, overwrite, cb) {
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs3.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    function isSrcSubdir(src, dest) {
      const srcArray = src.split(path9.sep);
      const destArray = dest.split(path9.sep);
      return srcArray.reduce((acc, current, i) => {
        return acc && destArray[i] === current;
      }, true);
    }
    module.exports = {
      move: u(move)
    };
  }
});

// ../../node_modules/fs-extra/lib/output/index.js
var require_output = __commonJS({
  "../../node_modules/fs-extra/lib/output/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs3 = require_graceful_fs();
    var path9 = __require("path");
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path9.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs3.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs3.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path9.dirname(file);
      if (fs3.existsSync(dir)) {
        return fs3.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs3.writeFileSync(file, ...args);
    }
    module.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../../node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/fs-extra/lib/index.js"(exports, module) {
    "use strict";
    module.exports = Object.assign(
      {},
      // Export promiseified graceful-fs:
      require_fs2(),
      // Export extra methods:
      require_copy_sync2(),
      require_copy2(),
      require_empty(),
      require_ensure(),
      require_json(),
      require_mkdirs2(),
      require_move_sync(),
      require_move(),
      require_output(),
      require_path_exists(),
      require_remove()
    );
    var fs3 = __require("fs");
    if (Object.getOwnPropertyDescriptor(fs3, "promises")) {
      Object.defineProperty(module.exports, "promises", {
        get() {
          return fs3.promises;
        }
      });
    }
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Text.js
var require_Text = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Text.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve4, reject) {
            v = o[n](v), settle(resolve4, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve4, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve4({ value: v2, done: d });
        }, reject);
      }
    };
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncDelegator = exports && exports.__asyncDelegator || function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Text = exports.NewlineKind = exports.Encoding = void 0;
    var os = __importStar(__require("os"));
    var Encoding;
    (function(Encoding2) {
      Encoding2["Utf8"] = "utf8";
    })(Encoding || (exports.Encoding = Encoding = {}));
    var NewlineKind;
    (function(NewlineKind2) {
      NewlineKind2["CrLf"] = "\r\n";
      NewlineKind2["Lf"] = "\n";
      NewlineKind2["OsDefault"] = "os";
    })(NewlineKind || (exports.NewlineKind = NewlineKind = {}));
    var NEWLINE_REGEX = /\r\n|\n\r|\r|\n/g;
    var NEWLINE_AT_END_REGEX = /(\r\n|\n\r|\r|\n)$/;
    function* readLinesFromChunk(chunk, encoding, ignoreEmptyLines, state) {
      if (!chunk) {
        return;
      }
      const remaining = state.remaining + (typeof chunk === "string" ? chunk : chunk.toString(encoding));
      let startIndex = 0;
      const matches = remaining.matchAll(NEWLINE_REGEX);
      for (const match of matches) {
        const endIndex = match.index;
        if (startIndex !== endIndex || !ignoreEmptyLines) {
          yield remaining.substring(startIndex, endIndex);
        }
        startIndex = endIndex + match[0].length;
      }
      state.remaining = remaining.substring(startIndex);
    }
    var Text = class _Text {
      /**
       * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
       * all matches are replaced, rather than just the first match.
       * @param input         - The string to be modified
       * @param searchValue   - The value to search for
       * @param replaceValue  - The replacement text
       */
      static replaceAll(input, searchValue, replaceValue) {
        return input.split(searchValue).join(replaceValue);
      }
      /**
       * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.
       */
      static convertToCrLf(input) {
        return input.replace(_Text._newLineRegEx, "\r\n");
      }
      /**
       * Converts all newlines in the provided string to use POSIX-style LF end of line characters.
       *
       * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
       */
      static convertToLf(input) {
        return input.replace(_Text._newLineRegEx, "\n");
      }
      /**
       * Converts all newlines in the provided string to use the specified newline type.
       */
      static convertTo(input, newlineKind) {
        return input.replace(_Text._newLineRegEx, _Text.getNewline(newlineKind));
      }
      /**
       * Returns the newline character sequence for the specified `NewlineKind`.
       */
      static getNewline(newlineKind) {
        switch (newlineKind) {
          case NewlineKind.CrLf:
            return "\r\n";
          case NewlineKind.Lf:
            return "\n";
          case NewlineKind.OsDefault:
            return os.EOL;
          default:
            throw new Error("Unsupported newline kind");
        }
      }
      /**
       * Append characters to the end of a string to ensure the result has a minimum length.
       * @remarks
       * If the string length already exceeds the minimum length, then the string is unchanged.
       * The string is not truncated.
       */
      static padEnd(s, minimumLength, paddingCharacter = " ") {
        if (paddingCharacter.length !== 1) {
          throw new Error("The paddingCharacter parameter must be a single character.");
        }
        if (s.length < minimumLength) {
          const paddingArray = new Array(minimumLength - s.length);
          paddingArray.unshift(s);
          return paddingArray.join(paddingCharacter);
        } else {
          return s;
        }
      }
      /**
       * Append characters to the start of a string to ensure the result has a minimum length.
       * @remarks
       * If the string length already exceeds the minimum length, then the string is unchanged.
       * The string is not truncated.
       */
      static padStart(s, minimumLength, paddingCharacter = " ") {
        if (paddingCharacter.length !== 1) {
          throw new Error("The paddingCharacter parameter must be a single character.");
        }
        if (s.length < minimumLength) {
          const paddingArray = new Array(minimumLength - s.length);
          paddingArray.push(s);
          return paddingArray.join(paddingCharacter);
        } else {
          return s;
        }
      }
      /**
       * If the string is longer than maximumLength characters, truncate it to that length
       * using "..." to indicate the truncation.
       *
       * @remarks
       * For example truncateWithEllipsis('1234578', 5) would produce '12...'.
       */
      static truncateWithEllipsis(s, maximumLength) {
        if (maximumLength < 0) {
          throw new Error("The maximumLength cannot be a negative number");
        }
        if (s.length <= maximumLength) {
          return s;
        }
        if (s.length <= 3) {
          return s.substring(0, maximumLength);
        }
        return s.substring(0, maximumLength - 3) + "...";
      }
      /**
       * Returns the input string with a trailing `\n` character appended, if not already present.
       */
      static ensureTrailingNewline(s, newlineKind = NewlineKind.Lf) {
        if (_Text._newLineAtEndRegEx.test(s)) {
          return s;
        }
        return s + newlineKind;
      }
      /**
       * Escapes a string so that it can be treated as a literal string when used in a regular expression.
       */
      static escapeRegExp(literal) {
        return literal.replace(/[^A-Za-z0-9_]/g, "\\$&");
      }
      /**
       * Read lines from an iterable object that returns strings or buffers, and return a generator that
       * produces the lines as strings. The lines will not include the newline characters.
       *
       * @param iterable - An iterable object that returns strings or buffers
       * @param options - Options used when reading the lines from the provided iterable
       */
      static readLinesFromIterableAsync(iterable, options = {}) {
        return __asyncGenerator(this, arguments, function* readLinesFromIterableAsync_1() {
          var _a, e_1, _b, _c;
          const { encoding = Encoding.Utf8, ignoreEmptyLines = false } = options;
          const state = { remaining: "" };
          try {
            for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), _a = iterable_1_1.done, !_a; _d = true) {
              _c = iterable_1_1.value;
              _d = false;
              const chunk = _c;
              yield __await(yield* __asyncDelegator(__asyncValues(readLinesFromChunk(chunk, encoding, ignoreEmptyLines, state))));
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = iterable_1.return))
                yield __await(_b.call(iterable_1));
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          const remaining = state.remaining;
          if (remaining.length) {
            yield yield __await(remaining);
          }
        });
      }
      /**
       * Read lines from an iterable object that returns strings or buffers, and return a generator that
       * produces the lines as strings. The lines will not include the newline characters.
       *
       * @param iterable - An iterable object that returns strings or buffers
       * @param options - Options used when reading the lines from the provided iterable
       */
      static *readLinesFromIterable(iterable, options = {}) {
        const { encoding = Encoding.Utf8, ignoreEmptyLines = false } = options;
        const state = { remaining: "" };
        for (const chunk of iterable) {
          yield* readLinesFromChunk(chunk, encoding, ignoreEmptyLines, state);
        }
        const remaining = state.remaining;
        if (remaining.length) {
          yield remaining;
        }
      }
      /**
       * Returns a new string that is the input string with the order of characters reversed.
       */
      static reverse(s) {
        return s.split("").reduce((newString, char) => char + newString, "");
      }
    };
    exports.Text = Text;
    Text._newLineRegEx = NEWLINE_REGEX;
    Text._newLineAtEndRegEx = NEWLINE_AT_END_REGEX;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/PosixModeBits.js
var require_PosixModeBits = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/PosixModeBits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PosixModeBits = void 0;
    var PosixModeBits;
    (function(PosixModeBits2) {
      PosixModeBits2[PosixModeBits2["UserRead"] = 256] = "UserRead";
      PosixModeBits2[PosixModeBits2["UserWrite"] = 128] = "UserWrite";
      PosixModeBits2[PosixModeBits2["UserExecute"] = 64] = "UserExecute";
      PosixModeBits2[PosixModeBits2["GroupRead"] = 32] = "GroupRead";
      PosixModeBits2[PosixModeBits2["GroupWrite"] = 16] = "GroupWrite";
      PosixModeBits2[PosixModeBits2["GroupExecute"] = 8] = "GroupExecute";
      PosixModeBits2[PosixModeBits2["OthersRead"] = 4] = "OthersRead";
      PosixModeBits2[PosixModeBits2["OthersWrite"] = 2] = "OthersWrite";
      PosixModeBits2[PosixModeBits2["OthersExecute"] = 1] = "OthersExecute";
      PosixModeBits2[PosixModeBits2["None"] = 0] = "None";
      PosixModeBits2[PosixModeBits2["AllRead"] = 292] = "AllRead";
      PosixModeBits2[PosixModeBits2["AllWrite"] = 146] = "AllWrite";
      PosixModeBits2[PosixModeBits2["AllExecute"] = 73] = "AllExecute";
    })(PosixModeBits || (exports.PosixModeBits = PosixModeBits = {}));
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/LegacyAdapters.js
var require_LegacyAdapters = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/LegacyAdapters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyAdapters = void 0;
    var LegacyAdapters = class _LegacyAdapters {
      static convertCallbackToPromise(fn, arg1, arg2, arg3, arg4) {
        return new Promise((resolve4, reject) => {
          const cb = (error, result) => {
            if (error) {
              reject(_LegacyAdapters.scrubError(error));
            } else {
              resolve4(result);
            }
          };
          try {
            if (arg1 !== void 0 && arg2 !== void 0 && arg3 !== void 0 && arg4 !== void 0) {
              fn(arg1, arg2, arg3, arg4, cb);
            } else if (arg1 !== void 0 && arg2 !== void 0 && arg3 !== void 0) {
              fn(arg1, arg2, arg3, cb);
            } else if (arg1 !== void 0 && arg2 !== void 0) {
              fn(arg1, arg2, cb);
            } else if (arg1 !== void 0) {
              fn(arg1, cb);
            } else {
              fn(cb);
            }
          } catch (e) {
            reject(e);
          }
        });
      }
      /**
       * Normalizes an object into an `Error` object.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static scrubError(error) {
        if (error instanceof Error) {
          return error;
        } else if (typeof error === "string") {
          return new Error(error);
        } else {
          const errorObject = new Error("An error occurred.");
          errorObject.errorData = error;
          return errorObject;
        }
      }
      /**
       * Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.
       * If you need a stable sort, you can use `sortStable()` as a workaround.
       *
       * @deprecated
       * Use native Array.sort(), since Node &lt; 14 is no longer supported
       * @remarks
       * On NodeJS 11.x and later, this method simply calls the native `Array.sort()`.
       */
      static sortStable(array, compare) {
        Array.prototype.sort.call(array, compare);
      }
    };
    exports.LegacyAdapters = LegacyAdapters;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/FileSystem.js
var require_FileSystem = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/FileSystem.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileSystem = exports.AlreadyExistsBehavior = void 0;
    var nodeJsPath = __importStar(__require("path"));
    var fs3 = __importStar(__require("fs"));
    var fsx = __importStar(require_lib());
    var Text_1 = require_Text();
    var PosixModeBits_1 = require_PosixModeBits();
    var LegacyAdapters_1 = require_LegacyAdapters();
    var AlreadyExistsBehavior;
    (function(AlreadyExistsBehavior2) {
      AlreadyExistsBehavior2["Overwrite"] = "overwrite";
      AlreadyExistsBehavior2["Error"] = "error";
      AlreadyExistsBehavior2["Ignore"] = "ignore";
    })(AlreadyExistsBehavior || (exports.AlreadyExistsBehavior = AlreadyExistsBehavior = {}));
    var MOVE_DEFAULT_OPTIONS = {
      overwrite: true,
      ensureFolderExists: false
    };
    var READ_FOLDER_DEFAULT_OPTIONS = {
      absolutePaths: false
    };
    var WRITE_FILE_DEFAULT_OPTIONS = {
      ensureFolderExists: false,
      convertLineEndings: void 0,
      encoding: Text_1.Encoding.Utf8
    };
    var APPEND_TO_FILE_DEFAULT_OPTIONS = Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS);
    var READ_FILE_DEFAULT_OPTIONS = {
      encoding: Text_1.Encoding.Utf8,
      convertLineEndings: void 0
    };
    var COPY_FILE_DEFAULT_OPTIONS = {
      alreadyExistsBehavior: AlreadyExistsBehavior.Overwrite
    };
    var COPY_FILES_DEFAULT_OPTIONS = {
      alreadyExistsBehavior: AlreadyExistsBehavior.Overwrite
    };
    var DELETE_FILE_DEFAULT_OPTIONS = {
      throwIfNotExists: false
    };
    var FileSystem4 = class _FileSystem {
      // ===============
      // COMMON OPERATIONS
      // ===============
      /**
       * Returns true if the path exists on disk.
       * Behind the scenes it uses `fs.existsSync()`.
       * @remarks
       * There is a debate about the fact that after `fs.existsSync()` returns true,
       * the file might be deleted before fs.readSync() is called, which would imply that everybody
       * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.
       * We find this to be unpersuasive, since "unexceptional exceptions" really hinder the
       * break-on-exception debugging experience. Also, throwing/catching is generally slow.
       * @param path - The absolute or relative path to the filesystem object.
       */
      static exists(path9) {
        return _FileSystem._wrapException(() => {
          return fsx.existsSync(path9);
        });
      }
      /**
       * An async version of {@link FileSystem.exists}.
       */
      static async existsAsync(path9) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return new Promise((resolve4) => {
            fsx.exists(path9, resolve4);
          });
        });
      }
      /**
       * Gets the statistics for a particular filesystem object.
       * If the path is a link, this function follows the link and returns statistics about the link target.
       * Behind the scenes it uses `fs.statSync()`.
       * @param path - The absolute or relative path to the filesystem object.
       */
      static getStatistics(path9) {
        return _FileSystem._wrapException(() => {
          return fsx.statSync(path9);
        });
      }
      /**
       * An async version of {@link FileSystem.getStatistics}.
       */
      static async getStatisticsAsync(path9) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return fsx.stat(path9);
        });
      }
      /**
       * Updates the accessed and modified timestamps of the filesystem object referenced by path.
       * Behind the scenes it uses `fs.utimesSync()`.
       * The caller should specify both times in the `times` parameter.
       * @param path - The path of the file that should be modified.
       * @param times - The times that the object should be updated to reflect.
       */
      static updateTimes(path9, times) {
        return _FileSystem._wrapException(() => {
          fsx.utimesSync(path9, times.accessedTime, times.modifiedTime);
        });
      }
      /**
       * An async version of {@link FileSystem.updateTimes}.
       */
      static async updateTimesAsync(path9, times) {
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.utimes(path9, times.accessedTime, times.modifiedTime);
        });
      }
      /**
       * Changes the permissions (i.e. file mode bits) for a filesystem object.
       * Behind the scenes it uses `fs.chmodSync()`.
       * @param path - The absolute or relative path to the object that should be updated.
       * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
       */
      static changePosixModeBits(path9, modeBits) {
        _FileSystem._wrapException(() => {
          fs3.chmodSync(path9, modeBits);
        });
      }
      /**
       * An async version of {@link FileSystem.changePosixModeBits}.
       */
      static async changePosixModeBitsAsync(path9, mode) {
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.chmod(path9, mode);
        });
      }
      /**
       * Retrieves the permissions (i.e. file mode bits) for a filesystem object.
       * Behind the scenes it uses `fs.chmodSync()`.
       * @param path - The absolute or relative path to the object that should be updated.
       *
       * @remarks
       * This calls {@link FileSystem.getStatistics} to get the POSIX mode bits.
       * If statistics in addition to the mode bits are needed, it is more efficient
       * to call {@link FileSystem.getStatistics} directly instead.
       */
      static getPosixModeBits(path9) {
        return _FileSystem._wrapException(() => {
          return _FileSystem.getStatistics(path9).mode;
        });
      }
      /**
       * An async version of {@link FileSystem.getPosixModeBits}.
       */
      static async getPosixModeBitsAsync(path9) {
        return await _FileSystem._wrapExceptionAsync(async () => {
          return (await _FileSystem.getStatisticsAsync(path9)).mode;
        });
      }
      /**
       * Returns a 10-character string representation of a PosixModeBits value similar to what
       * would be displayed by a command such as "ls -l" on a POSIX-like operating system.
       * @remarks
       * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as "-rw-rw-rw-".
       * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
       */
      static formatPosixModeBits(modeBits) {
        let result = "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.UserRead ? "r" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.UserWrite ? "w" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.UserExecute ? "x" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.GroupRead ? "r" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.GroupWrite ? "w" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.GroupExecute ? "x" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.OthersRead ? "r" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.OthersWrite ? "w" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.OthersExecute ? "x" : "-";
        return result;
      }
      /**
       * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.
       * Behind the scenes it uses `fs-extra.moveSync()`
       */
      static move(options) {
        _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
          try {
            fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(options.destinationPath);
              _FileSystem.ensureFolder(folderPath);
              fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            } else {
              throw error;
            }
          }
        });
      }
      /**
       * An async version of {@link FileSystem.move}.
       */
      static async moveAsync(options) {
        await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
          try {
            await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(options.destinationPath);
              await _FileSystem.ensureFolderAsync(nodeJsPath.dirname(folderPath));
              await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            } else {
              throw error;
            }
          }
        });
      }
      // ===============
      // FOLDER OPERATIONS
      // ===============
      /**
       * Recursively creates a folder at a given path.
       * Behind the scenes is uses `fs-extra.ensureDirSync()`.
       * @remarks
       * Throws an exception if anything in the folderPath is not a folder.
       * @param folderPath - The absolute or relative path of the folder which should be created.
       */
      static ensureFolder(folderPath) {
        _FileSystem._wrapException(() => {
          fsx.ensureDirSync(folderPath);
        });
      }
      /**
       * An async version of {@link FileSystem.ensureFolder}.
       */
      static async ensureFolderAsync(folderPath) {
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.ensureDir(folderPath);
        });
      }
      /**
       * @deprecated
       * Use {@link FileSystem.readFolderItemNames} instead.
       */
      static readFolder(folderPath, options) {
        return _FileSystem.readFolderItemNames(folderPath, options);
      }
      /**
       * @deprecated
       * Use {@link FileSystem.readFolderItemNamesAsync} instead.
       */
      static async readFolderAsync(folderPath, options) {
        return await _FileSystem.readFolderItemNamesAsync(folderPath, options);
      }
      /**
       * Reads the names of folder entries, not including "." or "..".
       * Behind the scenes it uses `fs.readdirSync()`.
       * @param folderPath - The absolute or relative path to the folder which should be read.
       * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`
       */
      static readFolderItemNames(folderPath, options) {
        return _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
          const fileNames = fsx.readdirSync(folderPath);
          if (options.absolutePaths) {
            return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
          } else {
            return fileNames;
          }
        });
      }
      /**
       * An async version of {@link FileSystem.readFolderItemNames}.
       */
      static async readFolderItemNamesAsync(folderPath, options) {
        return await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
          const fileNames = await fsx.readdir(folderPath);
          if (options.absolutePaths) {
            return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
          } else {
            return fileNames;
          }
        });
      }
      /**
       * Reads the contents of the folder, not including "." or "..", returning objects including the
       * entry names and types.
       * Behind the scenes it uses `fs.readdirSync()`.
       * @param folderPath - The absolute or relative path to the folder which should be read.
       * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`
       */
      static readFolderItems(folderPath, options) {
        return _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
          const folderEntries = fsx.readdirSync(folderPath, { withFileTypes: true });
          if (options.absolutePaths) {
            return folderEntries.map((folderEntry) => {
              folderEntry.name = nodeJsPath.resolve(folderPath, folderEntry.name);
              return folderEntry;
            });
          } else {
            return folderEntries;
          }
        });
      }
      /**
       * An async version of {@link FileSystem.readFolderItems}.
       */
      static async readFolderItemsAsync(folderPath, options) {
        return await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
          const folderEntries = await LegacyAdapters_1.LegacyAdapters.convertCallbackToPromise(fs3.readdir, folderPath, { withFileTypes: true });
          if (options.absolutePaths) {
            return folderEntries.map((folderEntry) => {
              folderEntry.name = nodeJsPath.resolve(folderPath, folderEntry.name);
              return folderEntry;
            });
          } else {
            return folderEntries;
          }
        });
      }
      /**
       * Deletes a folder, including all of its contents.
       * Behind the scenes is uses `fs-extra.removeSync()`.
       * @remarks
       * Does not throw if the folderPath does not exist.
       * @param folderPath - The absolute or relative path to the folder which should be deleted.
       */
      static deleteFolder(folderPath) {
        _FileSystem._wrapException(() => {
          fsx.removeSync(folderPath);
        });
      }
      /**
       * An async version of {@link FileSystem.deleteFolder}.
       */
      static async deleteFolderAsync(folderPath) {
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.remove(folderPath);
        });
      }
      /**
       * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.
       * Behind the scenes it uses `fs-extra.emptyDirSync()`.
       * @remarks
       * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder
       * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.
       * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.
       */
      static ensureEmptyFolder(folderPath) {
        _FileSystem._wrapException(() => {
          fsx.emptyDirSync(folderPath);
        });
      }
      /**
       * An async version of {@link FileSystem.ensureEmptyFolder}.
       */
      static async ensureEmptyFolderAsync(folderPath) {
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.emptyDir(folderPath);
        });
      }
      // ===============
      // FILE OPERATIONS
      // ===============
      /**
       * Writes a text string to a file on disk, overwriting the file if it already exists.
       * Behind the scenes it uses `fs.writeFileSync()`.
       * @remarks
       * Throws an error if the folder doesn't exist, unless ensureFolder=true.
       * @param filePath - The absolute or relative path of the file.
       * @param contents - The text that should be written to the file.
       * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
       */
      static writeFile(filePath, contents, options) {
        _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
          }
          try {
            fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(filePath);
              _FileSystem.ensureFolder(folderPath);
              fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
            } else {
              throw error;
            }
          }
        });
      }
      /**
       * An async version of {@link FileSystem.writeFile}.
       */
      static async writeFileAsync(filePath, contents, options) {
        await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
          }
          try {
            await fsx.writeFile(filePath, contents, { encoding: options.encoding });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(filePath);
              await _FileSystem.ensureFolderAsync(folderPath);
              await fsx.writeFile(filePath, contents, { encoding: options.encoding });
            } else {
              throw error;
            }
          }
        });
      }
      /**
       * Writes a text string to a file on disk, appending to the file if it already exists.
       * Behind the scenes it uses `fs.appendFileSync()`.
       * @remarks
       * Throws an error if the folder doesn't exist, unless ensureFolder=true.
       * @param filePath - The absolute or relative path of the file.
       * @param contents - The text that should be written to the file.
       * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
       */
      static appendToFile(filePath, contents, options) {
        _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
          }
          try {
            fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(filePath);
              _FileSystem.ensureFolder(folderPath);
              fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
            } else {
              throw error;
            }
          }
        });
      }
      /**
       * An async version of {@link FileSystem.appendToFile}.
       */
      static async appendToFileAsync(filePath, contents, options) {
        await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
          }
          try {
            await fsx.appendFile(filePath, contents, { encoding: options.encoding });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(filePath);
              await _FileSystem.ensureFolderAsync(folderPath);
              await fsx.appendFile(filePath, contents, { encoding: options.encoding });
            } else {
              throw error;
            }
          }
        });
      }
      /**
       * Reads the contents of a file into a string.
       * Behind the scenes it uses `fs.readFileSync()`.
       * @param filePath - The relative or absolute path to the file whose contents should be read.
       * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`
       */
      static readFile(filePath, options) {
        return _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
          let contents = _FileSystem.readFileToBuffer(filePath).toString(options.encoding);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
          }
          return contents;
        });
      }
      /**
       * An async version of {@link FileSystem.readFile}.
       */
      static async readFileAsync(filePath, options) {
        return await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
          let contents = (await _FileSystem.readFileToBufferAsync(filePath)).toString(options.encoding);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
          }
          return contents;
        });
      }
      /**
       * Reads the contents of a file into a buffer.
       * Behind the scenes is uses `fs.readFileSync()`.
       * @param filePath - The relative or absolute path to the file whose contents should be read.
       */
      static readFileToBuffer(filePath) {
        return _FileSystem._wrapException(() => {
          return fsx.readFileSync(filePath);
        });
      }
      /**
       * An async version of {@link FileSystem.readFileToBuffer}.
       */
      static async readFileToBufferAsync(filePath) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return fsx.readFile(filePath);
        });
      }
      /**
       * Copies a single file from one location to another.
       * By default, destinationPath is overwritten if it already exists.
       *
       * @remarks
       * The `copyFile()` API cannot be used to copy folders.  It copies at most one file.
       * Use {@link FileSystem.copyFiles} if you need to recursively copy a tree of folders.
       *
       * The implementation is based on `copySync()` from the `fs-extra` package.
       */
      static copyFile(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (_FileSystem.getStatistics(options.sourcePath).isDirectory()) {
          throw new Error("The specified path refers to a folder; this operation expects a file object:\n" + options.sourcePath);
        }
        _FileSystem._wrapException(() => {
          fsx.copySync(options.sourcePath, options.destinationPath, {
            errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,
            overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite
          });
        });
      }
      /**
       * An async version of {@link FileSystem.copyFile}.
       */
      static async copyFileAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if ((await _FileSystem.getStatisticsAsync(options.sourcePath)).isDirectory()) {
          throw new Error("The specified path refers to a folder; this operation expects a file object:\n" + options.sourcePath);
        }
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.copy(options.sourcePath, options.destinationPath, {
            errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,
            overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite
          });
        });
      }
      /**
       * Copies a file or folder from one location to another, recursively copying any folder contents.
       * By default, destinationPath is overwritten if it already exists.
       *
       * @remarks
       * If you only intend to copy a single file, it is recommended to use {@link FileSystem.copyFile}
       * instead to more clearly communicate the intended operation.
       *
       * The implementation is based on `copySync()` from the `fs-extra` package.
       */
      static copyFiles(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        _FileSystem._wrapException(() => {
          fsx.copySync(options.sourcePath, options.destinationPath, {
            dereference: !!options.dereferenceSymlinks,
            errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,
            overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite,
            preserveTimestamps: !!options.preserveTimestamps,
            filter: options.filter
          });
        });
      }
      /**
       * An async version of {@link FileSystem.copyFiles}.
       */
      static async copyFilesAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        await _FileSystem._wrapExceptionAsync(async () => {
          await fsx.copy(options.sourcePath, options.destinationPath, {
            dereference: !!options.dereferenceSymlinks,
            errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,
            overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite,
            preserveTimestamps: !!options.preserveTimestamps,
            filter: options.filter
          });
        });
      }
      /**
       * Deletes a file. Can optionally throw if the file doesn't exist.
       * Behind the scenes it uses `fs.unlinkSync()`.
       * @param filePath - The absolute or relative path to the file that should be deleted.
       * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`
       */
      static deleteFile(filePath, options) {
        _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
          try {
            fsx.unlinkSync(filePath);
          } catch (error) {
            if (options.throwIfNotExists || !_FileSystem.isNotExistError(error)) {
              throw error;
            }
          }
        });
      }
      /**
       * An async version of {@link FileSystem.deleteFile}.
       */
      static async deleteFileAsync(filePath, options) {
        await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
          try {
            await fsx.unlink(filePath);
          } catch (error) {
            if (options.throwIfNotExists || !_FileSystem.isNotExistError(error)) {
              throw error;
            }
          }
        });
      }
      // ===============
      // LINK OPERATIONS
      // ===============
      /**
       * Gets the statistics of a filesystem object. Does NOT follow the link to its target.
       * Behind the scenes it uses `fs.lstatSync()`.
       * @param path - The absolute or relative path to the filesystem object.
       */
      static getLinkStatistics(path9) {
        return _FileSystem._wrapException(() => {
          return fsx.lstatSync(path9);
        });
      }
      /**
       * An async version of {@link FileSystem.getLinkStatistics}.
       */
      static async getLinkStatisticsAsync(path9) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return fsx.lstat(path9);
        });
      }
      /**
       * If `path` refers to a symbolic link, this returns the path of the link target, which may be
       * an absolute or relative path.
       *
       * @remarks
       * If `path` refers to a filesystem object that is not a symbolic link, then an `ErrnoException` is thrown
       * with code 'UNKNOWN'.  If `path` does not exist, then an `ErrnoException` is thrown with code `ENOENT`.
       *
       * @param path - The absolute or relative path to the symbolic link.
       * @returns the path of the link target
       */
      static readLink(path9) {
        return _FileSystem._wrapException(() => {
          return fsx.readlinkSync(path9);
        });
      }
      /**
       * An async version of {@link FileSystem.readLink}.
       */
      static async readLinkAsync(path9) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return fsx.readlink(path9);
        });
      }
      /**
       * Creates an NTFS "directory junction" on Windows operating systems; for other operating systems, it
       * creates a regular symbolic link.  The link target must be a folder, not a file.
       * Behind the scenes it uses `fs.symlinkSync()`.
       *
       * @remarks
       * For security reasons, Windows operating systems by default require administrator elevation to create
       * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
       * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
       * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
       * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
       * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
       * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
       *
       * A directory junction requires the link source and target to both be located on local disk volumes;
       * if not, use a symbolic link instead.
       */
      static createSymbolicLinkJunction(options) {
        _FileSystem._wrapException(() => {
          return _FileSystem._handleLink(() => {
            return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, "junction");
          }, options);
        });
      }
      /**
       * An async version of {@link FileSystem.createSymbolicLinkJunction}.
       */
      static async createSymbolicLinkJunctionAsync(options) {
        await _FileSystem._wrapExceptionAsync(() => {
          return _FileSystem._handleLinkAsync(() => {
            return fsx.symlink(options.linkTargetPath, options.newLinkPath, "junction");
          }, options);
        });
      }
      /**
       * Creates a symbolic link to a file.  On Windows operating systems, this may require administrator elevation.
       * Behind the scenes it uses `fs.symlinkSync()`.
       *
       * @remarks
       * To avoid administrator elevation on Windows, use {@link FileSystem.createHardLink} instead.
       *
       * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
       * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
       * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
       * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
       * tool incompatible with Windows.
       */
      static createSymbolicLinkFile(options) {
        _FileSystem._wrapException(() => {
          return _FileSystem._handleLink(() => {
            return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, "file");
          }, options);
        });
      }
      /**
       * An async version of {@link FileSystem.createSymbolicLinkFile}.
       */
      static async createSymbolicLinkFileAsync(options) {
        await _FileSystem._wrapExceptionAsync(() => {
          return _FileSystem._handleLinkAsync(() => {
            return fsx.symlink(options.linkTargetPath, options.newLinkPath, "file");
          }, options);
        });
      }
      /**
       * Creates a symbolic link to a folder.  On Windows operating systems, this may require administrator elevation.
       * Behind the scenes it uses `fs.symlinkSync()`.
       *
       * @remarks
       * To avoid administrator elevation on Windows, use {@link FileSystem.createSymbolicLinkJunction} instead.
       *
       * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
       * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
       * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
       * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
       * tool incompatible with Windows.
       */
      static createSymbolicLinkFolder(options) {
        _FileSystem._wrapException(() => {
          return _FileSystem._handleLink(() => {
            return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, "dir");
          }, options);
        });
      }
      /**
       * An async version of {@link FileSystem.createSymbolicLinkFolder}.
       */
      static async createSymbolicLinkFolderAsync(options) {
        await _FileSystem._wrapExceptionAsync(() => {
          return _FileSystem._handleLinkAsync(() => {
            return fsx.symlink(options.linkTargetPath, options.newLinkPath, "dir");
          }, options);
        });
      }
      /**
       * Creates a hard link.  The link target must be a file, not a folder.
       * Behind the scenes it uses `fs.linkSync()`.
       *
       * @remarks
       * For security reasons, Windows operating systems by default require administrator elevation to create
       * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
       * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
       * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
       * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
       * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
       * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
       *
       * A hard link requires the link source and target to both be located on same disk volume;
       * if not, use a symbolic link instead.
       */
      static createHardLink(options) {
        _FileSystem._wrapException(() => {
          return _FileSystem._handleLink(() => {
            return fsx.linkSync(options.linkTargetPath, options.newLinkPath);
          }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
      }
      /**
       * An async version of {@link FileSystem.createHardLink}.
       */
      static async createHardLinkAsync(options) {
        await _FileSystem._wrapExceptionAsync(() => {
          return _FileSystem._handleLinkAsync(() => {
            return fsx.link(options.linkTargetPath, options.newLinkPath);
          }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
      }
      /**
       * Follows a link to its destination and returns the absolute path to the final target of the link.
       * Behind the scenes it uses `fs.realpathSync()`.
       * @param linkPath - The path to the link.
       */
      static getRealPath(linkPath) {
        return _FileSystem._wrapException(() => {
          return fsx.realpathSync(linkPath);
        });
      }
      /**
       * An async version of {@link FileSystem.getRealPath}.
       */
      static async getRealPathAsync(linkPath) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return fsx.realpath(linkPath);
        });
      }
      // ===============
      // UTILITY FUNCTIONS
      // ===============
      /**
       * Returns true if the error object indicates the file or folder already exists (`EEXIST`).
       */
      static isExistError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "EEXIST";
      }
      /**
       * Returns true if the error object indicates the file or folder does not exist (`ENOENT` or `ENOTDIR`)
       */
      static isNotExistError(error) {
        return _FileSystem.isFileDoesNotExistError(error) || _FileSystem.isFolderDoesNotExistError(error);
      }
      /**
       * Returns true if the error object indicates the file does not exist (`ENOENT`).
       */
      static isFileDoesNotExistError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "ENOENT";
      }
      /**
       * Returns true if the error object indicates the folder does not exist (`ENOTDIR`).
       */
      static isFolderDoesNotExistError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "ENOTDIR";
      }
      /**
       * Returns true if the error object indicates the target is a directory (`EISDIR`).
       */
      static isDirectoryError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "EISDIR";
      }
      /**
       * Returns true if the error object indicates the target is not a directory (`ENOTDIR`).
       */
      static isNotDirectoryError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "ENOTDIR";
      }
      /**
       * Returns true if the error object indicates that the `unlink` system call failed
       * due to a permissions issue (`EPERM`).
       */
      static isUnlinkNotPermittedError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "EPERM" && error.syscall === "unlink";
      }
      /**
       * Detects if the provided error object is a `NodeJS.ErrnoException`
       */
      static isErrnoException(error) {
        const typedError = error;
        return typeof typedError.code === "string" && typeof typedError.errno === "number" && typeof typedError.path === "string" && typeof typedError.syscall === "string";
      }
      static _handleLink(linkFn, options) {
        try {
          linkFn();
        } catch (error) {
          if (_FileSystem.isExistError(error)) {
            switch (options.alreadyExistsBehavior) {
              case AlreadyExistsBehavior.Ignore:
                break;
              case AlreadyExistsBehavior.Overwrite:
                this.deleteFile(options.newLinkPath);
                linkFn();
                break;
              case AlreadyExistsBehavior.Error:
              default:
                throw error;
            }
          } else {
            if (_FileSystem.isNotExistError(error) && (!options.linkTargetMustExist || _FileSystem.exists(options.linkTargetPath))) {
              this.ensureFolder(nodeJsPath.dirname(options.newLinkPath));
              linkFn();
            } else {
              throw error;
            }
          }
        }
      }
      static async _handleLinkAsync(linkFn, options) {
        try {
          await linkFn();
        } catch (error) {
          if (_FileSystem.isExistError(error)) {
            switch (options.alreadyExistsBehavior) {
              case AlreadyExistsBehavior.Ignore:
                break;
              case AlreadyExistsBehavior.Overwrite:
                await this.deleteFileAsync(options.newLinkPath);
                await linkFn();
                break;
              case AlreadyExistsBehavior.Error:
              default:
                throw error;
            }
          } else {
            if (_FileSystem.isNotExistError(error) && (!options.linkTargetMustExist || await _FileSystem.existsAsync(options.linkTargetPath))) {
              await this.ensureFolderAsync(nodeJsPath.dirname(options.newLinkPath));
              await linkFn();
            } else {
              throw error;
            }
          }
        }
      }
      static _wrapException(fn) {
        try {
          return fn();
        } catch (error) {
          _FileSystem._updateErrorMessage(error);
          throw error;
        }
      }
      static async _wrapExceptionAsync(fn) {
        try {
          return await fn();
        } catch (error) {
          _FileSystem._updateErrorMessage(error);
          throw error;
        }
      }
      static _updateErrorMessage(error) {
        if (_FileSystem.isErrnoException(error)) {
          if (_FileSystem.isFileDoesNotExistError(error)) {
            error.message = `File does not exist: ${error.path}
${error.message}`;
          } else if (_FileSystem.isFolderDoesNotExistError(error)) {
            error.message = `Folder does not exist: ${error.path}
${error.message}`;
          } else if (_FileSystem.isExistError(error)) {
            const extendedError = error;
            error.message = `File or folder already exists: ${extendedError.dest}
${error.message}`;
          } else if (_FileSystem.isUnlinkNotPermittedError(error)) {
            error.message = `File or folder could not be deleted: ${error.path}
${error.message}`;
          } else if (_FileSystem.isDirectoryError(error)) {
            error.message = `Target is a folder, not a file: ${error.path}
${error.message}`;
          } else if (_FileSystem.isNotDirectoryError(error)) {
            error.message = `Target is not a folder: ${error.path}
${error.message}`;
          }
        }
      }
    };
    exports.FileSystem = FileSystem4;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Executable.js
var require_Executable = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Executable.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve4, reject) {
            v = o[n](v), settle(resolve4, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve4, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve4({ value: v2, done: d });
        }, reject);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Executable = exports.parseProcessListOutput = exports.parseProcessListOutputAsync = void 0;
    var os = __importStar(__require("os"));
    var child_process = __importStar(__require("child_process"));
    var path9 = __importStar(__require("path"));
    var EnvironmentMap_1 = require_EnvironmentMap();
    var FileSystem_1 = require_FileSystem();
    var PosixModeBits_1 = require_PosixModeBits();
    var Text_1 = require_Text();
    var InternalError_1 = require_InternalError();
    var OS_PLATFORM = os.platform();
    async function parseProcessListOutputAsync(stream, platform = OS_PLATFORM) {
      var _a, e_1, _b, _c;
      const processInfoById = /* @__PURE__ */ new Map();
      let seenHeaders = false;
      try {
        for (var _d = true, _e = __asyncValues(Text_1.Text.readLinesFromIterableAsync(stream, { ignoreEmptyLines: true })), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
          _c = _f.value;
          _d = false;
          const line = _c;
          if (!seenHeaders) {
            seenHeaders = true;
          } else {
            parseProcessInfoEntry(line, processInfoById, platform);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d && !_a && (_b = _e.return))
            await _b.call(_e);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return processInfoById;
    }
    exports.parseProcessListOutputAsync = parseProcessListOutputAsync;
    function parseProcessListOutput(output, platform = OS_PLATFORM) {
      const processInfoById = /* @__PURE__ */ new Map();
      let seenHeaders = false;
      for (const line of Text_1.Text.readLinesFromIterable(output, { ignoreEmptyLines: true })) {
        if (!seenHeaders) {
          seenHeaders = true;
        } else {
          parseProcessInfoEntry(line, processInfoById, platform);
        }
      }
      return processInfoById;
    }
    exports.parseProcessListOutput = parseProcessListOutput;
    var NAME_GROUP = "name";
    var PROCESS_ID_GROUP = "pid";
    var PARENT_PROCESS_ID_GROUP = "ppid";
    var PROCESS_LIST_ENTRY_REGEX_WIN32 = new RegExp(`^(?<${NAME_GROUP}>.+?)\\s+(?<${PARENT_PROCESS_ID_GROUP}>\\d+)\\s+(?<${PROCESS_ID_GROUP}>\\d+)\\s*$`);
    var PROCESS_LIST_ENTRY_REGEX_UNIX = new RegExp(`^\\s*(?<${PARENT_PROCESS_ID_GROUP}>\\d+)\\s+(?<${PROCESS_ID_GROUP}>\\d+)\\s+(?<${NAME_GROUP}>.+?)\\s*$`);
    function parseProcessInfoEntry(line, existingProcessInfoById, platform) {
      const processListEntryRegex = platform === "win32" ? PROCESS_LIST_ENTRY_REGEX_WIN32 : PROCESS_LIST_ENTRY_REGEX_UNIX;
      const match = line.match(processListEntryRegex);
      if (!(match === null || match === void 0 ? void 0 : match.groups)) {
        throw new InternalError_1.InternalError(`Invalid process list entry: ${line}`);
      }
      const processName = match.groups[NAME_GROUP];
      const processId = parseInt(match.groups[PROCESS_ID_GROUP], 10);
      const parentProcessId = parseInt(match.groups[PARENT_PROCESS_ID_GROUP], 10);
      let parentProcessInfo;
      if (parentProcessId !== processId) {
        parentProcessInfo = existingProcessInfoById.get(parentProcessId);
        if (!parentProcessInfo) {
          parentProcessInfo = {
            processName: "",
            processId: parentProcessId,
            parentProcessInfo: void 0,
            childProcessInfos: []
          };
          existingProcessInfoById.set(parentProcessId, parentProcessInfo);
        }
      }
      let processInfo = existingProcessInfoById.get(processId);
      if (!processInfo) {
        processInfo = {
          processName,
          processId,
          parentProcessInfo,
          childProcessInfos: []
        };
        existingProcessInfoById.set(processId, processInfo);
      } else {
        processInfo.processName = processName;
        processInfo.parentProcessInfo = parentProcessInfo;
      }
      parentProcessInfo === null || parentProcessInfo === void 0 ? void 0 : parentProcessInfo.childProcessInfos.push(processInfo);
    }
    function convertToProcessInfoByNameMap(processInfoById) {
      const processInfoByNameMap = /* @__PURE__ */ new Map();
      for (const processInfo of processInfoById.values()) {
        let processInfoNameEntries = processInfoByNameMap.get(processInfo.processName);
        if (!processInfoNameEntries) {
          processInfoNameEntries = [];
          processInfoByNameMap.set(processInfo.processName, processInfoNameEntries);
        }
        processInfoNameEntries.push(processInfo);
      }
      return processInfoByNameMap;
    }
    function getProcessListProcessOptions() {
      let command;
      let args;
      if (OS_PLATFORM === "win32") {
        command = "wmic.exe";
        args = ["process", "get", "Name,ParentProcessId,ProcessId"];
      } else {
        command = "ps";
        args = ["-Awo", "ppid,pid,comm"];
      }
      return { path: command, args };
    }
    var Executable = class _Executable {
      /**
       * Synchronously create a child process and optionally capture its output.
       *
       * @remarks
       * This function is similar to child_process.spawnSync().  The main differences are:
       *
       * - It does not invoke the OS shell unless the executable file is a shell script.
       * - Command-line arguments containing special characters are more accurately passed
       *   through to the child process.
       * - If the filename is missing a path, then the shell's default PATH will be searched.
       * - If the filename is missing a file extension, then Windows default file extensions
       *   will be searched.
       *
       * @param filename - The name of the executable file.  This string must not contain any
       * command-line arguments.  If the name contains any path delimiters, then the shell's
       * default PATH will not be searched.
       * @param args - The command-line arguments to be passed to the process.
       * @param options - Additional options
       * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
       *
       * @privateRemarks
       *
       * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>
       * polymorphically based on the options.encoding parameter value.  This is a fairly confusing
       * design.  In most cases, developers want string with the default encoding.  If/when someone
       * wants binary output or a non-default text encoding, we will introduce a separate API function
       * with a name like "spawnWithBufferSync".
       */
      static spawnSync(filename, args, options) {
        if (!options) {
          options = {};
        }
        const context = _Executable._getExecutableContext(options);
        const resolvedPath = _Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
          throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
          cwd: context.currentWorkingDirectory,
          env: context.environmentMap.toObject(),
          input: options.input,
          stdio: options.stdio,
          timeout: options.timeoutMs,
          maxBuffer: options.maxBuffer,
          // Contrary to what the NodeJS typings imply, we must explicitly specify "utf8" here
          // if we want the result to be SpawnSyncReturns<string> instead of SpawnSyncReturns<Buffer>.
          encoding: "utf8",
          // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
          shell: false
        };
        const normalizedCommandLine = _Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawnSync(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
      }
      /**
       * Start a child process.
       *
       * @remarks
       * This function is similar to child_process.spawn().  The main differences are:
       *
       * - It does not invoke the OS shell unless the executable file is a shell script.
       * - Command-line arguments containing special characters are more accurately passed
       *   through to the child process.
       * - If the filename is missing a path, then the shell's default PATH will be searched.
       * - If the filename is missing a file extension, then Windows default file extensions
       *   will be searched.
       *
       * This command is asynchronous, but it does not return a `Promise`.  Instead it returns
       * a Node.js `ChildProcess` supporting event notifications.
       *
       * @param filename - The name of the executable file.  This string must not contain any
       * command-line arguments.  If the name contains any path delimiters, then the shell's
       * default PATH will not be searched.
       * @param args - The command-line arguments to be passed to the process.
       * @param options - Additional options
       * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
       */
      static spawn(filename, args, options) {
        if (!options) {
          options = {};
        }
        const context = _Executable._getExecutableContext(options);
        const resolvedPath = _Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
          throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
          cwd: context.currentWorkingDirectory,
          env: context.environmentMap.toObject(),
          stdio: options.stdio,
          // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
          shell: false
        };
        const normalizedCommandLine = _Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawn(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
      }
      static async waitForExitAsync(childProcess, options = {}) {
        const { throwOnNonZeroExitCode = false, encoding } = options;
        if (encoding && (!childProcess.stdout || !childProcess.stderr)) {
          throw new Error("An encoding was specified, but stdout and/or stderr on the child process are not defined");
        }
        const collectedStdout = [];
        const collectedStderr = [];
        const useBufferEncoding = encoding === "buffer";
        function normalizeChunk(chunk) {
          if (typeof chunk === "string") {
            return useBufferEncoding ? Buffer.from(chunk) : chunk;
          } else {
            return useBufferEncoding ? chunk : chunk.toString(encoding);
          }
        }
        let errorThrown = false;
        const exitCode = await new Promise((resolve4, reject) => {
          if (encoding) {
            childProcess.stdout.on("data", (chunk) => {
              collectedStdout.push(normalizeChunk(chunk));
            });
            childProcess.stderr.on("data", (chunk) => {
              collectedStderr.push(normalizeChunk(chunk));
            });
          }
          childProcess.on("error", (error) => {
            errorThrown = true;
            reject(error);
          });
          childProcess.on("exit", (code) => {
            if (errorThrown) {
              return;
            }
            if (code !== 0 && throwOnNonZeroExitCode) {
              reject(new Error(`Process exited with code ${code}`));
            } else {
              resolve4(code);
            }
          });
        });
        const result = {
          exitCode
        };
        if (encoding === "buffer") {
          result.stdout = Buffer.concat(collectedStdout);
          result.stderr = Buffer.concat(collectedStderr);
        } else if (encoding) {
          result.stdout = collectedStdout.join("");
          result.stderr = collectedStderr.join("");
        }
        return result;
      }
      /* eslint-enable @rushstack/no-new-null */
      /**
       * Get the list of processes currently running on the system, keyed by the process ID.
       *
       * @remarks The underlying implementation depends on the operating system:
       * - On Windows, this uses the `wmic.exe` utility.
       * - On Unix, this uses the `ps` utility.
       */
      static async getProcessInfoByIdAsync() {
        const { path: command, args } = getProcessListProcessOptions();
        const process3 = _Executable.spawn(command, args, {
          stdio: ["ignore", "pipe", "ignore"]
        });
        if (process3.stdout === null) {
          throw new InternalError_1.InternalError("Child process did not provide stdout");
        }
        const [processInfoByIdMap] = await Promise.all([
          parseProcessListOutputAsync(process3.stdout),
          // Don't collect output in the result since we process it directly
          _Executable.waitForExitAsync(process3, { throwOnNonZeroExitCode: true })
        ]);
        return processInfoByIdMap;
      }
      /**
       * {@inheritDoc Executable.getProcessInfoByIdAsync}
       */
      static getProcessInfoById() {
        const { path: command, args } = getProcessListProcessOptions();
        const processOutput = _Executable.spawnSync(command, args);
        if (processOutput.error) {
          throw new Error(`Unable to list processes: ${command} failed with error ${processOutput.error}`);
        }
        if (processOutput.status !== 0) {
          throw new Error(`Unable to list processes: ${command} exited with code ${processOutput.status}`);
        }
        return parseProcessListOutput(processOutput.output);
      }
      /**
       * Get the list of processes currently running on the system, keyed by the process name. All processes
       * with the same name will be grouped.
       *
       * @remarks The underlying implementation depends on the operating system:
       * - On Windows, this uses the `wmic.exe` utility.
       * - On Unix, this uses the `ps` utility.
       */
      static async getProcessInfoByNameAsync() {
        const processInfoById = await _Executable.getProcessInfoByIdAsync();
        return convertToProcessInfoByNameMap(processInfoById);
      }
      /**
       * {@inheritDoc Executable.getProcessInfoByNameAsync}
       */
      static getProcessInfoByName() {
        const processInfoByIdMap = _Executable.getProcessInfoById();
        return convertToProcessInfoByNameMap(processInfoByIdMap);
      }
      // PROBLEM: Given an "args" array of strings that may contain special characters (e.g. spaces,
      // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array
      // without anything getting corrupted along the way.
      //
      // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:
      // - The Win32 CreateProcess() API expects the args to be encoded as a single text string
      // - The decoding of this string is up to the application (not the OS), and there are 3 different
      //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and
      //   the Win32 CommandLineToArgvW()
      // - The encodings are counterintuitive and have lots of special cases
      // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used
      //
      // See these articles for a full analysis:
      // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/
      // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/
      static _buildCommandLineFixup(resolvedPath, args, context) {
        const fileExtension = path9.extname(resolvedPath);
        if (OS_PLATFORM === "win32") {
          switch (fileExtension.toUpperCase()) {
            case ".EXE":
            case ".COM":
              break;
            case ".BAT":
            case ".CMD": {
              _Executable._validateArgsForWindowsShell(args);
              let shellPath = context.environmentMap.get("COMSPEC");
              if (!shellPath || !_Executable._canExecute(shellPath, context)) {
                shellPath = _Executable.tryResolve("cmd.exe");
              }
              if (!shellPath) {
                throw new Error(`Unable to execute "${path9.basename(resolvedPath)}" because CMD.exe was not found in the PATH`);
              }
              const shellArgs = [];
              shellArgs.push("/d");
              shellArgs.push("/s");
              shellArgs.push("/c");
              shellArgs.push(_Executable._getEscapedForWindowsShell(resolvedPath));
              shellArgs.push(...args);
              return { path: shellPath, args: shellArgs };
            }
            default:
              throw new Error(`Cannot execute "${path9.basename(resolvedPath)}" because the file type is not supported`);
          }
        }
        return {
          path: resolvedPath,
          args
        };
      }
      /**
       * Given a filename, this determines the absolute path of the executable file that would
       * be executed by a shell:
       *
       * - If the filename is missing a path, then the shell's default PATH will be searched.
       * - If the filename is missing a file extension, then Windows default file extensions
       *   will be searched.
       *
       * @remarks
       *
       * @param filename - The name of the executable file.  This string must not contain any
       * command-line arguments.  If the name contains any path delimiters, then the shell's
       * default PATH will not be searched.
       * @param options - optional other parameters
       * @returns the absolute path of the executable, or undefined if it was not found
       */
      static tryResolve(filename, options) {
        return _Executable._tryResolve(filename, options || {}, _Executable._getExecutableContext(options));
      }
      static _tryResolve(filename, options, context) {
        const hasPathSeparators = filename.indexOf("/") >= 0 || OS_PLATFORM === "win32" && filename.indexOf("\\") >= 0;
        if (hasPathSeparators) {
          const resolvedPath = path9.resolve(context.currentWorkingDirectory, filename);
          return _Executable._tryResolveFileExtension(resolvedPath, context);
        } else {
          const pathsToSearch = _Executable._getSearchFolders(context);
          for (const pathToSearch of pathsToSearch) {
            const resolvedPath = path9.join(pathToSearch, filename);
            const result = _Executable._tryResolveFileExtension(resolvedPath, context);
            if (result) {
              return result;
            }
          }
          return void 0;
        }
      }
      static _tryResolveFileExtension(resolvedPath, context) {
        if (_Executable._canExecute(resolvedPath, context)) {
          return resolvedPath;
        }
        for (const shellExtension of context.windowsExecutableExtensions) {
          const resolvedNameWithExtension = resolvedPath + shellExtension;
          if (_Executable._canExecute(resolvedNameWithExtension, context)) {
            return resolvedNameWithExtension;
          }
        }
        return void 0;
      }
      static _buildEnvironmentMap(options) {
        const environmentMap = new EnvironmentMap_1.EnvironmentMap();
        if (options.environment !== void 0 && options.environmentMap !== void 0) {
          throw new Error("IExecutableResolveOptions.environment and IExecutableResolveOptions.environmentMap cannot both be specified");
        }
        if (options.environment !== void 0) {
          environmentMap.mergeFromObject(options.environment);
        } else if (options.environmentMap !== void 0) {
          environmentMap.mergeFrom(options.environmentMap);
        } else {
          environmentMap.mergeFromObject(process.env);
        }
        return environmentMap;
      }
      /**
       * This is used when searching the shell PATH for an executable, to determine
       * whether a match should be skipped or not.  If it returns true, this does not
       * guarantee that the file can be successfully executed.
       */
      static _canExecute(filePath, context) {
        if (!FileSystem_1.FileSystem.exists(filePath)) {
          return false;
        }
        if (OS_PLATFORM === "win32") {
          if (path9.extname(filePath) === "") {
            return false;
          }
        } else {
          try {
            if ((FileSystem_1.FileSystem.getPosixModeBits(filePath) & PosixModeBits_1.PosixModeBits.AllExecute) === 0) {
              return false;
            }
          } catch (error) {
          }
        }
        return true;
      }
      /**
       * Returns the list of folders where we will search for an executable,
       * based on the PATH environment variable.
       */
      static _getSearchFolders(context) {
        const pathList = context.environmentMap.get("PATH") || "";
        const folders = [];
        const seenPaths = /* @__PURE__ */ new Set();
        for (const splitPath of pathList.split(path9.delimiter)) {
          const trimmedPath = splitPath.trim();
          if (trimmedPath !== "") {
            if (!seenPaths.has(trimmedPath)) {
              const resolvedPath = path9.resolve(context.currentWorkingDirectory, trimmedPath);
              if (!seenPaths.has(resolvedPath)) {
                if (FileSystem_1.FileSystem.exists(resolvedPath)) {
                  folders.push(resolvedPath);
                }
                seenPaths.add(resolvedPath);
              }
              seenPaths.add(trimmedPath);
            }
          }
        }
        return folders;
      }
      static _getExecutableContext(options) {
        if (!options) {
          options = {};
        }
        const environment = _Executable._buildEnvironmentMap(options);
        let currentWorkingDirectory;
        if (options.currentWorkingDirectory) {
          currentWorkingDirectory = path9.resolve(options.currentWorkingDirectory);
        } else {
          currentWorkingDirectory = process.cwd();
        }
        const windowsExecutableExtensions = [];
        if (OS_PLATFORM === "win32") {
          const pathExtVariable = environment.get("PATHEXT") || "";
          for (const splitValue of pathExtVariable.split(";")) {
            const trimmed = splitValue.trim().toLowerCase();
            if (/^\.[a-z0-9\.]*[a-z0-9]$/i.test(trimmed)) {
              if (windowsExecutableExtensions.indexOf(trimmed) < 0) {
                windowsExecutableExtensions.push(trimmed);
              }
            }
          }
        }
        return {
          environmentMap: environment,
          currentWorkingDirectory,
          windowsExecutableExtensions
        };
      }
      /**
       * Given an input string containing special symbol characters, this inserts the "^" escape
       * character to ensure the symbols are interpreted literally by the Windows shell.
       */
      static _getEscapedForWindowsShell(text) {
        const escapableCharRegExp = /[%\^&|<> ]/g;
        return text.replace(escapableCharRegExp, (value) => "^" + value);
      }
      /**
       * Checks for characters that are unsafe to pass to a Windows batch file
       * due to the way that cmd.exe implements escaping.
       */
      static _validateArgsForWindowsShell(args) {
        const specialCharRegExp = /[%\^&|<>\r\n]/g;
        for (const arg of args) {
          const match = arg.match(specialCharRegExp);
          if (match) {
            throw new Error(`The command line argument ${JSON.stringify(arg)} contains a special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`);
          }
        }
      }
    };
    exports.Executable = Executable;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Path.js
var require_Path = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Path.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Path = void 0;
    var path9 = __importStar(__require("path"));
    var Path2 = class _Path {
      /**
       * Returns true if "childPath" is located inside the "parentFolderPath" folder
       * or one of its child folders.  Note that "parentFolderPath" is not considered to be
       * under itself.  The "childPath" can refer to any type of file system object.
       *
       * @remarks
       * The indicated file/folder objects are not required to actually exist on disk.
       * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
       * If the paths are relative, they will first be resolved using path.resolve().
       */
      static isUnder(childPath, parentFolderPath) {
        const relativePath = path9.relative(childPath, parentFolderPath);
        return _Path._relativePathRegex.test(relativePath);
      }
      /**
       * Returns true if "childPath" is equal to "parentFolderPath", or if it is inside that folder
       * or one of its children.  The "childPath" can refer to any type of file system object.
       *
       * @remarks
       * The indicated file/folder objects are not required to actually exist on disk.
       * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
       * If the paths are relative, they will first be resolved using path.resolve().
       */
      static isUnderOrEqual(childPath, parentFolderPath) {
        const relativePath = path9.relative(childPath, parentFolderPath);
        return relativePath === "" || _Path._relativePathRegex.test(relativePath);
      }
      /**
       * Returns true if `path1` and `path2` refer to the same underlying path.
       *
       * @remarks
       *
       * The comparison is performed using `path.relative()`.
       */
      static isEqual(path1, path22) {
        return path9.relative(path1, path22) === "";
      }
      /**
       * Formats a path to look nice for reporting purposes.
       * @remarks
       * If `pathToConvert` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix
       * unless the {@link IPathFormatConciselyOptions.trimLeadingDotSlash} option is set to `true`.
       * Otherwise, it will be converted to an absolute path.
       *
       * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\`.
       */
      static formatConcisely(options) {
        const relativePath = path9.relative(options.pathToConvert, options.baseFolder);
        const isUnderOrEqual = relativePath === "" || _Path._relativePathRegex.test(relativePath);
        if (isUnderOrEqual) {
          const convertedPath = _Path.convertToSlashes(path9.relative(options.baseFolder, options.pathToConvert));
          if (options.trimLeadingDotSlash) {
            return convertedPath;
          } else {
            return `./${convertedPath}`;
          }
        }
        const absolutePath = path9.resolve(options.pathToConvert);
        return absolutePath;
      }
      /**
       * Formats a file location to look nice for reporting purposes.
       * @remarks
       * If `pathToFormat` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix.
       * Otherwise, it will be converted to an absolute path.
       *
       * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\`.
       */
      static formatFileLocation(options) {
        const { message, format, pathToFormat, baseFolder, line, column } = options;
        const filePath = baseFolder ? _Path.formatConcisely({
          pathToConvert: pathToFormat,
          baseFolder,
          trimLeadingDotSlash: true
        }) : path9.resolve(pathToFormat);
        let formattedFileLocation;
        switch (format) {
          case "Unix": {
            if (line !== void 0 && column !== void 0) {
              formattedFileLocation = `:${line}:${column}`;
            } else if (line !== void 0) {
              formattedFileLocation = `:${line}`;
            } else {
              formattedFileLocation = "";
            }
            break;
          }
          case "VisualStudio": {
            if (line !== void 0 && column !== void 0) {
              formattedFileLocation = `(${line},${column})`;
            } else if (line !== void 0) {
              formattedFileLocation = `(${line})`;
            } else {
              formattedFileLocation = "";
            }
            break;
          }
          default: {
            throw new Error(`Unknown format: ${format}`);
          }
        }
        return `${filePath}${formattedFileLocation} - ${message}`;
      }
      /**
       * Replaces Windows-style backslashes with POSIX-style slashes.
       *
       * @remarks
       * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
       */
      static convertToSlashes(inputPath) {
        return inputPath.replace(/\\/g, "/");
      }
      /**
       * Replaces POSIX-style slashes with Windows-style backslashes
       *
       * @remarks
       * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
       */
      static convertToBackslashes(inputPath) {
        return inputPath.replace(/\//g, "\\");
      }
      /**
       * Replaces slashes or backslashes with the appropriate slash for the current operating system.
       */
      static convertToPlatformDefault(inputPath) {
        return path9.sep === "/" ? _Path.convertToSlashes(inputPath) : _Path.convertToBackslashes(inputPath);
      }
      /**
       * Returns true if the specified path is a relative path and does not use `..` to walk upwards.
       *
       * @example
       * ```ts
       * // These evaluate to true
       * isDownwardRelative('folder');
       * isDownwardRelative('file');
       * isDownwardRelative('folder/');
       * isDownwardRelative('./folder/');
       * isDownwardRelative('./folder/file');
       *
       * // These evaluate to false
       * isDownwardRelative('../folder');
       * isDownwardRelative('folder/../file');
       * isDownwardRelative('/folder/file');
       * ```
       */
      static isDownwardRelative(inputPath) {
        if (path9.isAbsolute(inputPath)) {
          return false;
        }
        if (_Path._upwardPathSegmentRegex.test(inputPath)) {
          return false;
        }
        return true;
      }
    };
    exports.Path = Path2;
    Path2._relativePathRegex = /^[.\/\\]+$/;
    Path2._upwardPathSegmentRegex = /([\/\\]|^)\.\.([\/\\]|$)/;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/FileError.js
var require_FileError = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/FileError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileError = void 0;
    var Path_1 = require_Path();
    var TypeUuid_1 = require_TypeUuid();
    var uuidFileError = "37a4c772-2dc8-4c66-89ae-262f8cc1f0c1";
    var baseFolderEnvVar = "RUSHSTACK_FILE_ERROR_BASE_FOLDER";
    var FileError = class _FileError extends Error {
      /**
       * Constructs a new instance of the {@link FileError} class.
       *
       * @param message - A message describing the error.
       * @param options - Options for the error.
       */
      constructor(message, options) {
        super(message);
        this.absolutePath = options.absolutePath;
        this.projectFolder = options.projectFolder;
        this.line = options.line;
        this.column = options.column;
        this.__proto__ = _FileError.prototype;
      }
      /**
       * Get the Unix-formatted the error message.
       *
       * @override
       */
      toString() {
        return this.getFormattedErrorMessage();
      }
      /**
       * Get the formatted error message.
       *
       * @param options - Options for the error message format.
       */
      getFormattedErrorMessage(options) {
        return Path_1.Path.formatFileLocation({
          format: (options === null || options === void 0 ? void 0 : options.format) || "Unix",
          baseFolder: this._evaluateBaseFolder(),
          pathToFormat: this.absolutePath,
          message: this.message,
          line: this.line,
          column: this.column
        });
      }
      _evaluateBaseFolder() {
        if (!_FileError._sanitizedEnvironmentVariable && process.env[baseFolderEnvVar]) {
          _FileError._sanitizedEnvironmentVariable = process.env[baseFolderEnvVar].replace(/^("|')|("|')$/g, "");
        }
        if (_FileError._environmentVariableIsAbsolutePath) {
          return _FileError._sanitizedEnvironmentVariable;
        }
        const baseFolderFn = _FileError._environmentVariableBasePathFnMap.get(_FileError._sanitizedEnvironmentVariable);
        if (baseFolderFn) {
          return baseFolderFn(this);
        }
        const baseFolderTokenRegex = /{([^}]+)}/g;
        const result = baseFolderTokenRegex.exec(_FileError._sanitizedEnvironmentVariable);
        if (!result) {
          _FileError._environmentVariableIsAbsolutePath = true;
          return _FileError._sanitizedEnvironmentVariable;
        } else if (result.index !== 0) {
          throw new Error(`The ${baseFolderEnvVar} environment variable contains text before the token "${result[0]}".`);
        } else if (result[0].length !== _FileError._sanitizedEnvironmentVariable.length) {
          throw new Error(`The ${baseFolderEnvVar} environment variable contains text after the token "${result[0]}".`);
        } else {
          throw new Error(`The ${baseFolderEnvVar} environment variable contains a token "${result[0]}", which is not supported.`);
        }
      }
      static [Symbol.hasInstance](instance) {
        return TypeUuid_1.TypeUuid.isInstanceOf(instance, uuidFileError);
      }
    };
    exports.FileError = FileError;
    FileError._environmentVariableIsAbsolutePath = false;
    FileError._environmentVariableBasePathFnMap = /* @__PURE__ */ new Map([
      [void 0, (fileError) => fileError.projectFolder],
      ["{PROJECT_FOLDER}", (fileError) => fileError.projectFolder],
      ["{ABSOLUTE_PATH}", (fileError) => void 0]
    ]);
    TypeUuid_1.TypeUuid.registerClass(FileError, uuidFileError);
  }
});

// ../../node_modules/import-lazy/index.js
var require_import_lazy = __commonJS({
  "../../node_modules/import-lazy/index.js"(exports, module) {
    "use strict";
    var lazy = (importedModule, importFn, moduleId) => importedModule === void 0 ? importFn(moduleId) : importedModule;
    module.exports = (importFn) => {
      return (moduleId) => {
        let importedModule;
        const handler2 = {
          get: (target, property) => {
            importedModule = lazy(importedModule, importFn, moduleId);
            return Reflect.get(importedModule, property);
          },
          apply: (target, thisArgument, argumentsList) => {
            importedModule = lazy(importedModule, importFn, moduleId);
            return Reflect.apply(importedModule, thisArgument, argumentsList);
          },
          construct: (target, argumentsList) => {
            importedModule = lazy(importedModule, importFn, moduleId);
            return Reflect.construct(importedModule, argumentsList);
          }
        };
        return new Proxy(function() {
        }, handler2);
      };
    };
  }
});

// ../../node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "../../node_modules/resolve/lib/homedir.js"(exports, module) {
    "use strict";
    var os = __require("os");
    module.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// ../../node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "../../node_modules/resolve/lib/caller.js"(exports, module) {
    "use strict";
    module.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_2, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// ../../node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "../../node_modules/path-parse/index.js"(exports, module) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module.exports = win32.parse;
    else
      module.exports = posix.parse;
    module.exports.posix = posix.parse;
    module.exports.win32 = win32.parse;
  }
});

// ../../node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "../../node_modules/resolve/lib/node-modules-paths.js"(exports, module) {
    "use strict";
    var path9 = __require("path");
    var parse2 = path9.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse2(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse2(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path9.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module.exports = function nodeModulesPaths(start, opts, request2) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request2,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// ../../node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "../../node_modules/resolve/lib/normalize-options.js"(exports, module) {
    "use strict";
    module.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind2 = require_function_bind();
    module.exports = bind2.call(call, $hasOwn);
  }
});

// ../../node_modules/is-core-module/core.json
var require_core = __commonJS({
  "../../node_modules/is-core-module/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      "node:sea": [">= 20.12 && < 21", ">= 21.7"],
      smalloc: ">= 0.11.5 && < 3",
      "node:sqlite": ">= 23.4",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "test/mock_loader": ">= 22.3 && < 22.7",
      "node:test/mock_loader": ">= 22.3 && < 22.7",
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// ../../node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "../../node_modules/is-core-module/index.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module.exports = function isCore(x, nodeVersion) {
      return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// ../../node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "../../node_modules/resolve/lib/async.js"(exports, module) {
    "use strict";
    var fs3 = __require("fs");
    var getHomedir = require_homedir();
    var path9 = __require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs3.realpath && typeof fs3.realpath.native === "function" ? fs3.realpath.native : fs3.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path9.join(homedir, ".node_modules"),
        path9.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs3.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs3.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile2, pkgfile, cb) {
      readFile2(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path9.join(dirs[i], x);
      }
      return dirs;
    };
    module.exports = function resolve4(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile2 = opts.readFile || fs3.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path9.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path9.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2)
            cb(err2);
          else
            init(realStart);
        }
      );
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path9.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n, pkg) {
            if (err2)
              cb(err2);
            else if (n) {
              return maybeRealpath(realpath, n, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path9.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path9.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load(
                  [""].concat(extensions.slice()),
                  path9.resolve(dir, r),
                  pkg
                );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path9.dirname(dir), cb2);
          var pkgfile = path9.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path9.dirname(dir), cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path9.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path9.join(x2, "index"), fpkg, cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path9.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path9.join(x2, "index"), pkg2, cb2);
                  var dir = path9.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n)
                      return cb2(null, n, pkg3);
                    loadAsFile(path9.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path9.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path9.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2)
            return cb2(err2);
          if (n)
            return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// ../../node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "../../node_modules/resolve/lib/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      "node:sea": [">= 20.12 && < 21", ">= 21.7"],
      smalloc: ">= 0.11.5 && < 3",
      "node:sqlite": ">= 23.4",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "test/mock_loader": ">= 22.3 && < 22.7",
      "node:test/mock_loader": ">= 22.3 && < 22.7",
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// ../../node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "../../node_modules/resolve/lib/core.js"(exports, module) {
    "use strict";
    var isCoreModule = require_is_core_module();
    var data = require_core2();
    var core = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = isCoreModule(mod);
      }
    }
    var mod;
    module.exports = core;
  }
});

// ../../node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "../../node_modules/resolve/lib/is-core.js"(exports, module) {
    "use strict";
    var isCoreModule = require_is_core_module();
    module.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// ../../node_modules/resolve/lib/sync.js
var require_sync2 = __commonJS({
  "../../node_modules/resolve/lib/sync.js"(exports, module) {
    "use strict";
    var isCore = require_is_core_module();
    var fs3 = __require("fs");
    var path9 = __require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs3.realpathSync && typeof fs3.realpathSync.native === "function" ? fs3.realpathSync.native : fs3.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path9.join(homedir, ".node_modules"),
        path9.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs3.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs3.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync2, pkgfile) {
      var body = readFileSync2(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path9.join(dirs[i], x);
      }
      return dirs;
    };
    module.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync2 = opts.readFileSync || fs3.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path9.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path9.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path9.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n)
          return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path9.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path9.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path9.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path9.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path9.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync2, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir
          );
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path9.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync2, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x2
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path9.resolve(x2, pkg.main));
              if (m2)
                return m2;
              var n2 = loadAsDirectorySync(path9.resolve(x2, pkg.main));
              if (n2)
                return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path9.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path9.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2)
              return n2;
          }
        }
      }
    };
  }
});

// ../../node_modules/resolve/index.js
var require_resolve = __commonJS({
  "../../node_modules/resolve/index.js"(exports, module) {
    "use strict";
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync2();
    module.exports = async;
  }
});

// ../../node_modules/jju/lib/unicode.js
var require_unicode = __commonJS({
  "../../node_modules/jju/lib/unicode.js"(exports, module) {
    "use strict";
    var Uni = module.exports;
    module.exports.isWhiteSpace = function isWhiteSpace(x) {
      return x === " " || x === "\xA0" || x === "\uFEFF" || x >= "	" && x <= "\r" || x === "\u1680" || x >= "\u2000" && x <= "\u200A" || x === "\u2028" || x === "\u2029" || x === "\u202F" || x === "\u205F" || x === "\u3000";
    };
    module.exports.isWhiteSpaceJSON = function isWhiteSpaceJSON(x) {
      return x === " " || x === "	" || x === "\n" || x === "\r";
    };
    module.exports.isLineTerminator = function isLineTerminator(x) {
      return x === "\n" || x === "\r" || x === "\u2028" || x === "\u2029";
    };
    module.exports.isLineTerminatorJSON = function isLineTerminatorJSON(x) {
      return x === "\n" || x === "\r";
    };
    module.exports.isIdentifierStart = function isIdentifierStart(x) {
      return x === "$" || x === "_" || x >= "A" && x <= "Z" || x >= "a" && x <= "z" || x >= "\x80" && Uni.NonAsciiIdentifierStart.test(x);
    };
    module.exports.isIdentifierPart = function isIdentifierPart(x) {
      return x === "$" || x === "_" || x >= "A" && x <= "Z" || x >= "a" && x <= "z" || x >= "0" && x <= "9" || x >= "\x80" && Uni.NonAsciiIdentifierPart.test(x);
    };
    module.exports.NonAsciiIdentifierStart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
    module.exports.NonAsciiIdentifierPart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
  }
});

// ../../node_modules/jju/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/jju/lib/parse.js"(exports, module) {
    "use strict";
    var Uni = require_unicode();
    function isHexDigit(x) {
      return x >= "0" && x <= "9" || x >= "A" && x <= "F" || x >= "a" && x <= "f";
    }
    function isOctDigit(x) {
      return x >= "0" && x <= "7";
    }
    function isDecDigit(x) {
      return x >= "0" && x <= "9";
    }
    var unescapeMap = {
      "'": "'",
      '"': '"',
      "\\": "\\",
      "b": "\b",
      "f": "\f",
      "n": "\n",
      "r": "\r",
      "t": "	",
      "v": "\v",
      "/": "/"
    };
    function formatError(input, msg, position, lineno, column, json5) {
      var result = msg + " at " + (lineno + 1) + ":" + (column + 1), tmppos = position - column - 1, srcline = "", underline = "";
      var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;
      if (tmppos < position - 70) {
        tmppos = position - 70;
      }
      while (1) {
        var chr = input[++tmppos];
        if (isLineTerminator(chr) || tmppos === input.length) {
          if (position >= tmppos) {
            underline += "^";
          }
          break;
        }
        srcline += chr;
        if (position === tmppos) {
          underline += "^";
        } else if (position > tmppos) {
          underline += input[tmppos] === "	" ? "	" : " ";
        }
        if (srcline.length > 78)
          break;
      }
      return result + "\n" + srcline + "\n" + underline;
    }
    function parse2(input, options) {
      var json5 = false;
      var cjson = false;
      if (options.legacy || options.mode === "json") {
      } else if (options.mode === "cjson") {
        cjson = true;
      } else if (options.mode === "json5") {
        json5 = true;
      } else {
        json5 = true;
      }
      var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;
      var isWhiteSpace = json5 ? Uni.isWhiteSpace : Uni.isWhiteSpaceJSON;
      var length = input.length, lineno = 0, linestart = 0, position = 0, stack = [];
      var tokenStart = function() {
      };
      var tokenEnd = function(v) {
        return v;
      };
      if (options._tokenize) {
        ;
        (function() {
          var start = null;
          tokenStart = function() {
            if (start !== null)
              throw Error("internal error, token overlap");
            start = position;
          };
          tokenEnd = function(v, type) {
            if (start != position) {
              var hash = {
                raw: input.substr(start, position - start),
                type,
                stack: stack.slice(0)
              };
              if (v !== void 0)
                hash.value = v;
              options._tokenize.call(null, hash);
            }
            start = null;
            return v;
          };
        })();
      }
      function fail(msg) {
        var column = position - linestart;
        if (!msg) {
          if (position < length) {
            var token = "'" + JSON.stringify(input[position]).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            if (!msg)
              msg = "Unexpected token " + token;
          } else {
            if (!msg)
              msg = "Unexpected end of input";
          }
        }
        var error = SyntaxError(formatError(input, msg, position, lineno, column, json5));
        error.row = lineno + 1;
        error.column = column + 1;
        throw error;
      }
      function newline(chr) {
        if (chr === "\r" && input[position] === "\n")
          position++;
        linestart = position;
        lineno++;
      }
      function parseGeneric() {
        var result;
        while (position < length) {
          tokenStart();
          var chr = input[position++];
          if (chr === '"' || chr === "'" && json5) {
            return tokenEnd(parseString(chr), "literal");
          } else if (chr === "{") {
            tokenEnd(void 0, "separator");
            return parseObject();
          } else if (chr === "[") {
            tokenEnd(void 0, "separator");
            return parseArray();
          } else if (chr === "-" || chr === "." || isDecDigit(chr) || json5 && (chr === "+" || chr === "I" || chr === "N")) {
            return tokenEnd(parseNumber(), "literal");
          } else if (chr === "n") {
            parseKeyword("null");
            return tokenEnd(null, "literal");
          } else if (chr === "t") {
            parseKeyword("true");
            return tokenEnd(true, "literal");
          } else if (chr === "f") {
            parseKeyword("false");
            return tokenEnd(false, "literal");
          } else {
            position--;
            return tokenEnd(void 0);
          }
        }
      }
      function parseKey() {
        var result;
        while (position < length) {
          tokenStart();
          var chr = input[position++];
          if (chr === '"' || chr === "'" && json5) {
            return tokenEnd(parseString(chr), "key");
          } else if (chr === "{") {
            tokenEnd(void 0, "separator");
            return parseObject();
          } else if (chr === "[") {
            tokenEnd(void 0, "separator");
            return parseArray();
          } else if (chr === "." || isDecDigit(chr)) {
            return tokenEnd(parseNumber(true), "key");
          } else if (json5 && Uni.isIdentifierStart(chr) || chr === "\\" && input[position] === "u") {
            var rollback = position - 1;
            var result = parseIdentifier();
            if (result === void 0) {
              position = rollback;
              return tokenEnd(void 0);
            } else {
              return tokenEnd(result, "key");
            }
          } else {
            position--;
            return tokenEnd(void 0);
          }
        }
      }
      function skipWhiteSpace() {
        tokenStart();
        while (position < length) {
          var chr = input[position++];
          if (isLineTerminator(chr)) {
            position--;
            tokenEnd(void 0, "whitespace");
            tokenStart();
            position++;
            newline(chr);
            tokenEnd(void 0, "newline");
            tokenStart();
          } else if (isWhiteSpace(chr)) {
          } else if (chr === "/" && (json5 || cjson) && (input[position] === "/" || input[position] === "*")) {
            position--;
            tokenEnd(void 0, "whitespace");
            tokenStart();
            position++;
            skipComment(input[position++] === "*");
            tokenEnd(void 0, "comment");
            tokenStart();
          } else {
            position--;
            break;
          }
        }
        return tokenEnd(void 0, "whitespace");
      }
      function skipComment(multi) {
        while (position < length) {
          var chr = input[position++];
          if (isLineTerminator(chr)) {
            if (!multi) {
              position--;
              return;
            }
            newline(chr);
          } else if (chr === "*" && multi) {
            if (input[position] === "/") {
              position++;
              return;
            }
          } else {
          }
        }
        if (multi) {
          fail("Unclosed multiline comment");
        }
      }
      function parseKeyword(keyword) {
        var _pos = position;
        var len = keyword.length;
        for (var i = 1; i < len; i++) {
          if (position >= length || keyword[i] != input[position]) {
            position = _pos - 1;
            fail();
          }
          position++;
        }
      }
      function parseObject() {
        var result = options.null_prototype ? /* @__PURE__ */ Object.create(null) : {}, empty_object = {}, is_non_empty = false;
        while (position < length) {
          skipWhiteSpace();
          var item1 = parseKey();
          skipWhiteSpace();
          tokenStart();
          var chr = input[position++];
          tokenEnd(void 0, "separator");
          if (chr === "}" && item1 === void 0) {
            if (!json5 && is_non_empty) {
              position--;
              fail("Trailing comma in object");
            }
            return result;
          } else if (chr === ":" && item1 !== void 0) {
            skipWhiteSpace();
            stack.push(item1);
            var item2 = parseGeneric();
            stack.pop();
            if (item2 === void 0)
              fail("No value found for key " + item1);
            if (typeof item1 !== "string") {
              if (!json5 || typeof item1 !== "number") {
                fail("Wrong key type: " + item1);
              }
            }
            if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== "replace") {
              if (options.reserved_keys === "throw") {
                fail("Reserved key: " + item1);
              } else {
              }
            } else {
              if (typeof options.reviver === "function") {
                item2 = options.reviver.call(null, item1, item2);
              }
              if (item2 !== void 0) {
                is_non_empty = true;
                Object.defineProperty(result, item1, {
                  value: item2,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              }
            }
            skipWhiteSpace();
            tokenStart();
            var chr = input[position++];
            tokenEnd(void 0, "separator");
            if (chr === ",") {
              continue;
            } else if (chr === "}") {
              return result;
            } else {
              fail();
            }
          } else {
            position--;
            fail();
          }
        }
        fail();
      }
      function parseArray() {
        var result = [];
        while (position < length) {
          skipWhiteSpace();
          stack.push(result.length);
          var item = parseGeneric();
          stack.pop();
          skipWhiteSpace();
          tokenStart();
          var chr = input[position++];
          tokenEnd(void 0, "separator");
          if (item !== void 0) {
            if (typeof options.reviver === "function") {
              item = options.reviver.call(null, String(result.length), item);
            }
            if (item === void 0) {
              result.length++;
              item = true;
            } else {
              result.push(item);
            }
          }
          if (chr === ",") {
            if (item === void 0) {
              fail("Elisions are not supported");
            }
          } else if (chr === "]") {
            if (!json5 && item === void 0 && result.length) {
              position--;
              fail("Trailing comma in array");
            }
            return result;
          } else {
            position--;
            fail();
          }
        }
      }
      function parseNumber() {
        position--;
        var start = position, chr = input[position++], t;
        var to_num = function(is_octal2) {
          var str = input.substr(start, position - start);
          if (is_octal2) {
            var result = parseInt(str.replace(/^0o?/, ""), 8);
          } else {
            var result = Number(str);
          }
          if (Number.isNaN(result)) {
            position--;
            fail('Bad numeric literal - "' + input.substr(start, position - start + 1) + '"');
          } else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) {
            position--;
            fail('Non-json numeric literal - "' + input.substr(start, position - start + 1) + '"');
          } else {
            return result;
          }
        };
        if (chr === "-" || chr === "+" && json5)
          chr = input[position++];
        if (chr === "N" && json5) {
          parseKeyword("NaN");
          return NaN;
        }
        if (chr === "I" && json5) {
          parseKeyword("Infinity");
          return to_num();
        }
        if (chr >= "1" && chr <= "9") {
          while (position < length && isDecDigit(input[position]))
            position++;
          chr = input[position++];
        }
        if (chr === "0") {
          chr = input[position++];
          var is_octal = chr === "o" || chr === "O" || isOctDigit(chr);
          var is_hex = chr === "x" || chr === "X";
          if (json5 && (is_octal || is_hex)) {
            while (position < length && (is_hex ? isHexDigit : isOctDigit)(input[position]))
              position++;
            var sign = 1;
            if (input[start] === "-") {
              sign = -1;
              start++;
            } else if (input[start] === "+") {
              start++;
            }
            return sign * to_num(is_octal);
          }
        }
        if (chr === ".") {
          while (position < length && isDecDigit(input[position]))
            position++;
          chr = input[position++];
        }
        if (chr === "e" || chr === "E") {
          chr = input[position++];
          if (chr === "-" || chr === "+")
            position++;
          while (position < length && isDecDigit(input[position]))
            position++;
          chr = input[position++];
        }
        position--;
        return to_num();
      }
      function parseIdentifier() {
        position--;
        var result = "";
        while (position < length) {
          var chr = input[position++];
          if (chr === "\\" && input[position] === "u" && isHexDigit(input[position + 1]) && isHexDigit(input[position + 2]) && isHexDigit(input[position + 3]) && isHexDigit(input[position + 4])) {
            chr = String.fromCharCode(parseInt(input.substr(position + 1, 4), 16));
            position += 5;
          }
          if (result.length) {
            if (Uni.isIdentifierPart(chr)) {
              result += chr;
            } else {
              position--;
              return result;
            }
          } else {
            if (Uni.isIdentifierStart(chr)) {
              result += chr;
            } else {
              return void 0;
            }
          }
        }
        fail();
      }
      function parseString(endChar) {
        var result = "";
        while (position < length) {
          var chr = input[position++];
          if (chr === endChar) {
            return result;
          } else if (chr === "\\") {
            if (position >= length)
              fail();
            chr = input[position++];
            if (unescapeMap[chr] && (json5 || chr != "v" && chr != "'")) {
              result += unescapeMap[chr];
            } else if (json5 && isLineTerminator(chr)) {
              newline(chr);
            } else if (chr === "u" || chr === "x" && json5) {
              var off = chr === "u" ? 4 : 2;
              for (var i = 0; i < off; i++) {
                if (position >= length)
                  fail();
                if (!isHexDigit(input[position]))
                  fail("Bad escape sequence");
                position++;
              }
              result += String.fromCharCode(parseInt(input.substr(position - off, off), 16));
            } else if (json5 && isOctDigit(chr)) {
              if (chr < "4" && isOctDigit(input[position]) && isOctDigit(input[position + 1])) {
                var digits = 3;
              } else if (isOctDigit(input[position])) {
                var digits = 2;
              } else {
                var digits = 1;
              }
              position += digits - 1;
              result += String.fromCharCode(parseInt(input.substr(position - digits, digits), 8));
            } else if (json5) {
              result += chr;
            } else {
              position--;
              fail();
            }
          } else if (isLineTerminator(chr)) {
            fail();
          } else {
            if (!json5 && chr.charCodeAt(0) < 32) {
              position--;
              fail("Unexpected control character");
            }
            result += chr;
          }
        }
        fail();
      }
      skipWhiteSpace();
      var return_value = parseGeneric();
      if (return_value !== void 0 || position < length) {
        skipWhiteSpace();
        if (position >= length) {
          if (typeof options.reviver === "function") {
            return_value = options.reviver.call(null, "", return_value);
          }
          return return_value;
        } else {
          fail();
        }
      } else {
        if (position) {
          fail("No data, only a whitespace");
        } else {
          fail("No data, empty input");
        }
      }
    }
    module.exports.parse = function parseJSON(input, options) {
      if (typeof options === "function") {
        options = {
          reviver: options
        };
      }
      if (input === void 0) {
        return void 0;
      }
      if (typeof input !== "string")
        input = String(input);
      if (options == null)
        options = {};
      if (options.reserved_keys == null)
        options.reserved_keys = "ignore";
      if (options.reserved_keys === "throw" || options.reserved_keys === "ignore") {
        if (options.null_prototype == null) {
          options.null_prototype = true;
        }
      }
      try {
        return parse2(input, options);
      } catch (err) {
        if (err instanceof SyntaxError && err.row != null && err.column != null) {
          var old_err = err;
          err = SyntaxError(old_err.message);
          err.column = old_err.column;
          err.row = old_err.row;
        }
        throw err;
      }
    };
    module.exports.tokenize = function tokenizeJSON(input, options) {
      if (options == null)
        options = {};
      options._tokenize = function(smth) {
        if (options._addstack)
          smth.stack.unshift.apply(smth.stack, options._addstack);
        tokens.push(smth);
      };
      var tokens = [];
      tokens.data = module.exports.parse(input, options);
      return tokens;
    };
  }
});

// ../../node_modules/jju/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/jju/lib/stringify.js"(exports, module) {
    "use strict";
    var Uni = require_unicode();
    if (!function f() {
    }.name) {
      Object.defineProperty(function() {
      }.constructor.prototype, "name", {
        get: function() {
          var name = this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
          Object.defineProperty(this, "name", { value: name });
          return name;
        }
      });
    }
    var special_chars = {
      0: "\\0",
      // this is not an octal literal
      8: "\\b",
      9: "\\t",
      10: "\\n",
      11: "\\v",
      12: "\\f",
      13: "\\r",
      92: "\\\\"
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var escapable = /[\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;
    function _stringify(object, options, recursiveLvl, currentKey) {
      var json5 = options.mode === "json5" || !options.mode;
      function indent(str2, add) {
        var prefix = options._prefix ? options._prefix : "";
        if (!options.indent)
          return prefix + str2;
        var result = "";
        var count = recursiveLvl + (add || 0);
        for (var i = 0; i < count; i++)
          result += options.indent;
        return prefix + result + str2 + (add ? "\n" : "");
      }
      function _stringify_key(key) {
        if (options.quote_keys)
          return _stringify_str(key);
        if (String(Number(key)) == key && key[0] != "-")
          return key;
        if (key == "")
          return _stringify_str(key);
        var result = "";
        for (var i = 0; i < key.length; i++) {
          if (i > 0) {
            if (!Uni.isIdentifierPart(key[i]))
              return _stringify_str(key);
          } else {
            if (!Uni.isIdentifierStart(key[i]))
              return _stringify_str(key);
          }
          var chr = key.charCodeAt(i);
          if (options.ascii) {
            if (chr < 128) {
              result += key[i];
            } else {
              result += "\\u" + ("0000" + chr.toString(16)).slice(-4);
            }
          } else {
            if (escapable.exec(key[i])) {
              result += "\\u" + ("0000" + chr.toString(16)).slice(-4);
            } else {
              result += key[i];
            }
          }
        }
        return result;
      }
      function _stringify_str(key) {
        var quote = options.quote;
        var quoteChr = quote.charCodeAt(0);
        var result = "";
        for (var i = 0; i < key.length; i++) {
          var chr = key.charCodeAt(i);
          if (chr < 16) {
            if (chr === 0 && json5) {
              result += "\\0";
            } else if (chr >= 8 && chr <= 13 && (json5 || chr !== 11)) {
              result += special_chars[chr];
            } else if (json5) {
              result += "\\x0" + chr.toString(16);
            } else {
              result += "\\u000" + chr.toString(16);
            }
          } else if (chr < 32) {
            if (json5) {
              result += "\\x" + chr.toString(16);
            } else {
              result += "\\u00" + chr.toString(16);
            }
          } else if (chr >= 32 && chr < 128) {
            if (chr === 47 && i && key[i - 1] === "<") {
              result += "\\" + key[i];
            } else if (chr === 92) {
              result += "\\\\";
            } else if (chr === quoteChr) {
              result += "\\" + quote;
            } else {
              result += key[i];
            }
          } else if (options.ascii || Uni.isLineTerminator(key[i]) || escapable.exec(key[i])) {
            if (chr < 256) {
              if (json5) {
                result += "\\x" + chr.toString(16);
              } else {
                result += "\\u00" + chr.toString(16);
              }
            } else if (chr < 4096) {
              result += "\\u0" + chr.toString(16);
            } else if (chr < 65536) {
              result += "\\u" + chr.toString(16);
            } else {
              throw Error("weird codepoint");
            }
          } else {
            result += key[i];
          }
        }
        return quote + result + quote;
      }
      function _stringify_object() {
        if (object === null)
          return "null";
        var result = [], len = 0, braces;
        if (Array.isArray(object)) {
          braces = "[]";
          for (var i = 0; i < object.length; i++) {
            var s = _stringify(object[i], options, recursiveLvl + 1, String(i));
            if (s === void 0)
              s = "null";
            len += s.length + 2;
            result.push(s + ",");
          }
        } else {
          braces = "{}";
          var fn = function(key) {
            var t = _stringify(object[key], options, recursiveLvl + 1, key);
            if (t !== void 0) {
              t = _stringify_key(key) + ":" + (options.indent ? " " : "") + t + ",";
              len += t.length + 1;
              result.push(t);
            }
          };
          if (Array.isArray(options.replacer)) {
            for (var i = 0; i < options.replacer.length; i++)
              if (hasOwnProperty.call(object, options.replacer[i]))
                fn(options.replacer[i]);
          } else {
            var keys = Object.keys(object);
            if (options.sort_keys)
              keys = keys.sort(typeof options.sort_keys === "function" ? options.sort_keys : void 0);
            keys.forEach(fn);
          }
        }
        len -= 2;
        if (options.indent && (len > options._splitMax - recursiveLvl * options.indent.length || len > options._splitMin)) {
          if (options.no_trailing_comma && result.length) {
            result[result.length - 1] = result[result.length - 1].substring(0, result[result.length - 1].length - 1);
          }
          var innerStuff = result.map(function(x) {
            return indent(x, 1);
          }).join("");
          return braces[0] + (options.indent ? "\n" : "") + innerStuff + indent(braces[1]);
        } else {
          if (result.length) {
            result[result.length - 1] = result[result.length - 1].substring(0, result[result.length - 1].length - 1);
          }
          var innerStuff = result.join(options.indent ? " " : "");
          return braces[0] + innerStuff + braces[1];
        }
      }
      function _stringify_nonobject(object2) {
        if (typeof options.replacer === "function") {
          object2 = options.replacer.call(null, currentKey, object2);
        }
        switch (typeof object2) {
          case "string":
            return _stringify_str(object2);
          case "number":
            if (object2 === 0 && 1 / object2 < 0) {
              return "-0";
            }
            if (!json5 && !Number.isFinite(object2)) {
              return "null";
            }
            return object2.toString();
          case "boolean":
            return object2.toString();
          case "undefined":
            return void 0;
          case "function":
          default:
            return JSON.stringify(object2);
        }
      }
      if (options._stringify_key) {
        return _stringify_key(object);
      }
      if (typeof object === "object") {
        if (object === null)
          return "null";
        var str;
        if (typeof (str = object.toJSON5) === "function" && options.mode !== "json") {
          object = str.call(object, currentKey);
        } else if (typeof (str = object.toJSON) === "function") {
          object = str.call(object, currentKey);
        }
        if (object === null)
          return "null";
        if (typeof object !== "object")
          return _stringify_nonobject(object);
        if (object.constructor === Number || object.constructor === Boolean || object.constructor === String) {
          object = object.valueOf();
          return _stringify_nonobject(object);
        } else if (object.constructor === Date) {
          return _stringify_nonobject(object.toISOString());
        } else {
          if (typeof options.replacer === "function") {
            object = options.replacer.call(null, currentKey, object);
            if (typeof object !== "object")
              return _stringify_nonobject(object);
          }
          return _stringify_object(object);
        }
      } else {
        return _stringify_nonobject(object);
      }
    }
    module.exports.stringify = function stringifyJSON(object, options, _space) {
      if (typeof options === "function" || Array.isArray(options)) {
        options = {
          replacer: options
        };
      } else if (typeof options === "object" && options !== null) {
      } else {
        options = {};
      }
      if (_space != null)
        options.indent = _space;
      if (options.indent == null)
        options.indent = "	";
      if (options.quote == null)
        options.quote = "'";
      if (options.ascii == null)
        options.ascii = false;
      if (options.mode == null)
        options.mode = "json5";
      if (options.mode === "json" || options.mode === "cjson") {
        options.quote = '"';
        options.no_trailing_comma = true;
        options.quote_keys = true;
      }
      if (typeof options.indent === "object") {
        if (options.indent.constructor === Number || options.indent.constructor === Boolean || options.indent.constructor === String)
          options.indent = options.indent.valueOf();
      }
      if (typeof options.indent === "number") {
        if (options.indent >= 0) {
          options.indent = Array(Math.min(~~options.indent, 10) + 1).join(" ");
        } else {
          options.indent = false;
        }
      } else if (typeof options.indent === "string") {
        options.indent = options.indent.substr(0, 10);
      }
      if (options._splitMin == null)
        options._splitMin = 50;
      if (options._splitMax == null)
        options._splitMax = 70;
      return _stringify(object, options, 0, "");
    };
  }
});

// ../../node_modules/jju/lib/analyze.js
var require_analyze = __commonJS({
  "../../node_modules/jju/lib/analyze.js"(exports, module) {
    "use strict";
    var tokenize = require_parse().tokenize;
    module.exports.analyze = function analyzeJSON(input, options) {
      if (options == null)
        options = {};
      if (!Array.isArray(input)) {
        input = tokenize(input, options);
      }
      var result = {
        has_whitespace: false,
        has_comments: false,
        has_newlines: false,
        has_trailing_comma: false,
        indent: "",
        newline: "\n",
        quote: '"',
        quote_keys: true
      };
      var stats = {
        indent: {},
        newline: {},
        quote: {}
      };
      for (var i = 0; i < input.length; i++) {
        if (input[i].type === "newline") {
          if (input[i + 1] && input[i + 1].type === "whitespace") {
            if (input[i + 1].raw[0] === "	") {
              stats.indent["	"] = (stats.indent["	"] || 0) + 1;
            }
            if (input[i + 1].raw.match(/^\x20+$/)) {
              var ws_len = input[i + 1].raw.length;
              var indent_len = input[i + 1].stack.length + 1;
              if (ws_len % indent_len === 0) {
                var t = Array(ws_len / indent_len + 1).join(" ");
                stats.indent[t] = (stats.indent[t] || 0) + 1;
              }
            }
          }
          stats.newline[input[i].raw] = (stats.newline[input[i].raw] || 0) + 1;
        }
        if (input[i].type === "newline") {
          result.has_newlines = true;
        }
        if (input[i].type === "whitespace") {
          result.has_whitespace = true;
        }
        if (input[i].type === "comment") {
          result.has_comments = true;
        }
        if (input[i].type === "key") {
          if (input[i].raw[0] !== '"' && input[i].raw[0] !== "'")
            result.quote_keys = false;
        }
        if (input[i].type === "key" || input[i].type === "literal") {
          if (input[i].raw[0] === '"' || input[i].raw[0] === "'") {
            stats.quote[input[i].raw[0]] = (stats.quote[input[i].raw[0]] || 0) + 1;
          }
        }
        if (input[i].type === "separator" && input[i].raw === ",") {
          for (var j = i + 1; j < input.length; j++) {
            if (input[j].type === "literal" || input[j].type === "key")
              break;
            if (input[j].type === "separator")
              result.has_trailing_comma = true;
          }
        }
      }
      for (var k in stats) {
        if (Object.keys(stats[k]).length) {
          result[k] = Object.keys(stats[k]).reduce(function(a, b) {
            return stats[k][a] > stats[k][b] ? a : b;
          });
        }
      }
      return result;
    };
  }
});

// ../../node_modules/jju/lib/document.js
var require_document = __commonJS({
  "../../node_modules/jju/lib/document.js"(exports, module) {
    "use strict";
    var assert = __require("assert");
    var tokenize = require_parse().tokenize;
    var stringify = require_stringify().stringify;
    var analyze = require_analyze().analyze;
    function isObject(x) {
      return typeof x === "object" && x !== null;
    }
    function value_to_tokenlist(value, stack, options, is_key, indent) {
      options = Object.create(options);
      options._stringify_key = !!is_key;
      if (indent) {
        options._prefix = indent.prefix.map(function(x) {
          return x.raw;
        }).join("");
      }
      if (options._splitMin == null)
        options._splitMin = 0;
      if (options._splitMax == null)
        options._splitMax = 0;
      var stringified = stringify(value, options);
      if (is_key) {
        return [{ raw: stringified, type: "key", stack, value }];
      }
      options._addstack = stack;
      var result = tokenize(stringified, {
        _addstack: stack
      });
      result.data = null;
      return result;
    }
    function arg_to_path(path9) {
      if (typeof path9 === "number")
        path9 = String(path9);
      if (path9 === "")
        path9 = [];
      if (typeof path9 === "string")
        path9 = path9.split(".");
      if (!Array.isArray(path9))
        throw Error("Invalid path type, string or array expected");
      return path9;
    }
    function find_element_in_tokenlist(element, lvl, tokens, begin, end) {
      while (tokens[begin].stack[lvl] != element) {
        if (begin++ >= end)
          return false;
      }
      while (tokens[end].stack[lvl] != element) {
        if (end-- < begin)
          return false;
      }
      return [begin, end];
    }
    function is_whitespace(token_type) {
      return token_type === "whitespace" || token_type === "newline" || token_type === "comment";
    }
    function find_first_non_ws_token(tokens, begin, end) {
      while (is_whitespace(tokens[begin].type)) {
        if (begin++ >= end)
          return false;
      }
      return begin;
    }
    function find_last_non_ws_token(tokens, begin, end) {
      while (is_whitespace(tokens[end].type)) {
        if (end-- < begin)
          return false;
      }
      return end;
    }
    function detect_indent_style(tokens, is_array, begin, end, level) {
      var result = {
        sep1: [],
        sep2: [],
        suffix: [],
        prefix: [],
        newline: []
      };
      if (tokens[end].type === "separator" && tokens[end].stack.length !== level + 1 && tokens[end].raw !== ",") {
        return result;
      }
      if (tokens[end].type === "separator")
        end = find_last_non_ws_token(tokens, begin, end - 1);
      if (end === false)
        return result;
      while (tokens[end].stack.length > level)
        end--;
      if (!is_array) {
        while (is_whitespace(tokens[end].type)) {
          if (end < begin)
            return result;
          if (tokens[end].type === "whitespace") {
            result.sep2.unshift(tokens[end]);
          } else {
            return result;
          }
          end--;
        }
        assert.equal(tokens[end].type, "separator");
        assert.equal(tokens[end].raw, ":");
        while (is_whitespace(tokens[--end].type)) {
          if (end < begin)
            return result;
          if (tokens[end].type === "whitespace") {
            result.sep1.unshift(tokens[end]);
          } else {
            return result;
          }
        }
        assert.equal(tokens[end].type, "key");
        end--;
      }
      while (is_whitespace(tokens[end].type)) {
        if (end < begin)
          return result;
        if (tokens[end].type === "whitespace") {
          result.prefix.unshift(tokens[end]);
        } else if (tokens[end].type === "newline") {
          result.newline.unshift(tokens[end]);
          return result;
        } else {
          return result;
        }
        end--;
      }
      return result;
    }
    function Document(text, options) {
      var self2 = Object.create(Document.prototype);
      if (options == null)
        options = {};
      var tokens = self2._tokens = tokenize(text, options);
      self2._data = tokens.data;
      tokens.data = null;
      self2._options = options;
      var stats = analyze(text, options);
      if (options.indent == null) {
        options.indent = stats.indent;
      }
      if (options.quote == null) {
        options.quote = stats.quote;
      }
      if (options.quote_keys == null) {
        options.quote_keys = stats.quote_keys;
      }
      if (options.no_trailing_comma == null) {
        options.no_trailing_comma = !stats.has_trailing_comma;
      }
      return self2;
    }
    function check_if_can_be_placed(key, object, is_unset) {
      function error(add) {
        return Error("You can't " + (is_unset ? "unset" : "set") + " key '" + key + "'" + add);
      }
      if (!isObject(object)) {
        throw error(" of an non-object");
      }
      if (Array.isArray(object)) {
        if (String(key).match(/^\d+$/)) {
          key = Number(String(key));
          if (object.length < key || is_unset && object.length === key) {
            throw error(", out of bounds");
          } else if (is_unset && object.length !== key + 1) {
            throw error(" in the middle of an array");
          } else {
            return true;
          }
        } else {
          throw error(" of an array");
        }
      } else {
        return true;
      }
    }
    Document.prototype.set = function(path9, value) {
      path9 = arg_to_path(path9);
      if (path9.length === 0) {
        if (value === void 0)
          throw Error("can't remove root document");
        this._data = value;
        var new_key = false;
      } else {
        var data = this._data;
        for (var i = 0; i < path9.length - 1; i++) {
          check_if_can_be_placed(path9[i], data, false);
          data = data[path9[i]];
        }
        if (i === path9.length - 1) {
          check_if_can_be_placed(path9[i], data, value === void 0);
        }
        var new_key = !(path9[i] in data);
        if (value === void 0) {
          if (Array.isArray(data)) {
            data.pop();
          } else {
            delete data[path9[i]];
          }
        } else {
          data[path9[i]] = value;
        }
      }
      if (!this._tokens.length)
        this._tokens = [{ raw: "", type: "literal", stack: [], value: void 0 }];
      var position = [
        find_first_non_ws_token(this._tokens, 0, this._tokens.length - 1),
        find_last_non_ws_token(this._tokens, 0, this._tokens.length - 1)
      ];
      for (var i = 0; i < path9.length - 1; i++) {
        position = find_element_in_tokenlist(path9[i], i, this._tokens, position[0], position[1]);
        if (position == false)
          throw Error("internal error, please report this");
      }
      if (path9.length === 0) {
        var newtokens = value_to_tokenlist(value, path9, this._options);
      } else if (!new_key) {
        var pos_old = position;
        position = find_element_in_tokenlist(path9[i], i, this._tokens, position[0], position[1]);
        if (value === void 0 && position !== false) {
          var newtokens = [];
          if (!Array.isArray(data)) {
            var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1);
            assert.equal(this._tokens[pos2].type, "separator");
            assert.equal(this._tokens[pos2].raw, ":");
            position[0] = pos2;
            var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1);
            assert.equal(this._tokens[pos2].type, "key");
            assert.equal(this._tokens[pos2].value, path9[path9.length - 1]);
            position[0] = pos2;
          }
          var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1);
          assert.equal(this._tokens[pos2].type, "separator");
          if (this._tokens[pos2].raw === ",") {
            position[0] = pos2;
          } else {
            pos2 = find_first_non_ws_token(this._tokens, position[1] + 1, pos_old[1]);
            assert.equal(this._tokens[pos2].type, "separator");
            if (this._tokens[pos2].raw === ",") {
              position[1] = pos2;
            }
          }
        } else {
          var indent = pos2 !== false ? detect_indent_style(this._tokens, Array.isArray(data), pos_old[0], position[1] - 1, i) : {};
          var newtokens = value_to_tokenlist(value, path9, this._options, false, indent);
        }
      } else {
        var path_1 = path9.slice(0, i);
        var pos2 = find_last_non_ws_token(this._tokens, position[0] + 1, position[1] - 1);
        assert(pos2 !== false);
        var indent = pos2 !== false ? detect_indent_style(this._tokens, Array.isArray(data), position[0] + 1, pos2, i) : {};
        var newtokens = value_to_tokenlist(value, path9, this._options, false, indent);
        var prefix = [];
        if (indent.newline && indent.newline.length)
          prefix = prefix.concat(indent.newline);
        if (indent.prefix && indent.prefix.length)
          prefix = prefix.concat(indent.prefix);
        if (!Array.isArray(data)) {
          prefix = prefix.concat(value_to_tokenlist(path9[path9.length - 1], path_1, this._options, true));
          if (indent.sep1 && indent.sep1.length)
            prefix = prefix.concat(indent.sep1);
          prefix.push({ raw: ":", type: "separator", stack: path_1 });
          if (indent.sep2 && indent.sep2.length)
            prefix = prefix.concat(indent.sep2);
        }
        newtokens.unshift.apply(newtokens, prefix);
        if (this._tokens[pos2].type === "separator" && this._tokens[pos2].stack.length === path9.length - 1) {
          if (this._tokens[pos2].raw === ",") {
            newtokens.push({ raw: ",", type: "separator", stack: path_1 });
          }
        } else {
          newtokens.unshift({ raw: ",", type: "separator", stack: path_1 });
        }
        if (indent.suffix && indent.suffix.length)
          newtokens.push.apply(newtokens, indent.suffix);
        assert.equal(this._tokens[position[1]].type, "separator");
        position[0] = pos2 + 1;
        position[1] = pos2;
      }
      newtokens.unshift(position[1] - position[0] + 1);
      newtokens.unshift(position[0]);
      this._tokens.splice.apply(this._tokens, newtokens);
      return this;
    };
    Document.prototype.unset = function(path9) {
      return this.set(path9, void 0);
    };
    Document.prototype.get = function(path9) {
      path9 = arg_to_path(path9);
      var data = this._data;
      for (var i = 0; i < path9.length; i++) {
        if (!isObject(data))
          return void 0;
        data = data[path9[i]];
      }
      return data;
    };
    Document.prototype.has = function(path9) {
      path9 = arg_to_path(path9);
      var data = this._data;
      for (var i = 0; i < path9.length; i++) {
        if (!isObject(data))
          return false;
        data = data[path9[i]];
      }
      return data !== void 0;
    };
    Document.prototype.update = function(value) {
      var self2 = this;
      change([], self2._data, value);
      return self2;
      function change(path9, old_data, new_data) {
        if (!isObject(new_data) || !isObject(old_data)) {
          if (new_data !== old_data)
            self2.set(path9, new_data);
        } else if (Array.isArray(new_data) != Array.isArray(old_data)) {
          self2.set(path9, new_data);
        } else if (Array.isArray(new_data)) {
          if (new_data.length > old_data.length) {
            for (var i = 0; i < new_data.length; i++) {
              path9.push(String(i));
              change(path9, old_data[i], new_data[i]);
              path9.pop();
            }
          } else {
            for (var i = old_data.length - 1; i >= 0; i--) {
              path9.push(String(i));
              change(path9, old_data[i], new_data[i]);
              path9.pop();
            }
          }
        } else {
          for (var i in new_data) {
            path9.push(String(i));
            change(path9, old_data[i], new_data[i]);
            path9.pop();
          }
          for (var i in old_data) {
            if (i in new_data)
              continue;
            path9.push(String(i));
            change(path9, old_data[i], new_data[i]);
            path9.pop();
          }
        }
      }
    };
    Document.prototype.toString = function() {
      return this._tokens.map(function(x) {
        return x.raw;
      }).join("");
    };
    module.exports.Document = Document;
    module.exports.update = function updateJSON(source, new_value, options) {
      return Document(source, options).update(new_value).toString();
    };
  }
});

// ../../node_modules/jju/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/jju/lib/utils.js"(exports, module) {
    "use strict";
    var FS = __require("fs");
    var jju = require_jju();
    module.exports.register = function() {
      var r = __require, e = "extensions";
      r[e][".json5"] = function(m, f) {
        m.exports = jju.parse(FS.readFileSync(f, "utf8"));
      };
    };
    module.exports.patch_JSON_parse = function() {
      var _parse = JSON.parse;
      JSON.parse = function(text, rev) {
        try {
          return _parse(text, rev);
        } catch (err) {
          require_jju().parse(text, {
            mode: "json",
            legacy: true,
            reviver: rev,
            reserved_keys: "replace",
            null_prototype: false
          });
          throw err;
        }
      };
    };
    module.exports.middleware = function() {
      return function(req, res, next) {
        throw Error("this function is removed, use express-json5 instead");
      };
    };
  }
});

// ../../node_modules/jju/index.js
var require_jju = __commonJS({
  "../../node_modules/jju/index.js"(exports, module) {
    "use strict";
    module.exports.__defineGetter__("parse", function() {
      return require_parse().parse;
    });
    module.exports.__defineGetter__("stringify", function() {
      return require_stringify().stringify;
    });
    module.exports.__defineGetter__("tokenize", function() {
      return require_parse().tokenize;
    });
    module.exports.__defineGetter__("update", function() {
      return require_document().update;
    });
    module.exports.__defineGetter__("analyze", function() {
      return require_analyze().analyze;
    });
    module.exports.__defineGetter__("utils", function() {
      return require_utils();
    });
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/JsonFile.js
var require_JsonFile = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/JsonFile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonFile = exports.JsonSyntax = void 0;
    var os = __importStar(__require("os"));
    var jju = __importStar(require_jju());
    var Text_1 = require_Text();
    var FileSystem_1 = require_FileSystem();
    var JsonSyntax;
    (function(JsonSyntax2) {
      JsonSyntax2["Strict"] = "strict";
      JsonSyntax2["JsonWithComments"] = "jsonWithComments";
      JsonSyntax2["Json5"] = "json5";
    })(JsonSyntax || (exports.JsonSyntax = JsonSyntax = {}));
    var DEFAULT_ENCODING = "utf8";
    var JsonFile = class _JsonFile {
      /**
       * Loads a JSON file.
       */
      static load(jsonFilename, options) {
        try {
          const contents = FileSystem_1.FileSystem.readFile(jsonFilename);
          const parseOptions = _JsonFile._buildJjuParseOptions(options);
          return jju.parse(contents, parseOptions);
        } catch (error) {
          if (FileSystem_1.FileSystem.isNotExistError(error)) {
            throw error;
          } else {
            throw new Error(`Error reading "${_JsonFile._formatPathForError(jsonFilename)}":` + os.EOL + `  ${error.message}`);
          }
        }
      }
      /**
       * An async version of {@link JsonFile.load}.
       */
      static async loadAsync(jsonFilename, options) {
        try {
          const contents = await FileSystem_1.FileSystem.readFileAsync(jsonFilename);
          const parseOptions = _JsonFile._buildJjuParseOptions(options);
          return jju.parse(contents, parseOptions);
        } catch (error) {
          if (FileSystem_1.FileSystem.isNotExistError(error)) {
            throw error;
          } else {
            throw new Error(`Error reading "${_JsonFile._formatPathForError(jsonFilename)}":` + os.EOL + `  ${error.message}`);
          }
        }
      }
      /**
       * Parses a JSON file's contents.
       */
      static parseString(jsonContents, options) {
        const parseOptions = _JsonFile._buildJjuParseOptions(options);
        return jju.parse(jsonContents, parseOptions);
      }
      /**
       * Loads a JSON file and validate its schema.
       */
      static loadAndValidate(jsonFilename, jsonSchema, options) {
        const jsonObject = _JsonFile.load(jsonFilename, options);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
      }
      /**
       * An async version of {@link JsonFile.loadAndValidate}.
       */
      static async loadAndValidateAsync(jsonFilename, jsonSchema, options) {
        const jsonObject = await _JsonFile.loadAsync(jsonFilename, options);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
      }
      /**
       * Loads a JSON file and validate its schema, reporting errors using a callback
       * @remarks
       * See JsonSchema.validateObjectWithCallback() for more info.
       */
      static loadAndValidateWithCallback(jsonFilename, jsonSchema, errorCallback, options) {
        const jsonObject = _JsonFile.load(jsonFilename, options);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
      }
      /**
       * An async version of {@link JsonFile.loadAndValidateWithCallback}.
       */
      static async loadAndValidateWithCallbackAsync(jsonFilename, jsonSchema, errorCallback, options) {
        const jsonObject = await _JsonFile.loadAsync(jsonFilename, options);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
      }
      /**
       * Serializes the specified JSON object to a string buffer.
       * @param jsonObject - the object to be serialized
       * @param options - other settings that control serialization
       * @returns a JSON string, with newlines, and indented with two spaces
       */
      static stringify(jsonObject, options) {
        return _JsonFile.updateString("", jsonObject, options);
      }
      /**
       * Serializes the specified JSON object to a string buffer.
       * @param previousJson - the previous JSON string, which will be updated
       * @param newJsonObject - the object to be serialized
       * @param options - other settings that control serialization
       * @returns a JSON string, with newlines, and indented with two spaces
       */
      static updateString(previousJson, newJsonObject, options = {}) {
        if (!options.ignoreUndefinedValues) {
          _JsonFile.validateNoUndefinedMembers(newJsonObject);
        }
        let stringified;
        if (previousJson !== "") {
          stringified = jju.update(previousJson, newJsonObject, {
            mode: JsonSyntax.Json5,
            indent: 2
          });
        } else if (options.prettyFormatting) {
          stringified = jju.stringify(newJsonObject, {
            mode: "json",
            indent: 2
          });
          if (options.headerComment !== void 0) {
            stringified = _JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
          }
        } else {
          stringified = JSON.stringify(newJsonObject, void 0, 2);
          if (options.headerComment !== void 0) {
            stringified = _JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
          }
        }
        stringified = Text_1.Text.ensureTrailingNewline(stringified);
        if (options.newlineConversion) {
          stringified = Text_1.Text.convertTo(stringified, options.newlineConversion);
        }
        return stringified;
      }
      /**
       * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.
       * @param jsonObject - the object to be saved
       * @param jsonFilename - the file path to write
       * @param options - other settings that control how the file is saved
       * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise
       */
      static save(jsonObject, jsonFilename, options = {}) {
        let oldBuffer = void 0;
        if (options.updateExistingFile || options.onlyIfChanged) {
          try {
            oldBuffer = FileSystem_1.FileSystem.readFileToBuffer(jsonFilename);
          } catch (error) {
            if (!FileSystem_1.FileSystem.isNotExistError(error)) {
              throw error;
            }
          }
        }
        let jsonToUpdate = "";
        if (options.updateExistingFile && oldBuffer) {
          jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = _JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
          if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
            return false;
          }
        }
        FileSystem_1.FileSystem.writeFile(jsonFilename, newBuffer, {
          ensureFolderExists: options.ensureFolderExists
        });
        return true;
      }
      /**
       * An async version of {@link JsonFile.save}.
       */
      static async saveAsync(jsonObject, jsonFilename, options = {}) {
        let oldBuffer = void 0;
        if (options.updateExistingFile || options.onlyIfChanged) {
          try {
            oldBuffer = await FileSystem_1.FileSystem.readFileToBufferAsync(jsonFilename);
          } catch (error) {
            if (!FileSystem_1.FileSystem.isNotExistError(error)) {
              throw error;
            }
          }
        }
        let jsonToUpdate = "";
        if (options.updateExistingFile && oldBuffer) {
          jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = _JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
          if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
            return false;
          }
        }
        await FileSystem_1.FileSystem.writeFileAsync(jsonFilename, newBuffer, {
          ensureFolderExists: options.ensureFolderExists
        });
        return true;
      }
      /**
       * Used to validate a data structure before writing.  Reports an error if there
       * are any undefined members.
       */
      static validateNoUndefinedMembers(jsonObject) {
        return _JsonFile._validateNoUndefinedMembers(jsonObject, []);
      }
      // Private implementation of validateNoUndefinedMembers()
      static _validateNoUndefinedMembers(jsonObject, keyPath) {
        if (!jsonObject) {
          return;
        }
        if (typeof jsonObject === "object") {
          for (const key of Object.keys(jsonObject)) {
            keyPath.push(key);
            const value = jsonObject[key];
            if (value === void 0) {
              const fullPath = _JsonFile._formatKeyPath(keyPath);
              throw new Error(`The value for ${fullPath} is "undefined" and cannot be serialized as JSON`);
            }
            _JsonFile._validateNoUndefinedMembers(value, keyPath);
            keyPath.pop();
          }
        }
      }
      // Given this input:    ['items', '4', 'syntax', 'parameters', 'string "with" symbols", 'type']
      // Return this string:  items[4].syntax.parameters["string \"with\" symbols"].type
      static _formatKeyPath(keyPath) {
        let result = "";
        for (const key of keyPath) {
          if (/^[0-9]+$/.test(key)) {
            result += `[${key}]`;
          } else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {
            if (result) {
              result += ".";
            }
            result += `${key}`;
          } else {
            const escapedKey = key.replace(/[\\]/g, "\\\\").replace(/["]/g, "\\");
            result += `["${escapedKey}"]`;
          }
        }
        return result;
      }
      static _formatJsonHeaderComment(headerComment) {
        if (headerComment === "") {
          return "";
        }
        const lines = headerComment.split("\n");
        const result = [];
        for (const line of lines) {
          if (!/^\s*$/.test(line) && !/^\s*\/\//.test(line)) {
            throw new Error('The headerComment lines must be blank or start with the "//" prefix.\nInvalid line' + JSON.stringify(line));
          }
          result.push(Text_1.Text.replaceAll(line, "\r", ""));
        }
        return lines.join("\n") + "\n";
      }
      static _buildJjuParseOptions(options = {}) {
        const parseOptions = {};
        switch (options.jsonSyntax) {
          case JsonSyntax.Strict:
            parseOptions.mode = "json";
            break;
          case JsonSyntax.JsonWithComments:
            parseOptions.mode = "cjson";
            break;
          case JsonSyntax.Json5:
          default:
            parseOptions.mode = "json5";
            break;
        }
        return parseOptions;
      }
    };
    exports.JsonFile = JsonFile;
    JsonFile._formatPathForError = (path9) => path9;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/PackageJsonLookup.js
var require_PackageJsonLookup = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/PackageJsonLookup.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PackageJsonLookup = void 0;
    var path9 = __importStar(__require("path"));
    var JsonFile_1 = require_JsonFile();
    var Constants_1 = require_Constants();
    var FileSystem_1 = require_FileSystem();
    var PackageJsonLookup = class _PackageJsonLookup {
      /**
       * A singleton instance of `PackageJsonLookup`, which is useful for short-lived processes
       * that can reasonably assume that the file system will not be modified after the cache
       * is populated.
       *
       * @remarks
       * For long-running processes that need to clear the cache at appropriate times,
       * it is recommended to create your own instance of `PackageJsonLookup` instead
       * of relying on this instance.
       */
      static get instance() {
        if (!_PackageJsonLookup._instance) {
          _PackageJsonLookup._instance = new _PackageJsonLookup({ loadExtraFields: true });
        }
        return _PackageJsonLookup._instance;
      }
      constructor(parameters) {
        this._loadExtraFields = false;
        if (parameters) {
          if (parameters.loadExtraFields) {
            this._loadExtraFields = parameters.loadExtraFields;
          }
        }
        this.clearCache();
      }
      /**
       * A helper for loading the caller's own package.json file.
       *
       * @remarks
       *
       * This function provides a concise and efficient way for an NPM package to report metadata about itself.
       * For example, a tool might want to report its version.
       *
       * The `loadOwnPackageJson()` probes upwards from the caller's folder, expecting to find a package.json file,
       * which is assumed to be the caller's package.  The result is cached, under the assumption that a tool's
       * own package.json (and intermediary folders) will never change during the lifetime of the process.
       *
       * @example
       * ```ts
       * // Report the version of our NPM package
       * const myPackageVersion: string = PackageJsonLookup.loadOwnPackageJson(__dirname).version;
       * console.log(`Cool Tool - Version ${myPackageVersion}`);
       * ```
       *
       * @param dirnameOfCaller - The NodeJS `__dirname` macro for the caller.
       * @returns This function always returns a valid `IPackageJson` object.  If any problems are encountered during
       * loading, an exception will be thrown instead.
       */
      static loadOwnPackageJson(dirnameOfCaller) {
        const packageJson = _PackageJsonLookup.instance.tryLoadPackageJsonFor(dirnameOfCaller);
        if (packageJson === void 0) {
          throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed to find the caller's package.json.  The __dirname was: ${dirnameOfCaller}`);
        }
        if (packageJson.version !== void 0) {
          return packageJson;
        }
        const errorPath = _PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(dirnameOfCaller) || "package.json";
        throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed because the "version" field is missing in ${errorPath}`);
      }
      /**
       * Clears the internal file cache.
       * @remarks
       * Call this method if changes have been made to the package.json files on disk.
       */
      clearCache() {
        this._packageFolderCache = /* @__PURE__ */ new Map();
        this._packageJsonCache = /* @__PURE__ */ new Map();
      }
      /**
       * Returns the absolute path of a folder containing a package.json file, by looking
       * upwards from the specified fileOrFolderPath.  If no package.json can be found,
       * undefined is returned.
       *
       * @remarks
       * The fileOrFolderPath is not required to actually exist on disk.
       * The fileOrFolderPath itself can be the return value, if it is a folder containing
       * a package.json file.
       * Both positive and negative lookup results are cached.
       *
       * @param fileOrFolderPath - a relative or absolute path to a source file or folder
       * that may be part of a package
       * @returns an absolute path to a folder containing a package.json file
       */
      tryGetPackageFolderFor(fileOrFolderPath) {
        const resolvedFileOrFolderPath = path9.resolve(fileOrFolderPath);
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
          return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        return this._tryGetPackageFolderFor(resolvedFileOrFolderPath);
      }
      /**
       * If the specified file or folder is part of a package, this returns the absolute path
       * to the associated package.json file.
       *
       * @remarks
       * The package folder is determined using the same algorithm
       * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
       *
       * @param fileOrFolderPath - a relative or absolute path to a source file or folder
       * that may be part of a package
       * @returns an absolute path to * package.json file
       */
      tryGetPackageJsonFilePathFor(fileOrFolderPath) {
        const packageJsonFolder = this.tryGetPackageFolderFor(fileOrFolderPath);
        if (!packageJsonFolder) {
          return void 0;
        }
        return path9.join(packageJsonFolder, Constants_1.FileConstants.PackageJson);
      }
      /**
       * If the specified file or folder is part of a package, this loads and returns the
       * associated package.json file.
       *
       * @remarks
       * The package folder is determined using the same algorithm
       * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
       *
       * @param fileOrFolderPath - a relative or absolute path to a source file or folder
       * that may be part of a package
       * @returns an IPackageJson object, or undefined if the fileOrFolderPath does not
       * belong to a package
       */
      tryLoadPackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
          return void 0;
        }
        return this.loadPackageJson(packageJsonFilePath);
      }
      /**
       * This function is similar to {@link PackageJsonLookup.tryLoadPackageJsonFor}, except that it does not report
       * an error if the `version` field is missing from the package.json file.
       */
      tryLoadNodePackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
          return void 0;
        }
        return this.loadNodePackageJson(packageJsonFilePath);
      }
      /**
       * Loads the specified package.json file, if it is not already present in the cache.
       *
       * @remarks
       * Unless {@link IPackageJsonLookupParameters.loadExtraFields} was specified,
       * the returned IPackageJson object will contain a subset of essential fields.
       * The returned object should be considered to be immutable; the caller must never
       * modify it.
       *
       * @param jsonFilename - a relative or absolute path to a package.json file
       */
      loadPackageJson(jsonFilename) {
        const packageJson = this.loadNodePackageJson(jsonFilename);
        if (!packageJson.version) {
          throw new Error(`Error reading "${jsonFilename}":
  The required field "version" was not found`);
        }
        return packageJson;
      }
      /**
       * This function is similar to {@link PackageJsonLookup.loadPackageJson}, except that it does not report an error
       * if the `version` field is missing from the package.json file.
       */
      loadNodePackageJson(jsonFilename) {
        return this._loadPackageJsonInner(jsonFilename);
      }
      _loadPackageJsonInner(jsonFilename, errorsToIgnore) {
        const loadResult = this._tryLoadNodePackageJsonInner(jsonFilename);
        if (loadResult.error && (errorsToIgnore === null || errorsToIgnore === void 0 ? void 0 : errorsToIgnore.has(loadResult.error))) {
          return void 0;
        }
        switch (loadResult.error) {
          case "FILE_NOT_FOUND": {
            throw new Error(`Input file not found: ${jsonFilename}`);
          }
          case "MISSING_NAME_FIELD": {
            throw new Error(`Error reading "${jsonFilename}":
  The required field "name" was not found`);
          }
          case "OTHER_ERROR": {
            throw loadResult.errorObject;
          }
          default: {
            return loadResult.packageJson;
          }
        }
      }
      /**
       * Try to load a package.json file as an INodePackageJson,
       * returning undefined if the found file does not contain a `name` field.
       */
      _tryLoadNodePackageJsonInner(jsonFilename) {
        let normalizedFilePath;
        try {
          normalizedFilePath = FileSystem_1.FileSystem.getRealPath(jsonFilename);
        } catch (e) {
          if (FileSystem_1.FileSystem.isNotExistError(e)) {
            return {
              error: "FILE_NOT_FOUND"
            };
          } else {
            return {
              error: "OTHER_ERROR",
              errorObject: e
            };
          }
        }
        let packageJson = this._packageJsonCache.get(normalizedFilePath);
        if (!packageJson) {
          const loadedPackageJson = JsonFile_1.JsonFile.load(normalizedFilePath);
          if (!loadedPackageJson.name) {
            return {
              error: "MISSING_NAME_FIELD"
            };
          }
          if (this._loadExtraFields) {
            packageJson = loadedPackageJson;
          } else {
            packageJson = {};
            packageJson.bin = loadedPackageJson.bin;
            packageJson.dependencies = loadedPackageJson.dependencies;
            packageJson.description = loadedPackageJson.description;
            packageJson.devDependencies = loadedPackageJson.devDependencies;
            packageJson.homepage = loadedPackageJson.homepage;
            packageJson.license = loadedPackageJson.license;
            packageJson.main = loadedPackageJson.main;
            packageJson.name = loadedPackageJson.name;
            packageJson.optionalDependencies = loadedPackageJson.optionalDependencies;
            packageJson.peerDependencies = loadedPackageJson.peerDependencies;
            packageJson.private = loadedPackageJson.private;
            packageJson.scripts = loadedPackageJson.scripts;
            packageJson.typings = loadedPackageJson.typings || loadedPackageJson.types;
            packageJson.tsdocMetadata = loadedPackageJson.tsdocMetadata;
            packageJson.version = loadedPackageJson.version;
          }
          Object.freeze(packageJson);
          this._packageJsonCache.set(normalizedFilePath, packageJson);
        }
        return {
          packageJson
        };
      }
      // Recursive part of the algorithm from tryGetPackageFolderFor()
      _tryGetPackageFolderFor(resolvedFileOrFolderPath) {
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
          return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        const packageJsonFilePath = `${resolvedFileOrFolderPath}/${Constants_1.FileConstants.PackageJson}`;
        const packageJson = this._loadPackageJsonInner(packageJsonFilePath, /* @__PURE__ */ new Set(["FILE_NOT_FOUND", "MISSING_NAME_FIELD"]));
        if (packageJson) {
          this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);
          return resolvedFileOrFolderPath;
        }
        const parentFolder = path9.dirname(resolvedFileOrFolderPath);
        if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {
          this._packageFolderCache.set(resolvedFileOrFolderPath, void 0);
          return void 0;
        }
        const parentResult = this._tryGetPackageFolderFor(parentFolder);
        this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);
        return parentResult;
      }
    };
    exports.PackageJsonLookup = PackageJsonLookup;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/PackageName.js
var require_PackageName = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/PackageName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PackageName = exports.PackageNameParser = void 0;
    var PackageNameParser = class _PackageNameParser {
      constructor(options = {}) {
        this._options = Object.assign({}, options);
      }
      /**
       * This attempts to parse a package name that may include a scope component.
       * The packageName must not be an empty string.
       * @remarks
       * This function will not throw an exception.
       *
       * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be
       * nonempty if the string could not be parsed.
       */
      tryParse(packageName) {
        const result = {
          scope: "",
          unscopedName: "",
          error: ""
        };
        let input = packageName;
        if (input === null || input === void 0) {
          result.error = "The package name must not be null or undefined";
          return result;
        }
        if (packageName.length > 214) {
          result.error = "The package name cannot be longer than 214 characters";
          return result;
        }
        if (input[0] === "@") {
          const indexOfScopeSlash = input.indexOf("/");
          if (indexOfScopeSlash <= 0) {
            result.scope = input;
            result.error = `Error parsing "${packageName}": The scope must be followed by a slash`;
            return result;
          }
          result.scope = input.substr(0, indexOfScopeSlash);
          input = input.substr(indexOfScopeSlash + 1);
        }
        result.unscopedName = input;
        if (result.scope === "@") {
          result.error = `Error parsing "${packageName}": The scope name cannot be empty`;
          return result;
        }
        if (result.unscopedName === "") {
          result.error = "The package name must not be empty";
          return result;
        }
        if (result.unscopedName[0] === "." || result.unscopedName[0] === "_") {
          result.error = `The package name "${packageName}" starts with an invalid character`;
          return result;
        }
        const nameWithoutScopeSymbols = (result.scope ? result.scope.slice(1, -1) : "") + result.unscopedName;
        if (!this._options.allowUpperCase) {
          if (result.scope !== result.scope.toLowerCase()) {
            result.error = `The package scope "${result.scope}" must not contain upper case characters`;
            return result;
          }
        }
        const match = nameWithoutScopeSymbols.match(_PackageNameParser._invalidNameCharactersRegExp);
        if (match) {
          result.error = `The package name "${packageName}" contains an invalid character: "${match[0]}"`;
          return result;
        }
        return result;
      }
      /**
       * Same as {@link PackageName.tryParse}, except this throws an exception if the input
       * cannot be parsed.
       * @remarks
       * The packageName must not be an empty string.
       */
      parse(packageName) {
        const result = this.tryParse(packageName);
        if (result.error) {
          throw new Error(result.error);
        }
        return result;
      }
      /**
       * {@inheritDoc IParsedPackageName.scope}
       */
      getScope(packageName) {
        return this.parse(packageName).scope;
      }
      /**
       * {@inheritDoc IParsedPackageName.unscopedName}
       */
      getUnscopedName(packageName) {
        return this.parse(packageName).unscopedName;
      }
      /**
       * Returns true if the specified package name is valid, or false otherwise.
       * @remarks
       * This function will not throw an exception.
       */
      isValidName(packageName) {
        const result = this.tryParse(packageName);
        return !result.error;
      }
      /**
       * Throws an exception if the specified name is not a valid package name.
       * The packageName must not be an empty string.
       */
      validate(packageName) {
        this.parse(packageName);
      }
      /**
       * Combines an optional package scope with an unscoped root name.
       * @param scope - Must be either an empty string, or a scope name such as "\@example"
       * @param unscopedName - Must be a nonempty package name that does not contain a scope
       * @returns A full package name such as "\@example/some-library".
       */
      combineParts(scope, unscopedName) {
        if (scope !== "") {
          if (scope[0] !== "@") {
            throw new Error('The scope must start with an "@" character');
          }
        }
        if (scope.indexOf("/") >= 0) {
          throw new Error('The scope must not contain a "/" character');
        }
        if (unscopedName[0] === "@") {
          throw new Error('The unscopedName cannot start with an "@" character');
        }
        if (unscopedName.indexOf("/") >= 0) {
          throw new Error('The unscopedName must not contain a "/" character');
        }
        let result;
        if (scope === "") {
          result = unscopedName;
        } else {
          result = scope + "/" + unscopedName;
        }
        this.validate(result);
        return result;
      }
    };
    exports.PackageNameParser = PackageNameParser;
    PackageNameParser._invalidNameCharactersRegExp = /[^A-Za-z0-9\-_\.]/;
    var PackageName = class _PackageName {
      /** {@inheritDoc PackageNameParser.tryParse} */
      static tryParse(packageName) {
        return _PackageName._parser.tryParse(packageName);
      }
      /** {@inheritDoc PackageNameParser.parse} */
      static parse(packageName) {
        return this._parser.parse(packageName);
      }
      /** {@inheritDoc PackageNameParser.getScope} */
      static getScope(packageName) {
        return this._parser.getScope(packageName);
      }
      /** {@inheritDoc PackageNameParser.getUnscopedName} */
      static getUnscopedName(packageName) {
        return this._parser.getUnscopedName(packageName);
      }
      /** {@inheritDoc PackageNameParser.isValidName} */
      static isValidName(packageName) {
        return this._parser.isValidName(packageName);
      }
      /** {@inheritDoc PackageNameParser.validate} */
      static validate(packageName) {
        return this._parser.validate(packageName);
      }
      /** {@inheritDoc PackageNameParser.combineParts} */
      static combineParts(scope, unscopedName) {
        return this._parser.combineParts(scope, unscopedName);
      }
    };
    exports.PackageName = PackageName;
    PackageName._parser = new PackageNameParser();
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Import.js
var require_Import = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Import.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Import = void 0;
    var path9 = __importStar(__require("path"));
    var importLazy = require_import_lazy();
    var Resolve = __importStar(require_resolve());
    var nodeModule = __require("module");
    var PackageJsonLookup_1 = require_PackageJsonLookup();
    var FileSystem_1 = require_FileSystem();
    var PackageName_1 = require_PackageName();
    var Import = class _Import {
      static get _builtInModules() {
        if (!_Import.__builtInModules) {
          _Import.__builtInModules = new Set(nodeModule.builtinModules);
        }
        return _Import.__builtInModules;
      }
      /**
       * Provides a way to improve process startup times by lazy-loading imported modules.
       *
       * @remarks
       * This is a more structured wrapper for the {@link https://www.npmjs.com/package/import-lazy|import-lazy}
       * package.  It enables you to replace an import like this:
       *
       * ```ts
       * import * as example from 'example'; // <-- 100ms load time
       *
       * if (condition) {
       *   example.doSomething();
       * }
       * ```
       *
       * ...with a pattern like this:
       *
       * ```ts
       * const example: typeof import('example') = Import.lazy('example', require);
       *
       * if (condition) {
       *   example.doSomething(); // <-- 100ms load time occurs here, only if needed
       * }
       * ```
       *
       * The implementation relies on JavaScript's `Proxy` feature to intercept access to object members.  Thus
       * it will only work correctly with certain types of module exports.  If a particular export isn't well behaved,
       * you may need to find (or introduce) some other module in your dependency graph to apply the optimization to.
       *
       * Usage guidelines:
       *
       * - Always specify types using `typeof` as shown above.
       *
       * - Never apply lazy-loading in a way that would convert the module's type to `any`. Losing type safety
       *   seriously impacts the maintainability of the code base.
       *
       * - In cases where the non-runtime types are needed, import them separately using the `Types` suffix:
       *
       * ```ts
       * const example: typeof import('example') = Import.lazy('example', require);
       * import type * as exampleTypes from 'example';
       * ```
       *
       * - If the imported module confusingly has the same name as its export, then use the Module suffix:
       *
       * ```ts
       * const exampleModule: typeof import('../../logic/Example') = Import.lazy(
       *   '../../logic/Example', require);
       * import type * as exampleTypes from '../../logic/Example';
       * ```
       *
       * - If the exports cause a lot of awkwardness (e.g. too many expressions need to have `exampleModule.` inserted
       *   into them), or if some exports cannot be proxied (e.g. `Import.lazy('example', require)` returns a function
       *   signature), then do not lazy-load that module.  Instead, apply lazy-loading to some other module which is
       *   better behaved.
       *
       * - It's recommended to sort imports in a standard ordering:
       *
       * ```ts
       * // 1. external imports
       * import * as path from 'path';
       * import { Import, JsonFile, JsonObject } from '@rushstack/node-core-library';
       *
       * // 2. local imports
       * import { LocalFile } from './path/LocalFile';
       *
       * // 3. lazy-imports (which are technically variables, not imports)
       * const semver: typeof import('semver') = Import.lazy('semver', require);
       * ```
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static lazy(moduleName, require2) {
        const importLazyLocal = importLazy(require2);
        return importLazyLocal(moduleName);
      }
      /**
       * This resolves a module path using similar logic as the Node.js `require.resolve()` API,
       * but supporting extra features such as specifying the base folder.
       *
       * @remarks
       * A module path is a text string that might appear in a statement such as
       * `import { X } from "____";` or `const x = require("___");`.  The implementation is based
       * on the popular `resolve` NPM package.
       *
       * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
       * ```ts
       * // Returns "/path/to/project/node_modules/example/lib/index.js"
       * Import.resolveModule({ modulePath: 'example' });
       *
       * // Returns "/path/to/project/node_modules/example/lib/other.js"
       * Import.resolveModule({ modulePath: 'example/lib/other' });
       * ```
       * If you need to determine the containing package folder
       * (`/path/to/project/node_modules/example`), use {@link Import.resolvePackage} instead.
       *
       * @returns the absolute path of the resolved module.
       * If {@link IImportResolveOptions.includeSystemModules} is specified
       * and a system module is found, then its name is returned without any file path.
       */
      static resolveModule(options) {
        const { modulePath, baseFolderPath, includeSystemModules, allowSelfReference, getRealPath } = options;
        if (path9.isAbsolute(modulePath)) {
          return modulePath;
        }
        const normalizedRootPath = (getRealPath || FileSystem_1.FileSystem.getRealPath)(baseFolderPath);
        if (modulePath.startsWith(".")) {
          return path9.resolve(normalizedRootPath, modulePath);
        }
        const slashIndex = modulePath.indexOf("/");
        const moduleName = slashIndex === -1 ? modulePath : modulePath.slice(0, slashIndex);
        if (!includeSystemModules && _Import._builtInModules.has(moduleName)) {
          throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}".`);
        }
        if (allowSelfReference === true) {
          const ownPackage = _Import._getPackageName(normalizedRootPath);
          if (ownPackage && (modulePath === ownPackage.packageName || modulePath.startsWith(`${ownPackage.packageName}/`))) {
            const packagePath = modulePath.slice(ownPackage.packageName.length + 1);
            return path9.resolve(ownPackage.packageRootPath, packagePath);
          }
        }
        try {
          return Resolve.sync(modulePath, {
            basedir: normalizedRootPath,
            preserveSymlinks: false,
            realpathSync: getRealPath
          });
        } catch (e) {
          throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}": ${e}`);
        }
      }
      /**
       * Async version of {@link Import.resolveModule}.
       */
      static async resolveModuleAsync(options) {
        const { modulePath, baseFolderPath, includeSystemModules, allowSelfReference, getRealPath, getRealPathAsync } = options;
        if (path9.isAbsolute(modulePath)) {
          return modulePath;
        }
        const normalizedRootPath = await (getRealPathAsync || getRealPath || FileSystem_1.FileSystem.getRealPathAsync)(baseFolderPath);
        if (modulePath.startsWith(".")) {
          return path9.resolve(normalizedRootPath, modulePath);
        }
        const slashIndex = modulePath.indexOf("/");
        const moduleName = slashIndex === -1 ? modulePath : modulePath.slice(0, slashIndex);
        if (!includeSystemModules && _Import._builtInModules.has(moduleName)) {
          throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}".`);
        }
        if (allowSelfReference === true) {
          const ownPackage = _Import._getPackageName(normalizedRootPath);
          if (ownPackage && (modulePath === ownPackage.packageName || modulePath.startsWith(`${ownPackage.packageName}/`))) {
            const packagePath = modulePath.slice(ownPackage.packageName.length + 1);
            return path9.resolve(ownPackage.packageRootPath, packagePath);
          }
        }
        try {
          const resolvePromise = new Promise((resolve4, reject) => {
            const realPathFn = getRealPathAsync || getRealPath ? (filePath, callback) => {
              if (getRealPathAsync) {
                getRealPathAsync(filePath).then((resolvedPath) => callback(null, resolvedPath)).catch((error) => callback(error));
              } else {
                try {
                  const resolvedPath = getRealPath(filePath);
                  callback(null, resolvedPath);
                } catch (error) {
                  callback(error);
                }
              }
            } : void 0;
            Resolve.default(modulePath, {
              basedir: normalizedRootPath,
              preserveSymlinks: false,
              realpath: realPathFn
            }, (error, resolvedPath) => {
              if (error) {
                reject(error);
              } else {
                resolve4(resolvedPath);
              }
            });
          });
          return await resolvePromise;
        } catch (e) {
          throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}": ${e}`);
        }
      }
      /**
       * Performs module resolution to determine the folder where a package is installed.
       *
       * @remarks
       * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
       * ```ts
       * // Returns "/path/to/project/node_modules/example"
       * Import.resolvePackage({ packageName: 'example' });
       * ```
       *
       * If you need to resolve a module path, use {@link Import.resolveModule} instead:
       * ```ts
       * // Returns "/path/to/project/node_modules/example/lib/index.js"
       * Import.resolveModule({ modulePath: 'example' });
       * ```
       *
       * @returns the absolute path of the package folder.
       * If {@link IImportResolveOptions.includeSystemModules} is specified
       * and a system module is found, then its name is returned without any file path.
       */
      static resolvePackage(options) {
        const { packageName, includeSystemModules, baseFolderPath, allowSelfReference, getRealPath } = options;
        if (includeSystemModules && _Import._builtInModules.has(packageName)) {
          return packageName;
        }
        const normalizedRootPath = (getRealPath || FileSystem_1.FileSystem.getRealPath)(baseFolderPath);
        if (allowSelfReference) {
          const ownPackage = _Import._getPackageName(normalizedRootPath);
          if (ownPackage && ownPackage.packageName === packageName) {
            return ownPackage.packageRootPath;
          }
        }
        PackageName_1.PackageName.parse(packageName);
        try {
          const resolvedPath = Resolve.sync(`${packageName}/`, {
            basedir: normalizedRootPath,
            preserveSymlinks: false,
            packageFilter: (pkg, pkgFile, dir) => {
              pkg.main = "package.json";
              return pkg;
            },
            realpathSync: getRealPath
          });
          const packagePath = path9.dirname(resolvedPath);
          return packagePath;
        } catch (e) {
          throw new Error(`Cannot find package "${packageName}" from "${baseFolderPath}": ${e}.`);
        }
      }
      /**
       * Async version of {@link Import.resolvePackage}.
       */
      static async resolvePackageAsync(options) {
        const { packageName, includeSystemModules, baseFolderPath, allowSelfReference, getRealPath, getRealPathAsync } = options;
        if (includeSystemModules && _Import._builtInModules.has(packageName)) {
          return packageName;
        }
        const normalizedRootPath = await (getRealPathAsync || getRealPath || FileSystem_1.FileSystem.getRealPathAsync)(baseFolderPath);
        if (allowSelfReference) {
          const ownPackage = _Import._getPackageName(normalizedRootPath);
          if (ownPackage && ownPackage.packageName === packageName) {
            return ownPackage.packageRootPath;
          }
        }
        PackageName_1.PackageName.parse(packageName);
        try {
          const resolvePromise = new Promise((resolve4, reject) => {
            const realPathFn = getRealPathAsync || getRealPath ? (filePath, callback) => {
              if (getRealPathAsync) {
                getRealPathAsync(filePath).then((resolvedPath2) => callback(null, resolvedPath2)).catch((error) => callback(error));
              } else {
                try {
                  const resolvedPath2 = getRealPath(filePath);
                  callback(null, resolvedPath2);
                } catch (error) {
                  callback(error);
                }
              }
            } : void 0;
            Resolve.default(
              // Append a slash to the package name to ensure `resolve` doesn't attempt to return a system package
              `${packageName}/`,
              {
                basedir: normalizedRootPath,
                preserveSymlinks: false,
                packageFilter: (pkg, pkgFile, dir) => {
                  pkg.main = "package.json";
                  return pkg;
                },
                realpath: realPathFn
              },
              (error, resolvedPath2) => {
                if (error) {
                  reject(error);
                } else {
                  resolve4(resolvedPath2);
                }
              }
            );
          });
          const resolvedPath = await resolvePromise;
          const packagePath = path9.dirname(resolvedPath);
          return packagePath;
        } catch (e) {
          throw new Error(`Cannot find package "${packageName}" from "${baseFolderPath}": ${e}`);
        }
      }
      static _getPackageName(rootPath) {
        const packageJsonPath = PackageJsonLookup_1.PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(rootPath);
        if (packageJsonPath) {
          const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(packageJsonPath);
          return {
            packageRootPath: path9.dirname(packageJsonPath),
            packageName: packageJson.name
          };
        } else {
          return void 0;
        }
      }
    };
    exports.Import = Import;
  }
});

// ../../node_modules/z-schema/dist/ZSchema-browser-min.js
var require_ZSchema_browser_min = __commonJS({
  "../../node_modules/z-schema/dist/ZSchema-browser-min.js"(exports, module) {
    "use strict";
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).ZSchema = e();
      }
    }(function() {
      return function a(o, s, l) {
        function u(t, e2) {
          if (!s[t]) {
            if (!o[t]) {
              var r = "function" == typeof __require && __require;
              if (!e2 && r)
                return r(t, true);
              if (d)
                return d(t, true);
              var i = new Error("Cannot find module '" + t + "'");
              throw i.code = "MODULE_NOT_FOUND", i;
            }
            var n = s[t] = { exports: {} };
            o[t][0].call(n.exports, function(e3) {
              return u(o[t][1][e3] || e3);
            }, n, n.exports, a, o, s, l);
          }
          return s[t].exports;
        }
        for (var d = "function" == typeof __require && __require, e = 0; e < l.length; e++)
          u(l[e]);
        return u;
      }({ 1: [function(e, W, t) {
        (function(H) {
          (function() {
            var e2 = "Expected a function", i = "__lodash_hash_undefined__", r = 1 / 0, n = "[object Function]", a = "[object GeneratorFunction]", o = "[object Symbol]", s = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, l = /^\w*$/, u = /^\./, d = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, f = /\\(\\)?/g, c = /^\[object .+?Constructor\]$/, t2 = "object" == typeof H && H && H.Object === Object && H, p = "object" == typeof self && self && self.Object === Object && self, h = t2 || p || Function("return this")();
            var m, v = Array.prototype, _2 = Function.prototype, g = Object.prototype, y = h["__core-js_shared__"], E = (m = /[^.]+$/.exec(y && y.keys && y.keys.IE_PROTO || "")) ? "Symbol(src)_1." + m : "", A = _2.toString, S = g.hasOwnProperty, b = g.toString, O = RegExp("^" + A.call(S).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), M = h.Symbol, I = v.splice, R = w(h, "Map"), $ = w(Object, "create"), P = M ? M.prototype : void 0, T = P ? P.toString : void 0;
            function D(e3) {
              var t3 = -1, r2 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r2; ) {
                var i2 = e3[t3];
                this.set(i2[0], i2[1]);
              }
            }
            function L(e3) {
              var t3 = -1, r2 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r2; ) {
                var i2 = e3[t3];
                this.set(i2[0], i2[1]);
              }
            }
            function C(e3) {
              var t3 = -1, r2 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r2; ) {
                var i2 = e3[t3];
                this.set(i2[0], i2[1]);
              }
            }
            function x(e3, t3) {
              for (var r2, i2, n2 = e3.length; n2--; )
                if ((r2 = e3[n2][0]) === (i2 = t3) || r2 != r2 && i2 != i2)
                  return n2;
              return -1;
            }
            function N(e3, t3) {
              for (var r2, i2 = 0, n2 = (t3 = function(e4, t4) {
                if (Y(e4))
                  return false;
                var r3 = typeof e4;
                if ("number" == r3 || "symbol" == r3 || "boolean" == r3 || null == e4 || G(e4))
                  return true;
                return l.test(e4) || !s.test(e4) || null != t4 && e4 in Object(t4);
              }(t3, e3) ? [t3] : Y(r2 = t3) ? r2 : U(r2)).length; null != e3 && i2 < n2; )
                e3 = e3[j(t3[i2++])];
              return i2 && i2 == n2 ? e3 : void 0;
            }
            function B(e3) {
              return !(!K(e3) || (t3 = e3, E && E in t3)) && ((i2 = K(r2 = e3) ? b.call(r2) : "") == n || i2 == a || function(e4) {
                var t4 = false;
                if (null != e4 && "function" != typeof e4.toString)
                  try {
                    t4 = !!(e4 + "");
                  } catch (e5) {
                  }
                return t4;
              }(e3) ? O : c).test(function(e4) {
                if (null != e4) {
                  try {
                    return A.call(e4);
                  } catch (e5) {
                  }
                  try {
                    return e4 + "";
                  } catch (e5) {
                  }
                }
                return "";
              }(e3));
              var t3, r2, i2;
            }
            function F(e3, t3) {
              var r2, i2, n2 = e3.__data__;
              return ("string" == (i2 = typeof (r2 = t3)) || "number" == i2 || "symbol" == i2 || "boolean" == i2 ? "__proto__" !== r2 : null === r2) ? n2["string" == typeof t3 ? "string" : "hash"] : n2.map;
            }
            function w(e3, t3) {
              var r2, i2, n2 = (i2 = t3, null == (r2 = e3) ? void 0 : r2[i2]);
              return B(n2) ? n2 : void 0;
            }
            D.prototype.clear = function() {
              this.__data__ = $ ? $(null) : {};
            }, D.prototype.delete = function(e3) {
              return this.has(e3) && delete this.__data__[e3];
            }, D.prototype.get = function(e3) {
              var t3 = this.__data__;
              if ($) {
                var r2 = t3[e3];
                return r2 === i ? void 0 : r2;
              }
              return S.call(t3, e3) ? t3[e3] : void 0;
            }, D.prototype.has = function(e3) {
              var t3 = this.__data__;
              return $ ? void 0 !== t3[e3] : S.call(t3, e3);
            }, D.prototype.set = function(e3, t3) {
              return this.__data__[e3] = $ && void 0 === t3 ? i : t3, this;
            }, L.prototype.clear = function() {
              this.__data__ = [];
            }, L.prototype.delete = function(e3) {
              var t3 = this.__data__, r2 = x(t3, e3);
              return !(r2 < 0 || (r2 == t3.length - 1 ? t3.pop() : I.call(t3, r2, 1), 0));
            }, L.prototype.get = function(e3) {
              var t3 = this.__data__, r2 = x(t3, e3);
              return r2 < 0 ? void 0 : t3[r2][1];
            }, L.prototype.has = function(e3) {
              return -1 < x(this.__data__, e3);
            }, L.prototype.set = function(e3, t3) {
              var r2 = this.__data__, i2 = x(r2, e3);
              return i2 < 0 ? r2.push([e3, t3]) : r2[i2][1] = t3, this;
            }, C.prototype.clear = function() {
              this.__data__ = { hash: new D(), map: new (R || L)(), string: new D() };
            }, C.prototype.delete = function(e3) {
              return F(this, e3).delete(e3);
            }, C.prototype.get = function(e3) {
              return F(this, e3).get(e3);
            }, C.prototype.has = function(e3) {
              return F(this, e3).has(e3);
            }, C.prototype.set = function(e3, t3) {
              return F(this, e3).set(e3, t3), this;
            };
            var U = Z(function(e3) {
              var t3;
              e3 = null == (t3 = e3) ? "" : function(e4) {
                if ("string" == typeof e4)
                  return e4;
                if (G(e4))
                  return T ? T.call(e4) : "";
                var t4 = e4 + "";
                return "0" == t4 && 1 / e4 == -r ? "-0" : t4;
              }(t3);
              var n2 = [];
              return u.test(e3) && n2.push(""), e3.replace(d, function(e4, t4, r2, i2) {
                n2.push(r2 ? i2.replace(f, "$1") : t4 || e4);
              }), n2;
            });
            function j(e3) {
              if ("string" == typeof e3 || G(e3))
                return e3;
              var t3 = e3 + "";
              return "0" == t3 && 1 / e3 == -r ? "-0" : t3;
            }
            function Z(n2, a2) {
              if ("function" != typeof n2 || a2 && "function" != typeof a2)
                throw new TypeError(e2);
              var o2 = function() {
                var e3 = arguments, t3 = a2 ? a2.apply(this, e3) : e3[0], r2 = o2.cache;
                if (r2.has(t3))
                  return r2.get(t3);
                var i2 = n2.apply(this, e3);
                return o2.cache = r2.set(t3, i2), i2;
              };
              return o2.cache = new (Z.Cache || C)(), o2;
            }
            Z.Cache = C;
            var Y = Array.isArray;
            function K(e3) {
              var t3 = typeof e3;
              return !!e3 && ("object" == t3 || "function" == t3);
            }
            function G(e3) {
              return "symbol" == typeof e3 || !!(t3 = e3) && "object" == typeof t3 && b.call(e3) == o;
              var t3;
            }
            W.exports = function(e3, t3, r2) {
              var i2 = null == e3 ? void 0 : N(e3, t3);
              return void 0 === i2 ? r2 : i2;
            };
          }).call(this);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 2: [function(e, Qe, et) {
        (function(Je) {
          (function() {
            var i = "__lodash_hash_undefined__", E = 1, _2 = 2, r = 9007199254740991, g = "[object Arguments]", y = "[object Array]", n = "[object AsyncFunction]", A = "[object Boolean]", S = "[object Date]", b = "[object Error]", a = "[object Function]", o = "[object GeneratorFunction]", O = "[object Map]", M = "[object Number]", s = "[object Null]", I = "[object Object]", l = "[object Promise]", u = "[object Proxy]", R = "[object RegExp]", $ = "[object Set]", P = "[object String]", T = "[object Symbol]", d = "[object Undefined]", f = "[object WeakMap]", D = "[object ArrayBuffer]", L = "[object DataView]", c = /^\[object .+?Constructor\]$/, p = /^(?:0|[1-9]\d*)$/, t = {};
            t["[object Float32Array]"] = t["[object Float64Array]"] = t["[object Int8Array]"] = t["[object Int16Array]"] = t["[object Int32Array]"] = t["[object Uint8Array]"] = t["[object Uint8ClampedArray]"] = t["[object Uint16Array]"] = t["[object Uint32Array]"] = true, t[g] = t[y] = t[D] = t[A] = t[L] = t[S] = t[b] = t[a] = t[O] = t[M] = t[I] = t[R] = t[$] = t[P] = t[f] = false;
            var e2 = "object" == typeof Je && Je && Je.Object === Object && Je, h = "object" == typeof self && self && self.Object === Object && self, m = e2 || h || Function("return this")(), v = "object" == typeof et && et && !et.nodeType && et, C = v && "object" == typeof Qe && Qe && !Qe.nodeType && Qe, x = C && C.exports === v, N = x && e2.process, B = function() {
              try {
                return N && N.binding && N.binding("util");
              } catch (e3) {
              }
            }(), F = B && B.isTypedArray;
            function w(e3, t2) {
              for (var r2 = -1, i2 = null == e3 ? 0 : e3.length; ++r2 < i2; )
                if (t2(e3[r2], r2, e3))
                  return true;
              return false;
            }
            function U(e3) {
              var r2 = -1, i2 = Array(e3.size);
              return e3.forEach(function(e4, t2) {
                i2[++r2] = [t2, e4];
              }), i2;
            }
            function j(e3) {
              var t2 = -1, r2 = Array(e3.size);
              return e3.forEach(function(e4) {
                r2[++t2] = e4;
              }), r2;
            }
            var Z, Y, K, G = Array.prototype, H = Function.prototype, W = Object.prototype, k = m["__core-js_shared__"], V = H.toString, X = W.hasOwnProperty, z = (Z = /[^.]+$/.exec(k && k.keys && k.keys.IE_PROTO || "")) ? "Symbol(src)_1." + Z : "", q = W.toString, J = RegExp("^" + V.call(X).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Q = x ? m.Buffer : void 0, ee = m.Symbol, te = m.Uint8Array, re = W.propertyIsEnumerable, ie = G.splice, ne = ee ? ee.toStringTag : void 0, ae = Object.getOwnPropertySymbols, oe = Q ? Q.isBuffer : void 0, se = (Y = Object.keys, K = Object, function(e3) {
              return Y(K(e3));
            }), le = Be(m, "DataView"), ue = Be(m, "Map"), de = Be(m, "Promise"), fe = Be(m, "Set"), ce = Be(m, "WeakMap"), pe = Be(Object, "create"), he = je(le), me = je(ue), ve = je(de), _e = je(fe), ge = je(ce), ye = ee ? ee.prototype : void 0, Ee = ye ? ye.valueOf : void 0;
            function Ae(e3) {
              var t2 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.clear(); ++t2 < r2; ) {
                var i2 = e3[t2];
                this.set(i2[0], i2[1]);
              }
            }
            function Se(e3) {
              var t2 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.clear(); ++t2 < r2; ) {
                var i2 = e3[t2];
                this.set(i2[0], i2[1]);
              }
            }
            function be(e3) {
              var t2 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.clear(); ++t2 < r2; ) {
                var i2 = e3[t2];
                this.set(i2[0], i2[1]);
              }
            }
            function Oe(e3) {
              var t2 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.__data__ = new be(); ++t2 < r2; )
                this.add(e3[t2]);
            }
            function Me(e3) {
              var t2 = this.__data__ = new Se(e3);
              this.size = t2.size;
            }
            function Ie(e3, t2) {
              var r2 = Ke(e3), i2 = !r2 && Ye(e3), n2 = !r2 && !i2 && Ge(e3), a2 = !r2 && !i2 && !n2 && ze(e3), o2 = r2 || i2 || n2 || a2, s2 = o2 ? function(e4, t3) {
                for (var r3 = -1, i3 = Array(e4); ++r3 < e4; )
                  i3[r3] = t3(r3);
                return i3;
              }(e3.length, String) : [], l2 = s2.length;
              for (var u2 in e3)
                !t2 && !X.call(e3, u2) || o2 && ("length" == u2 || n2 && ("offset" == u2 || "parent" == u2) || a2 && ("buffer" == u2 || "byteLength" == u2 || "byteOffset" == u2) || Ue(u2, l2)) || s2.push(u2);
              return s2;
            }
            function Re(e3, t2) {
              for (var r2 = e3.length; r2--; )
                if (Ze(e3[r2][0], t2))
                  return r2;
              return -1;
            }
            function $e(e3) {
              return null == e3 ? void 0 === e3 ? d : s : ne && ne in Object(e3) ? function(e4) {
                var t3 = X.call(e4, ne), r2 = e4[ne];
                try {
                  var i2 = !(e4[ne] = void 0);
                } catch (e5) {
                }
                var n2 = q.call(e4);
                i2 && (t3 ? e4[ne] = r2 : delete e4[ne]);
                return n2;
              }(e3) : (t2 = e3, q.call(t2));
              var t2;
            }
            function Pe(e3) {
              return Ve(e3) && $e(e3) == g;
            }
            function Te(e3, t2, r2, i2, n2) {
              return e3 === t2 || (null == e3 || null == t2 || !Ve(e3) && !Ve(t2) ? e3 != e3 && t2 != t2 : function(e4, t3, r3, i3, n3, a2) {
                var o2 = Ke(e4), s2 = Ke(t3), l2 = o2 ? y : we(e4), u2 = s2 ? y : we(t3), d2 = (l2 = l2 == g ? I : l2) == I, f2 = (u2 = u2 == g ? I : u2) == I, c2 = l2 == u2;
                if (c2 && Ge(e4)) {
                  if (!Ge(t3))
                    return false;
                  d2 = !(o2 = true);
                }
                if (c2 && !d2)
                  return a2 || (a2 = new Me()), o2 || ze(e4) ? Ce(e4, t3, r3, i3, n3, a2) : function(e5, t4, r4, i4, n4, a3, o3) {
                    switch (r4) {
                      case L:
                        if (e5.byteLength != t4.byteLength || e5.byteOffset != t4.byteOffset)
                          return false;
                        e5 = e5.buffer, t4 = t4.buffer;
                      case D:
                        return !(e5.byteLength != t4.byteLength || !a3(new te(e5), new te(t4)));
                      case A:
                      case S:
                      case M:
                        return Ze(+e5, +t4);
                      case b:
                        return e5.name == t4.name && e5.message == t4.message;
                      case R:
                      case P:
                        return e5 == t4 + "";
                      case O:
                        var s3 = U;
                      case $:
                        var l3 = i4 & E;
                        if (s3 || (s3 = j), e5.size != t4.size && !l3)
                          return false;
                        var u3 = o3.get(e5);
                        if (u3)
                          return u3 == t4;
                        i4 |= _2, o3.set(e5, t4);
                        var d3 = Ce(s3(e5), s3(t4), i4, n4, a3, o3);
                        return o3.delete(e5), d3;
                      case T:
                        if (Ee)
                          return Ee.call(e5) == Ee.call(t4);
                    }
                    return false;
                  }(e4, t3, l2, r3, i3, n3, a2);
                if (!(r3 & E)) {
                  var p2 = d2 && X.call(e4, "__wrapped__"), h2 = f2 && X.call(t3, "__wrapped__");
                  if (p2 || h2) {
                    var m2 = p2 ? e4.value() : e4, v2 = h2 ? t3.value() : t3;
                    return a2 || (a2 = new Me()), n3(m2, v2, r3, i3, a2);
                  }
                }
                return !!c2 && (a2 || (a2 = new Me()), function(e5, t4, r4, i4, n4, a3) {
                  var o3 = r4 & E, s3 = xe(e5), l3 = s3.length, u3 = xe(t4).length;
                  if (l3 != u3 && !o3)
                    return false;
                  for (var d3 = l3; d3--; ) {
                    var f3 = s3[d3];
                    if (!(o3 ? f3 in t4 : X.call(t4, f3)))
                      return false;
                  }
                  var c3 = a3.get(e5);
                  if (c3 && a3.get(t4))
                    return c3 == t4;
                  var p3 = true;
                  a3.set(e5, t4), a3.set(t4, e5);
                  for (var h3 = o3; ++d3 < l3; ) {
                    f3 = s3[d3];
                    var m3 = e5[f3], v3 = t4[f3];
                    if (i4)
                      var _3 = o3 ? i4(v3, m3, f3, t4, e5, a3) : i4(m3, v3, f3, e5, t4, a3);
                    if (!(void 0 === _3 ? m3 === v3 || n4(m3, v3, r4, i4, a3) : _3)) {
                      p3 = false;
                      break;
                    }
                    h3 || (h3 = "constructor" == f3);
                  }
                  if (p3 && !h3) {
                    var g2 = e5.constructor, y2 = t4.constructor;
                    g2 != y2 && "constructor" in e5 && "constructor" in t4 && !("function" == typeof g2 && g2 instanceof g2 && "function" == typeof y2 && y2 instanceof y2) && (p3 = false);
                  }
                  return a3.delete(e5), a3.delete(t4), p3;
                }(e4, t3, r3, i3, n3, a2));
              }(e3, t2, r2, i2, Te, n2));
            }
            function De(e3) {
              return !(!ke(e3) || (t2 = e3, z && z in t2)) && (He(e3) ? J : c).test(je(e3));
              var t2;
            }
            function Le(e3) {
              if (r2 = (t2 = e3) && t2.constructor, i2 = "function" == typeof r2 && r2.prototype || W, t2 !== i2)
                return se(e3);
              var t2, r2, i2, n2 = [];
              for (var a2 in Object(e3))
                X.call(e3, a2) && "constructor" != a2 && n2.push(a2);
              return n2;
            }
            function Ce(e3, t2, i2, n2, a2, o2) {
              var r2 = i2 & E, s2 = e3.length, l2 = t2.length;
              if (s2 != l2 && !(r2 && s2 < l2))
                return false;
              var u2 = o2.get(e3);
              if (u2 && o2.get(t2))
                return u2 == t2;
              var d2 = -1, f2 = true, c2 = i2 & _2 ? new Oe() : void 0;
              for (o2.set(e3, t2), o2.set(t2, e3); ++d2 < s2; ) {
                var p2 = e3[d2], h2 = t2[d2];
                if (n2)
                  var m2 = r2 ? n2(h2, p2, d2, t2, e3, o2) : n2(p2, h2, d2, e3, t2, o2);
                if (void 0 !== m2) {
                  if (m2)
                    continue;
                  f2 = false;
                  break;
                }
                if (c2) {
                  if (!w(t2, function(e4, t3) {
                    if (r3 = t3, !c2.has(r3) && (p2 === e4 || a2(p2, e4, i2, n2, o2)))
                      return c2.push(t3);
                    var r3;
                  })) {
                    f2 = false;
                    break;
                  }
                } else if (p2 !== h2 && !a2(p2, h2, i2, n2, o2)) {
                  f2 = false;
                  break;
                }
              }
              return o2.delete(e3), o2.delete(t2), f2;
            }
            function xe(e3) {
              return r2 = Fe, i2 = qe(t2 = e3), Ke(t2) ? i2 : function(e4, t3) {
                for (var r3 = -1, i3 = t3.length, n2 = e4.length; ++r3 < i3; )
                  e4[n2 + r3] = t3[r3];
                return e4;
              }(i2, r2(t2));
              var t2, r2, i2;
            }
            function Ne(e3, t2) {
              var r2, i2, n2 = e3.__data__;
              return ("string" == (i2 = typeof (r2 = t2)) || "number" == i2 || "symbol" == i2 || "boolean" == i2 ? "__proto__" !== r2 : null === r2) ? n2["string" == typeof t2 ? "string" : "hash"] : n2.map;
            }
            function Be(e3, t2) {
              var r2, i2, n2 = (i2 = t2, null == (r2 = e3) ? void 0 : r2[i2]);
              return De(n2) ? n2 : void 0;
            }
            Ae.prototype.clear = function() {
              this.__data__ = pe ? pe(null) : {}, this.size = 0;
            }, Ae.prototype.delete = function(e3) {
              var t2 = this.has(e3) && delete this.__data__[e3];
              return this.size -= t2 ? 1 : 0, t2;
            }, Ae.prototype.get = function(e3) {
              var t2 = this.__data__;
              if (pe) {
                var r2 = t2[e3];
                return r2 === i ? void 0 : r2;
              }
              return X.call(t2, e3) ? t2[e3] : void 0;
            }, Ae.prototype.has = function(e3) {
              var t2 = this.__data__;
              return pe ? void 0 !== t2[e3] : X.call(t2, e3);
            }, Ae.prototype.set = function(e3, t2) {
              var r2 = this.__data__;
              return this.size += this.has(e3) ? 0 : 1, r2[e3] = pe && void 0 === t2 ? i : t2, this;
            }, Se.prototype.clear = function() {
              this.__data__ = [], this.size = 0;
            }, Se.prototype.delete = function(e3) {
              var t2 = this.__data__, r2 = Re(t2, e3);
              return !(r2 < 0 || (r2 == t2.length - 1 ? t2.pop() : ie.call(t2, r2, 1), --this.size, 0));
            }, Se.prototype.get = function(e3) {
              var t2 = this.__data__, r2 = Re(t2, e3);
              return r2 < 0 ? void 0 : t2[r2][1];
            }, Se.prototype.has = function(e3) {
              return -1 < Re(this.__data__, e3);
            }, Se.prototype.set = function(e3, t2) {
              var r2 = this.__data__, i2 = Re(r2, e3);
              return i2 < 0 ? (++this.size, r2.push([e3, t2])) : r2[i2][1] = t2, this;
            }, be.prototype.clear = function() {
              this.size = 0, this.__data__ = { hash: new Ae(), map: new (ue || Se)(), string: new Ae() };
            }, be.prototype.delete = function(e3) {
              var t2 = Ne(this, e3).delete(e3);
              return this.size -= t2 ? 1 : 0, t2;
            }, be.prototype.get = function(e3) {
              return Ne(this, e3).get(e3);
            }, be.prototype.has = function(e3) {
              return Ne(this, e3).has(e3);
            }, be.prototype.set = function(e3, t2) {
              var r2 = Ne(this, e3), i2 = r2.size;
              return r2.set(e3, t2), this.size += r2.size == i2 ? 0 : 1, this;
            }, Oe.prototype.add = Oe.prototype.push = function(e3) {
              return this.__data__.set(e3, i), this;
            }, Oe.prototype.has = function(e3) {
              return this.__data__.has(e3);
            }, Me.prototype.clear = function() {
              this.__data__ = new Se(), this.size = 0;
            }, Me.prototype.delete = function(e3) {
              var t2 = this.__data__, r2 = t2.delete(e3);
              return this.size = t2.size, r2;
            }, Me.prototype.get = function(e3) {
              return this.__data__.get(e3);
            }, Me.prototype.has = function(e3) {
              return this.__data__.has(e3);
            }, Me.prototype.set = function(e3, t2) {
              var r2 = this.__data__;
              if (r2 instanceof Se) {
                var i2 = r2.__data__;
                if (!ue || i2.length < 199)
                  return i2.push([e3, t2]), this.size = ++r2.size, this;
                r2 = this.__data__ = new be(i2);
              }
              return r2.set(e3, t2), this.size = r2.size, this;
            };
            var Fe = ae ? function(t2) {
              return null == t2 ? [] : (t2 = Object(t2), function(e3, t3) {
                for (var r2 = -1, i2 = null == e3 ? 0 : e3.length, n2 = 0, a2 = []; ++r2 < i2; ) {
                  var o2 = e3[r2];
                  t3(o2, r2, e3) && (a2[n2++] = o2);
                }
                return a2;
              }(ae(t2), function(e3) {
                return re.call(t2, e3);
              }));
            } : function() {
              return [];
            }, we = $e;
            function Ue(e3, t2) {
              return !!(t2 = null == t2 ? r : t2) && ("number" == typeof e3 || p.test(e3)) && -1 < e3 && e3 % 1 == 0 && e3 < t2;
            }
            function je(e3) {
              if (null != e3) {
                try {
                  return V.call(e3);
                } catch (e4) {
                }
                try {
                  return e3 + "";
                } catch (e4) {
                }
              }
              return "";
            }
            function Ze(e3, t2) {
              return e3 === t2 || e3 != e3 && t2 != t2;
            }
            (le && we(new le(new ArrayBuffer(1))) != L || ue && we(new ue()) != O || de && we(de.resolve()) != l || fe && we(new fe()) != $ || ce && we(new ce()) != f) && (we = function(e3) {
              var t2 = $e(e3), r2 = t2 == I ? e3.constructor : void 0, i2 = r2 ? je(r2) : "";
              if (i2)
                switch (i2) {
                  case he:
                    return L;
                  case me:
                    return O;
                  case ve:
                    return l;
                  case _e:
                    return $;
                  case ge:
                    return f;
                }
              return t2;
            });
            var Ye = Pe(/* @__PURE__ */ function() {
              return arguments;
            }()) ? Pe : function(e3) {
              return Ve(e3) && X.call(e3, "callee") && !re.call(e3, "callee");
            }, Ke = Array.isArray;
            var Ge = oe || function() {
              return false;
            };
            function He(e3) {
              if (!ke(e3))
                return false;
              var t2 = $e(e3);
              return t2 == a || t2 == o || t2 == n || t2 == u;
            }
            function We(e3) {
              return "number" == typeof e3 && -1 < e3 && e3 % 1 == 0 && e3 <= r;
            }
            function ke(e3) {
              var t2 = typeof e3;
              return null != e3 && ("object" == t2 || "function" == t2);
            }
            function Ve(e3) {
              return null != e3 && "object" == typeof e3;
            }
            var Xe, ze = F ? (Xe = F, function(e3) {
              return Xe(e3);
            }) : function(e3) {
              return Ve(e3) && We(e3.length) && !!t[$e(e3)];
            };
            function qe(e3) {
              return null != (t2 = e3) && We(t2.length) && !He(t2) ? Ie(e3) : Le(e3);
              var t2;
            }
            Qe.exports = function(e3, t2) {
              return Te(e3, t2);
            };
          }).call(this);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 3: [function(e, t, r) {
        var i, n, a = t.exports = {};
        function o() {
          throw new Error("setTimeout has not been defined");
        }
        function s() {
          throw new Error("clearTimeout has not been defined");
        }
        function l(t2) {
          if (i === setTimeout)
            return setTimeout(t2, 0);
          if ((i === o || !i) && setTimeout)
            return i = setTimeout, setTimeout(t2, 0);
          try {
            return i(t2, 0);
          } catch (e2) {
            try {
              return i.call(null, t2, 0);
            } catch (e3) {
              return i.call(this, t2, 0);
            }
          }
        }
        !function() {
          try {
            i = "function" == typeof setTimeout ? setTimeout : o;
          } catch (e2) {
            i = o;
          }
          try {
            n = "function" == typeof clearTimeout ? clearTimeout : s;
          } catch (e2) {
            n = s;
          }
        }();
        var u, d = [], f = false, c = -1;
        function p() {
          f && u && (f = false, u.length ? d = u.concat(d) : c = -1, d.length && h());
        }
        function h() {
          if (!f) {
            var e2 = l(p);
            f = true;
            for (var t2 = d.length; t2; ) {
              for (u = d, d = []; ++c < t2; )
                u && u[c].run();
              c = -1, t2 = d.length;
            }
            u = null, f = false, function(t3) {
              if (n === clearTimeout)
                return clearTimeout(t3);
              if ((n === s || !n) && clearTimeout)
                return n = clearTimeout, clearTimeout(t3);
              try {
                n(t3);
              } catch (e3) {
                try {
                  return n.call(null, t3);
                } catch (e4) {
                  return n.call(this, t3);
                }
              }
            }(e2);
          }
        }
        function m(e2, t2) {
          this.fun = e2, this.array = t2;
        }
        function v() {
        }
        a.nextTick = function(e2) {
          var t2 = new Array(arguments.length - 1);
          if (1 < arguments.length)
            for (var r2 = 1; r2 < arguments.length; r2++)
              t2[r2 - 1] = arguments[r2];
          d.push(new m(e2, t2)), 1 !== d.length || f || l(h);
        }, m.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, a.title = "browser", a.browser = true, a.env = {}, a.argv = [], a.version = "", a.versions = {}, a.on = v, a.addListener = v, a.once = v, a.off = v, a.removeListener = v, a.removeAllListeners = v, a.emit = v, a.prependListener = v, a.prependOnceListener = v, a.listeners = function(e2) {
          return [];
        }, a.binding = function(e2) {
          throw new Error("process.binding is not supported");
        }, a.cwd = function() {
          return "/";
        }, a.chdir = function(e2) {
          throw new Error("process.chdir is not supported");
        }, a.umask = function() {
          return 0;
        };
      }, {}], 4: [function(e, t, r) {
        "use strict";
        function o(e2) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var i = He(e("./lib/toDate")), n = He(e("./lib/toFloat")), a = He(e("./lib/toInt")), s = He(e("./lib/toBoolean")), l = He(e("./lib/equals")), u = He(e("./lib/contains")), d = He(e("./lib/matches")), f = He(e("./lib/isEmail")), c = He(e("./lib/isURL")), p = He(e("./lib/isMACAddress")), h = He(e("./lib/isIP")), m = He(e("./lib/isIPRange")), v = He(e("./lib/isFQDN")), _2 = He(e("./lib/isDate")), g = He(e("./lib/isBoolean")), y = He(e("./lib/isLocale")), E = Ge(e("./lib/isAlpha")), A = Ge(e("./lib/isAlphanumeric")), S = He(e("./lib/isNumeric")), b = He(e("./lib/isPassportNumber")), O = He(e("./lib/isPort")), M = He(e("./lib/isLowercase")), I = He(e("./lib/isUppercase")), R = He(e("./lib/isIMEI")), $ = He(e("./lib/isAscii")), P = He(e("./lib/isFullWidth")), T = He(e("./lib/isHalfWidth")), D = He(e("./lib/isVariableWidth")), L = He(e("./lib/isMultibyte")), C = He(e("./lib/isSemVer")), x = He(e("./lib/isSurrogatePair")), N = He(e("./lib/isInt")), B = Ge(e("./lib/isFloat")), F = He(e("./lib/isDecimal")), w = He(e("./lib/isHexadecimal")), U = He(e("./lib/isOctal")), j = He(e("./lib/isDivisibleBy")), Z = He(e("./lib/isHexColor")), Y = He(e("./lib/isRgbColor")), K = He(e("./lib/isHSL")), G = He(e("./lib/isISRC")), H = Ge(e("./lib/isIBAN")), W = He(e("./lib/isBIC")), k = He(e("./lib/isMD5")), V = He(e("./lib/isHash")), X = He(e("./lib/isJWT")), z = He(e("./lib/isJSON")), q = He(e("./lib/isEmpty")), J = He(e("./lib/isLength")), Q = He(e("./lib/isByteLength")), ee = He(e("./lib/isUUID")), te = He(e("./lib/isMongoId")), re = He(e("./lib/isAfter")), ie = He(e("./lib/isBefore")), ne = He(e("./lib/isIn")), ae = He(e("./lib/isCreditCard")), oe = He(e("./lib/isIdentityCard")), se = He(e("./lib/isEAN")), le = He(e("./lib/isISIN")), ue = He(e("./lib/isISBN")), de = He(e("./lib/isISSN")), fe = He(e("./lib/isTaxID")), ce = Ge(e("./lib/isMobilePhone")), pe = He(e("./lib/isEthereumAddress")), he = He(e("./lib/isCurrency")), me = He(e("./lib/isBtcAddress")), ve = He(e("./lib/isISO8601")), _e = He(e("./lib/isRFC3339")), ge = He(e("./lib/isISO31661Alpha2")), ye = He(e("./lib/isISO31661Alpha3")), Ee = He(e("./lib/isISO4217")), Ae = He(e("./lib/isBase32")), Se = He(e("./lib/isBase58")), be = He(e("./lib/isBase64")), Oe = He(e("./lib/isDataURI")), Me = He(e("./lib/isMagnetURI")), Ie = He(e("./lib/isMimeType")), Re = He(e("./lib/isLatLong")), $e = Ge(e("./lib/isPostalCode")), Pe = He(e("./lib/ltrim")), Te = He(e("./lib/rtrim")), De = He(e("./lib/trim")), Le = He(e("./lib/escape")), Ce = He(e("./lib/unescape")), xe = He(e("./lib/stripLow")), Ne = He(e("./lib/whitelist")), Be = He(e("./lib/blacklist")), Fe = He(e("./lib/isWhitelisted")), we = He(e("./lib/normalizeEmail")), Ue = He(e("./lib/isSlug")), je = He(e("./lib/isLicensePlate")), Ze = He(e("./lib/isStrongPassword")), Ye = He(e("./lib/isVAT"));
        function Ke() {
          if ("function" != typeof WeakMap)
            return null;
          var e2 = /* @__PURE__ */ new WeakMap();
          return Ke = function() {
            return e2;
          }, e2;
        }
        function Ge(e2) {
          if (e2 && e2.__esModule)
            return e2;
          if (null === e2 || "object" !== o(e2) && "function" != typeof e2)
            return { default: e2 };
          var t2 = Ke();
          if (t2 && t2.has(e2))
            return t2.get(e2);
          var r2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var n2 in e2)
            if (Object.prototype.hasOwnProperty.call(e2, n2)) {
              var a2 = i2 ? Object.getOwnPropertyDescriptor(e2, n2) : null;
              a2 && (a2.get || a2.set) ? Object.defineProperty(r2, n2, a2) : r2[n2] = e2[n2];
            }
          return r2.default = e2, t2 && t2.set(e2, r2), r2;
        }
        function He(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var We = { version: "13.7.0", toDate: i.default, toFloat: n.default, toInt: a.default, toBoolean: s.default, equals: l.default, contains: u.default, matches: d.default, isEmail: f.default, isURL: c.default, isMACAddress: p.default, isIP: h.default, isIPRange: m.default, isFQDN: v.default, isBoolean: g.default, isIBAN: H.default, isBIC: W.default, isAlpha: E.default, isAlphaLocales: E.locales, isAlphanumeric: A.default, isAlphanumericLocales: A.locales, isNumeric: S.default, isPassportNumber: b.default, isPort: O.default, isLowercase: M.default, isUppercase: I.default, isAscii: $.default, isFullWidth: P.default, isHalfWidth: T.default, isVariableWidth: D.default, isMultibyte: L.default, isSemVer: C.default, isSurrogatePair: x.default, isInt: N.default, isIMEI: R.default, isFloat: B.default, isFloatLocales: B.locales, isDecimal: F.default, isHexadecimal: w.default, isOctal: U.default, isDivisibleBy: j.default, isHexColor: Z.default, isRgbColor: Y.default, isHSL: K.default, isISRC: G.default, isMD5: k.default, isHash: V.default, isJWT: X.default, isJSON: z.default, isEmpty: q.default, isLength: J.default, isLocale: y.default, isByteLength: Q.default, isUUID: ee.default, isMongoId: te.default, isAfter: re.default, isBefore: ie.default, isIn: ne.default, isCreditCard: ae.default, isIdentityCard: oe.default, isEAN: se.default, isISIN: le.default, isISBN: ue.default, isISSN: de.default, isMobilePhone: ce.default, isMobilePhoneLocales: ce.locales, isPostalCode: $e.default, isPostalCodeLocales: $e.locales, isEthereumAddress: pe.default, isCurrency: he.default, isBtcAddress: me.default, isISO8601: ve.default, isRFC3339: _e.default, isISO31661Alpha2: ge.default, isISO31661Alpha3: ye.default, isISO4217: Ee.default, isBase32: Ae.default, isBase58: Se.default, isBase64: be.default, isDataURI: Oe.default, isMagnetURI: Me.default, isMimeType: Ie.default, isLatLong: Re.default, ltrim: Pe.default, rtrim: Te.default, trim: De.default, escape: Le.default, unescape: Ce.default, stripLow: xe.default, whitelist: Ne.default, blacklist: Be.default, isWhitelisted: Fe.default, normalizeEmail: we.default, toString, isSlug: Ue.default, isStrongPassword: Ze.default, isTaxID: fe.default, isDate: _2.default, isLicensePlate: je.default, isVAT: Ye.default, ibanLocales: H.locales };
        r.default = We, t.exports = r.default, t.exports.default = r.default;
      }, { "./lib/blacklist": 6, "./lib/contains": 7, "./lib/equals": 8, "./lib/escape": 9, "./lib/isAfter": 10, "./lib/isAlpha": 11, "./lib/isAlphanumeric": 12, "./lib/isAscii": 13, "./lib/isBIC": 14, "./lib/isBase32": 15, "./lib/isBase58": 16, "./lib/isBase64": 17, "./lib/isBefore": 18, "./lib/isBoolean": 19, "./lib/isBtcAddress": 20, "./lib/isByteLength": 21, "./lib/isCreditCard": 22, "./lib/isCurrency": 23, "./lib/isDataURI": 24, "./lib/isDate": 25, "./lib/isDecimal": 26, "./lib/isDivisibleBy": 27, "./lib/isEAN": 28, "./lib/isEmail": 29, "./lib/isEmpty": 30, "./lib/isEthereumAddress": 31, "./lib/isFQDN": 32, "./lib/isFloat": 33, "./lib/isFullWidth": 34, "./lib/isHSL": 35, "./lib/isHalfWidth": 36, "./lib/isHash": 37, "./lib/isHexColor": 38, "./lib/isHexadecimal": 39, "./lib/isIBAN": 40, "./lib/isIMEI": 41, "./lib/isIP": 42, "./lib/isIPRange": 43, "./lib/isISBN": 44, "./lib/isISIN": 45, "./lib/isISO31661Alpha2": 46, "./lib/isISO31661Alpha3": 47, "./lib/isISO4217": 48, "./lib/isISO8601": 49, "./lib/isISRC": 50, "./lib/isISSN": 51, "./lib/isIdentityCard": 52, "./lib/isIn": 53, "./lib/isInt": 54, "./lib/isJSON": 55, "./lib/isJWT": 56, "./lib/isLatLong": 57, "./lib/isLength": 58, "./lib/isLicensePlate": 59, "./lib/isLocale": 60, "./lib/isLowercase": 61, "./lib/isMACAddress": 62, "./lib/isMD5": 63, "./lib/isMagnetURI": 64, "./lib/isMimeType": 65, "./lib/isMobilePhone": 66, "./lib/isMongoId": 67, "./lib/isMultibyte": 68, "./lib/isNumeric": 69, "./lib/isOctal": 70, "./lib/isPassportNumber": 71, "./lib/isPort": 72, "./lib/isPostalCode": 73, "./lib/isRFC3339": 74, "./lib/isRgbColor": 75, "./lib/isSemVer": 76, "./lib/isSlug": 77, "./lib/isStrongPassword": 78, "./lib/isSurrogatePair": 79, "./lib/isTaxID": 80, "./lib/isURL": 81, "./lib/isUUID": 82, "./lib/isUppercase": 83, "./lib/isVAT": 84, "./lib/isVariableWidth": 85, "./lib/isWhitelisted": 86, "./lib/ltrim": 87, "./lib/matches": 88, "./lib/normalizeEmail": 89, "./lib/rtrim": 90, "./lib/stripLow": 91, "./lib/toBoolean": 92, "./lib/toDate": 93, "./lib/toFloat": 94, "./lib/toInt": 95, "./lib/trim": 96, "./lib/unescape": 97, "./lib/whitelist": 104 }], 5: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.commaDecimal = r.dotDecimal = r.farsiLocales = r.arabicLocales = r.englishLocales = r.decimal = r.alphanumeric = r.alpha = void 0;
        var i = { "en-US": /^[A-Z]+$/i, "az-AZ": /^[A-VXYZÇƏĞİıÖŞÜ]+$/i, "bg-BG": /^[А-Я]+$/i, "cs-CZ": /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i, "da-DK": /^[A-ZÆØÅ]+$/i, "de-DE": /^[A-ZÄÖÜß]+$/i, "el-GR": /^[Α-ώ]+$/i, "es-ES": /^[A-ZÁÉÍÑÓÚÜ]+$/i, "fa-IR": /^[ابپتثجچحخدذرزژسشصضطظعغفقکگلمنوهی]+$/i, "fi-FI": /^[A-ZÅÄÖ]+$/i, "fr-FR": /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i, "it-IT": /^[A-ZÀÉÈÌÎÓÒÙ]+$/i, "nb-NO": /^[A-ZÆØÅ]+$/i, "nl-NL": /^[A-ZÁÉËÏÓÖÜÚ]+$/i, "nn-NO": /^[A-ZÆØÅ]+$/i, "hu-HU": /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i, "pl-PL": /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i, "pt-PT": /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i, "ru-RU": /^[А-ЯЁ]+$/i, "sl-SI": /^[A-ZČĆĐŠŽ]+$/i, "sk-SK": /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i, "sr-RS@latin": /^[A-ZČĆŽŠĐ]+$/i, "sr-RS": /^[А-ЯЂЈЉЊЋЏ]+$/i, "sv-SE": /^[A-ZÅÄÖ]+$/i, "th-TH": /^[ก-๐\s]+$/i, "tr-TR": /^[A-ZÇĞİıÖŞÜ]+$/i, "uk-UA": /^[А-ЩЬЮЯЄIЇҐі]+$/i, "vi-VN": /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i, "ku-IQ": /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i, ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/, he: /^[א-ת]+$/, fa: /^['آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی']+$/i, "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i };
        r.alpha = i;
        var n = { "en-US": /^[0-9A-Z]+$/i, "az-AZ": /^[0-9A-VXYZÇƏĞİıÖŞÜ]+$/i, "bg-BG": /^[0-9А-Я]+$/i, "cs-CZ": /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i, "da-DK": /^[0-9A-ZÆØÅ]+$/i, "de-DE": /^[0-9A-ZÄÖÜß]+$/i, "el-GR": /^[0-9Α-ω]+$/i, "es-ES": /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i, "fi-FI": /^[0-9A-ZÅÄÖ]+$/i, "fr-FR": /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i, "it-IT": /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i, "hu-HU": /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i, "nb-NO": /^[0-9A-ZÆØÅ]+$/i, "nl-NL": /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i, "nn-NO": /^[0-9A-ZÆØÅ]+$/i, "pl-PL": /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i, "pt-PT": /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i, "ru-RU": /^[0-9А-ЯЁ]+$/i, "sl-SI": /^[0-9A-ZČĆĐŠŽ]+$/i, "sk-SK": /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i, "sr-RS@latin": /^[0-9A-ZČĆŽŠĐ]+$/i, "sr-RS": /^[0-9А-ЯЂЈЉЊЋЏ]+$/i, "sv-SE": /^[0-9A-ZÅÄÖ]+$/i, "th-TH": /^[ก-๙\s]+$/i, "tr-TR": /^[0-9A-ZÇĞİıÖŞÜ]+$/i, "uk-UA": /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i, "ku-IQ": /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i, "vi-VN": /^[0-9A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i, ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/, he: /^[0-9א-ת]+$/, fa: /^['0-9آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی۱۲۳۴۵۶۷۸۹۰']+$/i, "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i };
        r.alphanumeric = n;
        var a = { "en-US": ".", ar: "\u066B" };
        r.decimal = a;
        var o = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
        r.englishLocales = o;
        for (var s, l = 0; l < o.length; l++)
          i[s = "en-".concat(o[l])] = i["en-US"], n[s] = n["en-US"], a[s] = a["en-US"];
        var u = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
        r.arabicLocales = u;
        for (var d, f = 0; f < u.length; f++)
          i[d = "ar-".concat(u[f])] = i.ar, n[d] = n.ar, a[d] = a.ar;
        var c = ["IR", "AF"];
        r.farsiLocales = c;
        for (var p, h = 0; h < c.length; h++)
          n[p = "fa-".concat(c[h])] = n.fa, a[p] = a.ar;
        var m = ["ar-EG", "ar-LB", "ar-LY"];
        r.dotDecimal = m;
        var v = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
        r.commaDecimal = v;
        for (var _2 = 0; _2 < m.length; _2++)
          a[m[_2]] = a["en-US"];
        for (var g = 0; g < v.length; g++)
          a[v[g]] = ",";
        i["fr-CA"] = i["fr-FR"], n["fr-CA"] = n["fr-FR"], i["pt-BR"] = i["pt-PT"], n["pt-BR"] = n["pt-PT"], a["pt-BR"] = a["pt-PT"], i["pl-Pl"] = i["pl-PL"], n["pl-Pl"] = n["pl-PL"], a["pl-Pl"] = a["pl-PL"], i["fa-AF"] = i.fa;
      }, {}], 6: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), e2.replace(new RegExp("[".concat(t2, "]+"), "g"), "");
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 7: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2, r2) {
          if ((0, i.default)(e2), (r2 = (0, a.default)(r2, s)).ignoreCase)
            return e2.toLowerCase().split((0, n.default)(t2).toLowerCase()).length > r2.minOccurrences;
          return e2.split((0, n.default)(t2)).length > r2.minOccurrences;
        };
        var i = o(e("./util/assertString")), n = o(e("./util/toString")), a = o(e("./util/merge"));
        function o(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var s = { ignoreCase: false, minOccurrences: 1 };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101, "./util/toString": 103 }], 8: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), e2 === t2;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 9: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), e2.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;");
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 10: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : String(/* @__PURE__ */ new Date());
          (0, n.default)(e2);
          var r2 = (0, a.default)(t2), i2 = (0, a.default)(e2);
          return !!(i2 && r2 && r2 < i2);
        };
        var n = i(e("./util/assertString")), a = i(e("./toDate"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./toDate": 93, "./util/assertString": 99 }], 11: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "en-US", r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
          (0, a.default)(e2);
          var i2 = e2, n2 = r2.ignore;
          if (n2)
            if (n2 instanceof RegExp)
              i2 = i2.replace(n2, "");
            else {
              if ("string" != typeof n2)
                throw new Error("ignore should be instance of a String or RegExp");
              i2 = i2.replace(new RegExp("[".concat(n2.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
            }
          if (t2 in o.alpha)
            return o.alpha[t2].test(i2);
          throw new Error("Invalid locale '".concat(t2, "'"));
        }, r.locales = void 0;
        var i, a = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, o = e("./alpha");
        var n = Object.keys(o.alpha);
        r.locales = n;
      }, { "./alpha": 5, "./util/assertString": 99 }], 12: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "en-US", r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
          (0, a.default)(e2);
          var i2 = e2, n2 = r2.ignore;
          if (n2)
            if (n2 instanceof RegExp)
              i2 = i2.replace(n2, "");
            else {
              if ("string" != typeof n2)
                throw new Error("ignore should be instance of a String or RegExp");
              i2 = i2.replace(new RegExp("[".concat(n2.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
            }
          if (t2 in o.alphanumeric)
            return o.alphanumeric[t2].test(i2);
          throw new Error("Invalid locale '".concat(t2, "'"));
        }, r.locales = void 0;
        var i, a = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, o = e("./alpha");
        var n = Object.keys(o.alphanumeric);
        r.locales = n;
      }, { "./alpha": 5, "./util/assertString": 99 }], 13: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[\x00-\x7F]+$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 14: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), !!a.CountryCodes.has(e2.slice(4, 6).toUpperCase()) && o.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, a = e("./isISO31661Alpha2");
        var o = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isISO31661Alpha2": 46, "./util/assertString": 99 }], 15: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          if ((0, n.default)(e2), e2.length % 8 == 0 && a.test(e2))
            return true;
          return false;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[A-Z2-7]+=*$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 16: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          if ((0, n.default)(e2), a.test(e2))
            return true;
          return false;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[A-HJ-NP-Za-km-z1-9]*$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 17: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2), t2 = (0, a.default)(t2, l);
          var r2 = e2.length;
          if (t2.urlSafe)
            return s.test(e2);
          if (r2 % 4 != 0 || o.test(e2))
            return false;
          var i2 = e2.indexOf("=");
          return -1 === i2 || i2 === r2 - 1 || i2 === r2 - 2 && "=" === e2[r2 - 1];
        };
        var n = i(e("./util/assertString")), a = i(e("./util/merge"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = /[^A-Z0-9+\/=]/i, s = /^[A-Z0-9_\-]*$/i, l = { urlSafe: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 18: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : String(/* @__PURE__ */ new Date());
          (0, n.default)(e2);
          var r2 = (0, a.default)(t2), i2 = (0, a.default)(e2);
          return !!(i2 && r2 && i2 < r2);
        };
        var n = i(e("./util/assertString")), a = i(e("./toDate"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./toDate": 93, "./util/assertString": 99 }], 19: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : a;
          if ((0, n.default)(e2), t2.loose)
            return s.includes(e2.toLowerCase());
          return o.includes(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { loose: false }, o = ["true", "false", "1", "0"], s = [].concat(o, ["yes", "no"]);
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 20: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          if ((0, n.default)(e2), e2.startsWith("bc1"))
            return a.test(e2);
          return o.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(bc1)[a-z0-9]{25,39}$/, o = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 21: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          var r2, i2;
          (0, a.default)(e2), i2 = "object" === o(t2) ? (r2 = t2.min || 0, t2.max) : (r2 = arguments[1], arguments[2]);
          var n = encodeURI(e2).split(/%..|./).length - 1;
          return r2 <= n && (void 0 === i2 || n <= i2);
        };
        var i, a = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        function o(e2) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 22: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          (0, s.default)(e2);
          var t2 = e2.replace(/[- ]+/g, "");
          if (!l.test(t2))
            return false;
          for (var r2, i2, n, a = 0, o = t2.length - 1; 0 <= o; o--)
            r2 = t2.substring(o, o + 1), i2 = parseInt(r2, 10), a += n && 10 <= (i2 *= 2) ? i2 % 10 + 1 : i2, n = !n;
          return !(a % 10 != 0 || !t2);
        };
        var i, s = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var l = /^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 23: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), function(e3) {
            var r2 = "\\d{".concat(e3.digits_after_decimal[0], "}");
            e3.digits_after_decimal.forEach(function(e4, t4) {
              0 !== t4 && (r2 = "".concat(r2, "|\\d{").concat(e4, "}"));
            });
            var t3 = "(".concat(e3.symbol.replace(/\W/, function(e4) {
              return "\\".concat(e4);
            }), ")").concat(e3.require_symbol ? "" : "?"), i2 = "[1-9]\\d{0,2}(\\".concat(e3.thousands_separator, "\\d{3})*"), n2 = "(".concat(["0", "[1-9]\\d*", i2].join("|"), ")?"), a2 = "(\\".concat(e3.decimal_separator, "(").concat(r2, "))").concat(e3.require_decimal ? "" : "?"), o2 = n2 + (e3.allow_decimal || e3.require_decimal ? a2 : "");
            return e3.allow_negatives && !e3.parens_for_negatives && (e3.negative_sign_after_digits ? o2 += "-?" : e3.negative_sign_before_digits && (o2 = "-?" + o2)), e3.allow_negative_sign_placeholder ? o2 = "( (?!\\-))?".concat(o2) : e3.allow_space_after_symbol ? o2 = " ?".concat(o2) : e3.allow_space_after_digits && (o2 += "( (?!$))?"), e3.symbol_after_digits ? o2 += t3 : o2 = t3 + o2, e3.allow_negatives && (e3.parens_for_negatives ? o2 = "(\\(".concat(o2, "\\)|").concat(o2, ")") : e3.negative_sign_before_digits || e3.negative_sign_after_digits || (o2 = "-?" + o2)), new RegExp("^(?!-? )(?=.*\\d)".concat(o2, "$"));
          }(t2 = (0, i.default)(t2, o)).test(e2);
        };
        var i = a(e("./util/merge")), n = a(e("./util/assertString"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = { symbol: "$", require_symbol: false, allow_space_after_symbol: false, symbol_after_digits: false, allow_negatives: true, parens_for_negatives: false, negative_sign_before_digits: false, negative_sign_after_digits: false, allow_negative_sign_placeholder: false, thousands_separator: ",", decimal_separator: ".", allow_decimal: true, require_decimal: false, digits_after_decimal: [2], allow_space_after_digits: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 24: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          (0, s.default)(e2);
          var t2 = e2.split(",");
          if (t2.length < 2)
            return false;
          var r2 = t2.shift().trim().split(";"), i2 = r2.shift();
          if ("data:" !== i2.substr(0, 5))
            return false;
          var n = i2.substr(5);
          if ("" !== n && !l.test(n))
            return false;
          for (var a = 0; a < r2.length; a++)
            if ((a !== r2.length - 1 || "base64" !== r2[a].toLowerCase()) && !u.test(r2[a]))
              return false;
          for (var o = 0; o < t2.length; o++)
            if (!d.test(t2[o]))
              return false;
          return true;
        };
        var i, s = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var l = /^[a-z]+\/[a-z0-9\-\+]+$/i, u = /^[a-z\-]+=[a-z0-9\-]+$/i, d = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 25: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(t2, r2) {
          r2 = "string" == typeof r2 ? (0, h.default)({ format: r2 }, v) : (0, h.default)(r2, v);
          if ("string" == typeof t2 && (p = r2.format, /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(p))) {
            var e2, i2 = r2.delimiters.find(function(e3) {
              return -1 !== r2.format.indexOf(e3);
            }), n2 = r2.strictMode ? i2 : r2.delimiters.find(function(e3) {
              return -1 !== t2.indexOf(e3);
            }), a = function(e3, t3) {
              for (var r3 = [], i3 = Math.min(e3.length, t3.length), n3 = 0; n3 < i3; n3++)
                r3.push([e3[n3], t3[n3]]);
              return r3;
            }(t2.split(n2), r2.format.toLowerCase().split(i2)), o = {}, s = function(e3, t3) {
              var r3;
              if ("undefined" == typeof Symbol || null == e3[Symbol.iterator]) {
                if (Array.isArray(e3) || (r3 = m(e3)) || t3 && e3 && "number" == typeof e3.length) {
                  r3 && (e3 = r3);
                  var i3 = 0, n3 = function() {
                  };
                  return { s: n3, n: function() {
                    return i3 >= e3.length ? { done: true } : { done: false, value: e3[i3++] };
                  }, e: function(e4) {
                    throw e4;
                  }, f: n3 };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var a2, o2 = true, s2 = false;
              return { s: function() {
                r3 = e3[Symbol.iterator]();
              }, n: function() {
                var e4 = r3.next();
                return o2 = e4.done, e4;
              }, e: function(e4) {
                s2 = true, a2 = e4;
              }, f: function() {
                try {
                  o2 || null == r3.return || r3.return();
                } finally {
                  if (s2)
                    throw a2;
                }
              } };
            }(a);
            try {
              for (s.s(); !(e2 = s.n()).done; ) {
                var l = (f = e2.value, c = 2, function(e3) {
                  if (Array.isArray(e3))
                    return e3;
                }(f) || function(e3, t3) {
                  if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e3)))
                    return;
                  var r3 = [], i3 = true, n3 = false, a2 = void 0;
                  try {
                    for (var o2, s2 = e3[Symbol.iterator](); !(i3 = (o2 = s2.next()).done) && (r3.push(o2.value), !t3 || r3.length !== t3); i3 = true)
                      ;
                  } catch (e4) {
                    n3 = true, a2 = e4;
                  } finally {
                    try {
                      i3 || null == s2.return || s2.return();
                    } finally {
                      if (n3)
                        throw a2;
                    }
                  }
                  return r3;
                }(f, c) || m(f, c) || function() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }()), u = l[0], d = l[1];
                if (u.length !== d.length)
                  return false;
                o[d.charAt(0)] = u;
              }
            } catch (e3) {
              s.e(e3);
            } finally {
              s.f();
            }
            return new Date("".concat(o.m, "/").concat(o.d, "/").concat(o.y)).getDate() === +o.d;
          }
          var f, c;
          var p;
          return !r2.strictMode && "[object Date]" === Object.prototype.toString.call(t2) && isFinite(t2);
        };
        var i, h = (i = e("./util/merge")) && i.__esModule ? i : { default: i };
        function m(e2, t2) {
          if (e2) {
            if ("string" == typeof e2)
              return n(e2, t2);
            var r2 = Object.prototype.toString.call(e2).slice(8, -1);
            return "Object" === r2 && e2.constructor && (r2 = e2.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(e2) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? n(e2, t2) : void 0;
          }
        }
        function n(e2, t2) {
          (null == t2 || t2 > e2.length) && (t2 = e2.length);
          for (var r2 = 0, i2 = new Array(t2); r2 < t2; r2++)
            i2[r2] = e2[r2];
          return i2;
        }
        var v = { format: "YYYY/MM/DD", delimiters: ["/", "-"], strictMode: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/merge": 101 }], 26: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), (t2 = (0, i.default)(t2, l)).locale in o.decimal)
            return !(0, a.default)(u, e2.replace(/ /g, "")) && (r2 = t2, new RegExp("^[-+]?([0-9]+)?(\\".concat(o.decimal[r2.locale], "[0-9]{").concat(r2.decimal_digits, "})").concat(r2.force_decimal ? "" : "?", "$"))).test(e2);
          var r2;
          throw new Error("Invalid locale '".concat(t2.locale, "'"));
        };
        var i = s(e("./util/merge")), n = s(e("./util/assertString")), a = s(e("./util/includes")), o = e("./alpha");
        function s(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var l = { force_decimal: false, decimal_digits: "1,", locale: "en-US" }, u = ["", "-", "+"];
        t.exports = r.default, t.exports.default = r.default;
      }, { "./alpha": 5, "./util/assertString": 99, "./util/includes": 100, "./util/merge": 101 }], 27: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, i.default)(e2), (0, n.default)(e2) % parseInt(t2, 10) == 0;
        };
        var i = a(e("./util/assertString")), n = a(e("./toFloat"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./toFloat": 94, "./util/assertString": 99 }], 28: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          (0, a.default)(e2);
          var t2 = Number(e2.slice(-1));
          return l.test(e2) && t2 === (n = e2, r2 = 10 - n.slice(0, -1).split("").map(function(e3, t3) {
            return Number(e3) * (r3 = n.length, i2 = t3, r3 !== o && r3 !== s ? i2 % 2 == 0 ? 1 : 3 : i2 % 2 == 0 ? 3 : 1);
            var r3, i2;
          }).reduce(function(e3, t3) {
            return e3 + t3;
          }, 0) % 10, r2 < 10 ? r2 : 0);
          var n, r2;
        };
        var i, a = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var o = 8, s = 14, l = /^(\d{8}|\d{13}|\d{14})$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 29: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, m.default)(e2), (t2 = (0, v.default)(t2, E)).require_display_name || t2.allow_display_name) {
            var r2 = e2.match(A);
            if (r2) {
              var i2 = r2[1];
              if (e2 = e2.replace(i2, "").replace(/(^<|>$)/g, ""), i2.endsWith(" ") && (i2 = i2.substr(0, i2.length - 1)), !function(e3) {
                var t3 = e3.replace(/^"(.+)"$/, "$1");
                if (!t3.trim())
                  return false;
                if (/[\.";<>]/.test(t3)) {
                  if (t3 === e3)
                    return false;
                  var r3 = t3.split('"').length === t3.split('\\"').length;
                  if (!r3)
                    return false;
                }
                return true;
              }(i2))
                return false;
            } else if (t2.require_display_name)
              return false;
          }
          if (!t2.ignore_max_length && e2.length > R)
            return false;
          var n = e2.split("@"), a = n.pop(), o = a.toLowerCase();
          if (t2.host_blacklist.includes(o))
            return false;
          var s = n.join("@");
          if (t2.domain_specific_validation && ("gmail.com" === o || "googlemail.com" === o)) {
            var l = (s = s.toLowerCase()).split("+")[0];
            if (!(0, _2.default)(l.replace(/\./g, ""), { min: 6, max: 30 }))
              return false;
            for (var u = l.split("."), d = 0; d < u.length; d++)
              if (!b.test(u[d]))
                return false;
          }
          if (!(false !== t2.ignore_max_length || (0, _2.default)(s, { max: 64 }) && (0, _2.default)(a, { max: 254 })))
            return false;
          if (!(0, g.default)(a, { require_tld: t2.require_tld })) {
            if (!t2.allow_ip_domain)
              return false;
            if (!(0, y.default)(a)) {
              if (!a.startsWith("[") || !a.endsWith("]"))
                return false;
              var f = a.substr(1, a.length - 2);
              if (0 === f.length || !(0, y.default)(f))
                return false;
            }
          }
          if ('"' === s[0])
            return s = s.slice(1, s.length - 1), t2.allow_utf8_local_part ? I.test(s) : O.test(s);
          for (var c = t2.allow_utf8_local_part ? M : S, p = s.split("."), h = 0; h < p.length; h++)
            if (!c.test(p[h]))
              return false;
          if (t2.blacklisted_chars && -1 !== s.search(new RegExp("[".concat(t2.blacklisted_chars, "]+"), "g")))
            return false;
          return true;
        };
        var m = i(e("./util/assertString")), v = i(e("./util/merge")), _2 = i(e("./isByteLength")), g = i(e("./isFQDN")), y = i(e("./isIP"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var E = { allow_display_name: false, require_display_name: false, allow_utf8_local_part: true, require_tld: true, blacklisted_chars: "", ignore_max_length: false, host_blacklist: [] }, A = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i, S = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i, b = /^[a-z\d]+$/, O = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i, M = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i, I = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i, R = 254;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isByteLength": 21, "./isFQDN": 32, "./isIP": 42, "./util/assertString": 99, "./util/merge": 101 }], 30: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, i.default)(e2), 0 === ((t2 = (0, n.default)(t2, o)).ignore_whitespace ? e2.trim().length : e2.length);
        };
        var i = a(e("./util/assertString")), n = a(e("./util/merge"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = { ignore_whitespace: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 31: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(0x)[0-9a-f]{40}$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 32: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2), (t2 = (0, a.default)(t2, o)).allow_trailing_dot && "." === e2[e2.length - 1] && (e2 = e2.substring(0, e2.length - 1));
          true === t2.allow_wildcard && 0 === e2.indexOf("*.") && (e2 = e2.substring(2));
          var r2 = e2.split("."), i2 = r2[r2.length - 1];
          if (t2.require_tld) {
            if (r2.length < 2)
              return false;
            if (!/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(i2))
              return false;
            if (/\s/.test(i2))
              return false;
          }
          return !(!t2.allow_numeric_tld && /^\d+$/.test(i2)) && r2.every(function(e3) {
            return !(63 < e3.length || !/^[a-z_\u00a1-\uffff0-9-]+$/i.test(e3) || /[\uff01-\uff5e]/.test(e3) || /^-|-$/.test(e3) || !t2.allow_underscores && /_/.test(e3));
          });
        };
        var n = i(e("./util/assertString")), a = i(e("./util/merge"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = { require_tld: true, allow_underscores: false, allow_trailing_dot: false, allow_numeric_tld: false, allow_wildcard: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 33: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2), t2 = t2 || {};
          var r2 = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(t2.locale ? a.decimal[t2.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
          if ("" === e2 || "." === e2 || "-" === e2 || "+" === e2)
            return false;
          var i2 = parseFloat(e2.replace(",", "."));
          return r2.test(e2) && (!t2.hasOwnProperty("min") || i2 >= t2.min) && (!t2.hasOwnProperty("max") || i2 <= t2.max) && (!t2.hasOwnProperty("lt") || i2 < t2.lt) && (!t2.hasOwnProperty("gt") || i2 > t2.gt);
        }, r.locales = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, a = e("./alpha");
        var o = Object.keys(a.decimal);
        r.locales = o;
      }, { "./alpha": 5, "./util/assertString": 99 }], 34: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        }, r.fullWidth = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
        r.fullWidth = a;
      }, { "./util/assertString": 99 }], 35: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          (0, n.default)(e2);
          var t2 = e2.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/gi, "$1");
          return -1 === t2.indexOf(",") ? o.test(t2) : a.test(t2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i, o = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 36: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        }, r.halfWidth = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
        r.halfWidth = a;
      }, { "./util/assertString": 99 }], 37: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), new RegExp("^[a-fA-F0-9]{".concat(a[t2], "}$")).test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { md5: 32, md4: 32, sha1: 40, sha256: 64, sha384: 96, sha512: 128, ripemd128: 32, ripemd160: 40, tiger128: 32, tiger160: 40, tiger192: 48, crc32: 8, crc32b: 8 };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 38: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 39: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(0x|0h)?[0-9A-F]+$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 40: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, o.default)(e2), i2 = e2, n2 = i2.replace(/[\s\-]+/gi, "").toUpperCase(), a = n2.slice(0, 2).toUpperCase(), a in s && s[a].test(n2) && (t2 = e2, r2 = t2.replace(/[^A-Z0-9]+/gi, "").toUpperCase(), 1 === (r2.slice(4) + r2.slice(0, 4)).replace(/[A-Z]/g, function(e3) {
            return e3.charCodeAt(0) - 55;
          }).match(/\d{1,7}/g).reduce(function(e3, t3) {
            return Number(e3 + t3) % 97;
          }, ""));
          var t2, r2;
          var i2, n2, a;
        }, r.locales = void 0;
        var i, o = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var s = { AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/, AE: /^(AE[0-9]{2})\d{3}\d{16}$/, AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/, AT: /^(AT[0-9]{2})\d{16}$/, AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/, BA: /^(BA[0-9]{2})\d{16}$/, BE: /^(BE[0-9]{2})\d{12}$/, BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/, BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/, BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/, BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/, CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/, CR: /^(CR[0-9]{2})\d{18}$/, CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/, CZ: /^(CZ[0-9]{2})\d{20}$/, DE: /^(DE[0-9]{2})\d{18}$/, DK: /^(DK[0-9]{2})\d{14}$/, DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/, EE: /^(EE[0-9]{2})\d{16}$/, EG: /^(EG[0-9]{2})\d{25}$/, ES: /^(ES[0-9]{2})\d{20}$/, FI: /^(FI[0-9]{2})\d{14}$/, FO: /^(FO[0-9]{2})\d{14}$/, FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/, GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/, GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/, GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/, GL: /^(GL[0-9]{2})\d{14}$/, GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/, GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/, HR: /^(HR[0-9]{2})\d{17}$/, HU: /^(HU[0-9]{2})\d{24}$/, IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/, IL: /^(IL[0-9]{2})\d{19}$/, IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/, IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/, IS: /^(IS[0-9]{2})\d{22}$/, IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/, JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/, KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/, KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/, LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/, LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/, LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/, LT: /^(LT[0-9]{2})\d{16}$/, LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/, LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/, MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/, MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/, ME: /^(ME[0-9]{2})\d{18}$/, MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/, MR: /^(MR[0-9]{2})\d{23}$/, MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/, MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/, MZ: /^(MZ[0-9]{2})\d{21}$/, NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/, NO: /^(NO[0-9]{2})\d{11}$/, PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/, PL: /^(PL[0-9]{2})\d{24}$/, PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/, PT: /^(PT[0-9]{2})\d{21}$/, QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/, RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/, RS: /^(RS[0-9]{2})\d{18}$/, SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/, SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/, SE: /^(SE[0-9]{2})\d{20}$/, SI: /^(SI[0-9]{2})\d{15}$/, SK: /^(SK[0-9]{2})\d{20}$/, SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/, SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/, TL: /^(TL[0-9]{2})\d{19}$/, TN: /^(TN[0-9]{2})\d{20}$/, TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/, UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/, VA: /^(VA[0-9]{2})\d{18}$/, VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/, XK: /^(XK[0-9]{2})\d{16}$/ };
        var n = Object.keys(s);
        r.locales = n;
      }, { "./util/assertString": 99 }], 41: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, l.default)(e2);
          var r2 = u;
          (t2 = t2 || {}).allow_hyphens && (r2 = d);
          if (!r2.test(e2))
            return false;
          e2 = e2.replace(/-/g, "");
          for (var i2 = 0, n = 2, a = 0; a < 14; a++) {
            var o = e2.substring(14 - a - 1, 14 - a), s = parseInt(o, 10) * n;
            i2 += 10 <= s ? s % 10 + 1 : s, 1 === n ? n += 1 : n -= 1;
          }
          return (10 - i2 % 10) % 10 === parseInt(e2.substring(14, 15), 10);
        };
        var i, l = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var u = /^[0-9]{15}$/, d = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 42: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function e2(t2) {
          var r2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "";
          (0, n.default)(t2);
          r2 = String(r2);
          if (!r2)
            return e2(t2, 4) || e2(t2, 6);
          if ("4" === r2) {
            if (!s.test(t2))
              return false;
            var i2 = t2.split(".").sort(function(e3, t3) {
              return e3 - t3;
            });
            return i2[3] <= 255;
          }
          if ("6" === r2)
            return !!u.test(t2);
          return false;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])", o = "(".concat(a, "[.]){3}").concat(a), s = new RegExp("^".concat(o, "$")), l = "(?:[0-9a-fA-F]{1,4})", u = new RegExp("^(" + "(?:".concat(l, ":){7}(?:").concat(l, "|:)|") + "(?:".concat(l, ":){6}(?:").concat(o, "|:").concat(l, "|:)|") + "(?:".concat(l, ":){5}(?::").concat(o, "|(:").concat(l, "){1,2}|:)|") + "(?:".concat(l, ":){4}(?:(:").concat(l, "){0,1}:").concat(o, "|(:").concat(l, "){1,3}|:)|") + "(?:".concat(l, ":){3}(?:(:").concat(l, "){0,2}:").concat(o, "|(:").concat(l, "){1,4}|:)|") + "(?:".concat(l, ":){2}(?:(:").concat(l, "){0,3}:").concat(o, "|(:").concat(l, "){1,5}|:)|") + "(?:".concat(l, ":){1}(?:(:").concat(l, "){0,4}:").concat(o, "|(:").concat(l, "){1,6}|:)|") + "(?::((?::".concat(l, "){0,5}:").concat(o, "|(?::").concat(l, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 43: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "";
          (0, n.default)(e2);
          var r2 = e2.split("/");
          if (2 !== r2.length)
            return false;
          if (!o.test(r2[1]))
            return false;
          if (1 < r2[1].length && r2[1].startsWith("0"))
            return false;
          if (!(0, a.default)(r2[0], t2))
            return false;
          var i2 = null;
          switch (String(t2)) {
            case "4":
              i2 = s;
              break;
            case "6":
              i2 = l;
              break;
            default:
              i2 = (0, a.default)(r2[0], "6") ? l : s;
          }
          return r2[1] <= i2 && 0 <= r2[1];
        };
        var n = i(e("./util/assertString")), a = i(e("./isIP"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = /^\d{1,3}$/, s = 32, l = 128;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isIP": 42, "./util/assertString": 99 }], 44: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function e2(t2) {
          var r2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "";
          (0, o.default)(t2);
          r2 = String(r2);
          if (!r2)
            return e2(t2, 10) || e2(t2, 13);
          var i2 = t2.replace(/[\s-]+/g, "");
          var n = 0;
          var a;
          if ("10" === r2) {
            if (!s.test(i2))
              return false;
            for (a = 0; a < 9; a++)
              n += (a + 1) * i2.charAt(a);
            if ("X" === i2.charAt(9) ? n += 100 : n += 10 * i2.charAt(9), n % 11 == 0)
              return !!i2;
          } else if ("13" === r2) {
            if (!l.test(i2))
              return false;
            for (a = 0; a < 12; a++)
              n += u[a % 2] * i2.charAt(a);
            if (i2.charAt(12) - (10 - n % 10) % 10 == 0)
              return !!i2;
          }
          return false;
        };
        var i, o = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var s = /^(?:[0-9]{9}X|[0-9]{10})$/, l = /^(?:[0-9]{13})$/, u = [1, 3];
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 45: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          if ((0, c.default)(e2), !p.test(e2))
            return false;
          for (var t2 = true, r2 = 0, i2 = e2.length - 2; 0 <= i2; i2--)
            if ("A" <= e2[i2] && e2[i2] <= "Z")
              for (var n = e2[i2].charCodeAt(0) - 55, a = n % 10, o = Math.trunc(n / 10), s = 0, l = [a, o]; s < l.length; s++) {
                var u = l[s];
                r2 += t2 ? 5 <= u ? 1 + 2 * (u - 5) : 2 * u : u, t2 = !t2;
              }
            else {
              var d = e2[i2].charCodeAt(0) - "0".charCodeAt(0);
              r2 += t2 ? 5 <= d ? 1 + 2 * (d - 5) : 2 * d : d, t2 = !t2;
            }
          var f = 10 * Math.trunc((r2 + 9) / 10) - r2;
          return +e2[e2.length - 1] === f;
        };
        var i, c = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var p = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 46: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.has(e2.toUpperCase());
        }, r.CountryCodes = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /* @__PURE__ */ new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
        var o = a;
        r.CountryCodes = o;
      }, { "./util/assertString": 99 }], 47: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.has(e2.toUpperCase());
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /* @__PURE__ */ new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 48: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.has(e2.toUpperCase());
        }, r.CurrencyCodes = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /* @__PURE__ */ new Set(["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"]);
        var o = a;
        r.CurrencyCodes = o;
      }, { "./util/assertString": 99 }], 49: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
          (0, n.default)(e2);
          var r2 = t2.strictSeparator ? o.test(e2) : a.test(e2);
          return r2 && t2.strict ? s(e2) : r2;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/, o = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/, s = function(e2) {
          var t2 = e2.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
          if (t2) {
            var r2 = Number(t2[1]), i2 = Number(t2[2]);
            return r2 % 4 == 0 && r2 % 100 != 0 || r2 % 400 == 0 ? i2 <= 366 : i2 <= 365;
          }
          var n2 = e2.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number), a2 = n2[1], o2 = n2[2], s2 = n2[3], l = o2 ? "0".concat(o2).slice(-2) : o2, u = s2 ? "0".concat(s2).slice(-2) : s2, d = new Date("".concat(a2, "-").concat(l || "01", "-").concat(u || "01"));
          return !o2 || !s2 || d.getUTCFullYear() === a2 && d.getUTCMonth() + 1 === o2 && d.getUTCDate() === s2;
        };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 50: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 51: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
          (0, s.default)(e2);
          var r2 = l;
          if (r2 = t2.require_hyphen ? r2.replace("?", "") : r2, !(r2 = t2.case_sensitive ? new RegExp(r2) : new RegExp(r2, "i")).test(e2))
            return false;
          for (var i2 = e2.replace("-", "").toUpperCase(), n = 0, a = 0; a < i2.length; a++) {
            var o = i2[a];
            n += ("X" === o ? 10 : +o) * (8 - a);
          }
          return n % 11 == 0;
        };
        var i, s = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var l = "^\\d{4}-?\\d{3}[\\dX]$";
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 52: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          {
            if ((0, n.default)(e2), t2 in o)
              return o[t2](e2);
            if ("any" === t2) {
              for (var r2 in o)
                if (o.hasOwnProperty(r2)) {
                  var i2 = o[r2];
                  if (i2(e2))
                    return true;
                }
              return false;
            }
          }
          throw new Error("Invalid locale '".concat(t2, "'"));
        };
        var n = i(e("./util/assertString")), a = i(e("./isInt"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = { PL: function(e2) {
          (0, n.default)(e2);
          var i2 = { 1: 1, 2: 3, 3: 7, 4: 9, 5: 1, 6: 3, 7: 7, 8: 9, 9: 1, 10: 3, 11: 0 };
          if (null != e2 && 11 === e2.length && (0, a.default)(e2, { allow_leading_zeroes: true })) {
            var t2 = e2.split("").slice(0, -1).reduce(function(e3, t3, r3) {
              return e3 + Number(t3) * i2[r3 + 1];
            }, 0) % 10, r2 = Number(e2.charAt(e2.length - 1));
            if (0 === t2 && 0 === r2 || r2 === 10 - t2)
              return true;
          }
          return false;
        }, ES: function(e2) {
          (0, n.default)(e2);
          var t2 = { X: 0, Y: 1, Z: 2 }, r2 = e2.trim().toUpperCase();
          if (!/^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/.test(r2))
            return false;
          var i2 = r2.slice(0, -1).replace(/[X,Y,Z]/g, function(e3) {
            return t2[e3];
          });
          return r2.endsWith(["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"][i2 % 23]);
        }, FI: function(e2) {
          if ((0, n.default)(e2), 11 !== e2.length)
            return false;
          if (!e2.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/))
            return false;
          return "0123456789ABCDEFHJKLMNPRSTUVWXY"[(1e3 * parseInt(e2.slice(0, 6), 10) + parseInt(e2.slice(7, 10), 10)) % 31] === e2.slice(10, 11);
        }, IN: function(e2) {
          var r2 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]], i2 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]], t2 = e2.trim();
          if (!/^[1-9]\d{3}\s?\d{4}\s?\d{4}$/.test(t2))
            return false;
          var n2 = 0;
          return t2.replace(/\s/g, "").split("").map(Number).reverse().forEach(function(e3, t3) {
            n2 = r2[n2][i2[t3 % 8][e3]];
          }), 0 === n2;
        }, IR: function(e2) {
          if (!e2.match(/^\d{10}$/))
            return false;
          if (e2 = "0000".concat(e2).substr(e2.length - 6), 0 === parseInt(e2.substr(3, 6), 10))
            return false;
          for (var t2 = parseInt(e2.substr(9, 1), 10), r2 = 0, i2 = 0; i2 < 9; i2++)
            r2 += parseInt(e2.substr(i2, 1), 10) * (10 - i2);
          return (r2 %= 11) < 2 && t2 === r2 || 2 <= r2 && t2 === 11 - r2;
        }, IT: function(e2) {
          return 9 === e2.length && ("CA00000AA" !== e2 && -1 < e2.search(/C[A-Z][0-9]{5}[A-Z]{2}/i));
        }, NO: function(e2) {
          var t2 = e2.trim();
          if (isNaN(Number(t2)))
            return false;
          if (11 !== t2.length)
            return false;
          if ("00000000000" === t2)
            return false;
          var r2 = t2.split("").map(Number), i2 = (11 - (3 * r2[0] + 7 * r2[1] + 6 * r2[2] + 1 * r2[3] + 8 * r2[4] + 9 * r2[5] + 4 * r2[6] + 5 * r2[7] + 2 * r2[8]) % 11) % 11, n2 = (11 - (5 * r2[0] + 4 * r2[1] + 3 * r2[2] + 2 * r2[3] + 7 * r2[4] + 6 * r2[5] + 5 * r2[6] + 4 * r2[7] + 3 * r2[8] + 2 * i2) % 11) % 11;
          return i2 === r2[9] && n2 === r2[10];
        }, TH: function(e2) {
          if (!e2.match(/^[1-8]\d{12}$/))
            return false;
          for (var t2 = 0, r2 = 0; r2 < 12; r2++)
            t2 += parseInt(e2[r2], 10) * (13 - r2);
          return e2[12] === ((11 - t2 % 11) % 10).toString();
        }, LK: function(e2) {
          return !(10 !== e2.length || !/^[1-9]\d{8}[vx]$/i.test(e2)) || !(12 !== e2.length || !/^[1-9]\d{11}$/i.test(e2));
        }, "he-IL": function(e2) {
          var t2 = e2.trim();
          if (!/^\d{9}$/.test(t2))
            return false;
          for (var r2, i2 = t2, n2 = 0, a2 = 0; a2 < i2.length; a2++)
            n2 += 9 < (r2 = Number(i2[a2]) * (a2 % 2 + 1)) ? r2 - 9 : r2;
          return n2 % 10 == 0;
        }, "ar-LY": function(e2) {
          var t2 = e2.trim();
          return !!/^(1|2)\d{11}$/.test(t2);
        }, "ar-TN": function(e2) {
          var t2 = e2.trim();
          return !!/^\d{8}$/.test(t2);
        }, "zh-CN": function(e2) {
          var t2, r2 = ["11", "12", "13", "14", "15", "21", "22", "23", "31", "32", "33", "34", "35", "36", "37", "41", "42", "43", "44", "45", "46", "50", "51", "52", "53", "54", "61", "62", "63", "64", "65", "71", "81", "82", "91"], n2 = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"], a2 = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"], o2 = function(e3) {
            return r2.includes(e3);
          }, s = function(e3) {
            var t3 = parseInt(e3.substring(0, 4), 10), r3 = parseInt(e3.substring(4, 6), 10), i2 = parseInt(e3.substring(6), 10), n3 = new Date(t3, r3 - 1, i2);
            return !(n3 > /* @__PURE__ */ new Date()) && (n3.getFullYear() === t3 && n3.getMonth() === r3 - 1 && n3.getDate() === i2);
          }, l = function(e3) {
            return function(e4) {
              for (var t3 = e4.substring(0, 17), r3 = 0, i2 = 0; i2 < 17; i2++)
                r3 += parseInt(t3.charAt(i2), 10) * parseInt(n2[i2], 10);
              return a2[r3 % 11];
            }(e3) === e3.charAt(17).toUpperCase();
          };
          return !!/^\d{15}|(\d{17}(\d|x|X))$/.test(t2 = e2) && (15 === t2.length ? function(e3) {
            var t3 = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(e3);
            if (!t3)
              return false;
            var r3 = e3.substring(0, 2);
            if (!(t3 = o2(r3)))
              return false;
            var i2 = "19".concat(e3.substring(6, 12));
            return !!(t3 = s(i2));
          }(t2) : function(e3) {
            var t3 = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(e3);
            if (!t3)
              return false;
            var r3 = e3.substring(0, 2);
            if (!(t3 = o2(r3)))
              return false;
            var i2 = e3.substring(6, 14);
            return !!(t3 = s(i2)) && l(e3);
          }(t2));
        }, "zh-TW": function(e2) {
          var n2 = { A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, G: 16, H: 17, I: 34, J: 18, K: 19, L: 20, M: 21, N: 22, O: 35, P: 23, Q: 24, R: 25, S: 26, T: 27, U: 28, V: 29, W: 32, X: 30, Y: 31, Z: 33 }, t2 = e2.trim().toUpperCase();
          return !!/^[A-Z][0-9]{9}$/.test(t2) && Array.from(t2).reduce(function(e3, t3, r2) {
            if (0 !== r2)
              return 9 === r2 ? (10 - e3 % 10 - Number(t3)) % 10 == 0 : e3 + Number(t3) * (9 - r2);
            var i2 = n2[t3];
            return i2 % 10 * 9 + Math.floor(i2 / 10);
          }, 0);
        } };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isInt": 54, "./util/assertString": 99 }], 53: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          var r2;
          {
            if ((0, n.default)(e2), "[object Array]" === Object.prototype.toString.call(t2)) {
              var i2 = [];
              for (r2 in t2)
                ({}).hasOwnProperty.call(t2, r2) && (i2[r2] = (0, a.default)(t2[r2]));
              return 0 <= i2.indexOf(e2);
            }
            if ("object" === o(t2))
              return t2.hasOwnProperty(e2);
            if (t2 && "function" == typeof t2.indexOf)
              return 0 <= t2.indexOf(e2);
          }
          return false;
        };
        var n = i(e("./util/assertString")), a = i(e("./util/toString"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function o(e2) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/toString": 103 }], 54: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, s.default)(e2);
          var r2 = (t2 = t2 || {}).hasOwnProperty("allow_leading_zeroes") && !t2.allow_leading_zeroes ? l : u, i2 = !t2.hasOwnProperty("min") || e2 >= t2.min, n = !t2.hasOwnProperty("max") || e2 <= t2.max, a = !t2.hasOwnProperty("lt") || e2 < t2.lt, o = !t2.hasOwnProperty("gt") || e2 > t2.gt;
          return r2.test(e2) && i2 && n && a && o;
        };
        var i, s = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var l = /^(?:[-+]?(?:0|[1-9][0-9]*))$/, u = /^[-+]?[0-9]+$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 55: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2);
          try {
            t2 = (0, a.default)(t2, s);
            var r2 = [];
            t2.allow_primitives && (r2 = [null, false, true]);
            var i2 = JSON.parse(e2);
            return r2.includes(i2) || !!i2 && "object" === o(i2);
          } catch (e3) {
          }
          return false;
        };
        var n = i(e("./util/assertString")), a = i(e("./util/merge"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function o(e2) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        var s = { allow_primitives: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 56: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          (0, i.default)(e2);
          var t2 = e2.split("."), r2 = t2.length;
          if (3 < r2 || r2 < 2)
            return false;
          return t2.reduce(function(e3, t3) {
            return e3 && (0, n.default)(t3, { urlSafe: true });
          }, true);
        };
        var i = a(e("./util/assertString")), n = a(e("./isBase64"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isBase64": 17, "./util/assertString": 99 }], 57: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, i.default)(e2), t2 = (0, n.default)(t2, d), !e2.includes(","))
            return false;
          var r2 = e2.split(",");
          if (r2[0].startsWith("(") && !r2[1].endsWith(")") || r2[1].endsWith(")") && !r2[0].startsWith("("))
            return false;
          if (t2.checkDMS)
            return l.test(r2[0]) && u.test(r2[1]);
          return o.test(r2[0]) && s.test(r2[1]);
        };
        var i = a(e("./util/assertString")), n = a(e("./util/merge"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/, s = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/, l = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i, u = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i, d = { checkDMS: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 58: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          var r2, i2;
          (0, o.default)(e2), i2 = "object" === s(t2) ? (r2 = t2.min || 0, t2.max) : (r2 = arguments[1] || 0, arguments[2]);
          var n = e2.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [], a = e2.length - n.length;
          return r2 <= a && (void 0 === i2 || a <= i2);
        };
        var i, o = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        function s(e2) {
          return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 59: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          {
            if ((0, n.default)(e2), t2 in a)
              return a[t2](e2);
            if ("any" === t2) {
              for (var r2 in a) {
                var i2 = a[r2];
                if (i2(e2))
                  return true;
              }
              return false;
            }
          }
          throw new Error("Invalid locale '".concat(t2, "'"));
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { "cs-CZ": function(e2) {
          return /^(([ABCDEFHKIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(e2);
        }, "de-DE": function(e2) {
          return /^((AW|UL|AK|GA|AÖ|LF|AZ|AM|AS|ZE|AN|AB|A|KG|KH|BA|EW|BZ|HY|KM|BT|HP|B|BC|BI|BO|FN|TT|ÜB|BN|AH|BS|FR|HB|ZZ|BB|BK|BÖ|OC|OK|CW|CE|C|CO|LH|CB|KW|LC|LN|DA|DI|DE|DH|SY|NÖ|DO|DD|DU|DN|D|EI|EA|EE|FI|EM|EL|EN|PF|ED|EF|ER|AU|ZP|E|ES|NT|EU|FL|FO|FT|FF|F|FS|FD|FÜ|GE|G|GI|GF|GS|ZR|GG|GP|GR|NY|ZI|GÖ|GZ|GT|HA|HH|HM|HU|WL|HZ|WR|RN|HK|HD|HN|HS|GK|HE|HF|RZ|HI|HG|HO|HX|IK|IL|IN|J|JL|KL|KA|KS|KF|KE|KI|KT|KO|KN|KR|KC|KU|K|LD|LL|LA|L|OP|LM|LI|LB|LU|LÖ|HL|LG|MD|GN|MZ|MA|ML|MR|MY|AT|DM|MC|NZ|RM|RG|MM|ME|MB|MI|FG|DL|HC|MW|RL|MK|MG|MÜ|WS|MH|M|MS|NU|NB|ND|NM|NK|NW|NR|NI|NF|DZ|EB|OZ|TG|TO|N|OA|GM|OB|CA|EH|FW|OF|OL|OE|OG|BH|LR|OS|AA|GD|OH|KY|NP|WK|PB|PA|PE|PI|PS|P|PM|PR|RA|RV|RE|R|H|SB|WN|RS|RD|RT|BM|NE|GV|RP|SU|GL|RO|GÜ|RH|EG|RW|PN|SK|MQ|RU|SZ|RI|SL|SM|SC|HR|FZ|VS|SW|SN|CR|SE|SI|SO|LP|SG|NH|SP|IZ|ST|BF|TE|HV|OD|SR|S|AC|DW|ZW|TF|TS|TR|TÜ|UM|PZ|TP|UE|UN|UH|MN|KK|VB|V|AE|PL|RC|VG|GW|PW|VR|VK|KB|WA|WT|BE|WM|WE|AP|MO|WW|FB|WZ|WI|WB|JE|WF|WO|W|WÜ|BL|Z|GC)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(AIC|FDB|ABG|SLN|SAW|KLZ|BUL|ESB|NAB|SUL|WST|ABI|AZE|BTF|KÖT|DKB|FEU|ROT|ALZ|SMÜ|WER|AUR|NOR|DÜW|BRK|HAB|TÖL|WOR|BAD|BAR|BER|BIW|EBS|KEM|MÜB|PEG|BGL|BGD|REI|WIL|BKS|BIR|WAT|BOR|BOH|BOT|BRB|BLK|HHM|NEB|NMB|WSF|LEO|HDL|WMS|WZL|BÜS|CHA|KÖZ|ROD|WÜM|CLP|NEC|COC|ZEL|COE|CUX|DAH|LDS|DEG|DEL|RSL|DLG|DGF|LAN|HEI|MED|DON|KIB|ROK|JÜL|MON|SLE|EBE|EIC|HIG|WBS|BIT|PRÜ|LIB|EMD|WIT|ERH|HÖS|ERZ|ANA|ASZ|MAB|MEK|STL|SZB|FDS|HCH|HOR|WOL|FRG|GRA|WOS|FRI|FFB|GAP|GER|BRL|CLZ|GTH|NOH|HGW|GRZ|LÖB|NOL|WSW|DUD|HMÜ|OHA|KRU|HAL|HAM|HBS|QLB|HVL|NAU|HAS|EBN|GEO|HOH|HDH|ERK|HER|WAN|HEF|ROF|HBN|ALF|HSK|USI|NAI|REH|SAN|KÜN|ÖHR|HOL|WAR|ARN|BRG|GNT|HOG|WOH|KEH|MAI|PAR|RID|ROL|KLE|GEL|KUS|KYF|ART|SDH|LDK|DIL|MAL|VIB|LER|BNA|GHA|GRM|MTL|WUR|LEV|LIF|STE|WEL|LIP|VAI|LUP|HGN|LBZ|LWL|PCH|STB|DAN|MKK|SLÜ|MSP|TBB|MGH|MTK|BIN|MSH|EIL|HET|SGH|BID|MYK|MSE|MST|MÜR|WRN|MEI|GRH|RIE|MZG|MIL|OBB|BED|FLÖ|MOL|FRW|SEE|SRB|AIB|MOS|BCH|ILL|SOB|NMS|NEA|SEF|UFF|NEW|VOH|NDH|TDO|NWM|GDB|GVM|WIS|NOM|EIN|GAN|LAU|HEB|OHV|OSL|SFB|ERB|LOS|BSK|KEL|BSB|MEL|WTL|OAL|FÜS|MOD|OHZ|OPR|BÜR|PAF|PLÖ|CAS|GLA|REG|VIT|ECK|SIM|GOA|EMS|DIZ|GOH|RÜD|SWA|NES|KÖN|MET|LRO|BÜZ|DBR|ROS|TET|HRO|ROW|BRV|HIP|PAN|GRI|SHK|EIS|SRO|SOK|LBS|SCZ|MER|QFT|SLF|SLS|HOM|SLK|ASL|BBG|SBK|SFT|SHG|MGN|MEG|ZIG|SAD|NEN|OVI|SHA|BLB|SIG|SON|SPN|FOR|GUB|SPB|IGB|WND|STD|STA|SDL|OBG|HST|BOG|SHL|PIR|FTL|SEB|SÖM|SÜW|TIR|SAB|TUT|ANG|SDT|LÜN|LSZ|MHL|VEC|VER|VIE|OVL|ANK|OVP|SBG|UEM|UER|WLG|GMN|NVP|RDG|RÜG|DAU|FKB|WAF|WAK|SLZ|WEN|SOG|APD|WUG|GUN|ESW|WIZ|WES|DIN|BRA|BÜD|WHV|HWI|GHC|WTM|WOB|WUN|MAK|SEL|OCH|HOT|WDA)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(e2);
        }, "de-LI": function(e2) {
          return /^FL[- ]?\d{1,5}[UZ]?$/.test(e2);
        }, "fi-FI": function(e2) {
          return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(e2);
        }, "pt-PT": function(e2) {
          return /^([A-Z]{2}|[0-9]{2})[ -·]?([A-Z]{2}|[0-9]{2})[ -·]?([A-Z]{2}|[0-9]{2})$/.test(e2);
        }, "sq-AL": function(e2) {
          return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(e2);
        }, "pt-BR": function(e2) {
          return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(e2);
        } };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 60: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), "en_US_POSIX" === e2 || "ca_ES_VALENCIA" === e2 || a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[A-Za-z]{2,4}([_-]([A-Za-z]{4}|[\d]{3}))?([_-]([A-Za-z]{2}|[\d]{3}))?$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 61: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), e2 === e2.toLowerCase();
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 62: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), t2 && (t2.no_colons || t2.no_separators))
            return o.test(e2);
          return a.test(e2) || s.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/, o = /^([0-9a-fA-F]){12}$/, s = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 63: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[a-f0-9]{32}$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 64: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2.trim());
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^magnet:\?xt(?:\.1)?=urn:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?($|&)/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 65: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2) || o.test(e2) || s.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+]{1,100}$/i, o = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i, s = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 66: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(r2, e2, t2) {
          if ((0, a.default)(r2), t2 && t2.strictMode && !r2.startsWith("+"))
            return false;
          {
            if (Array.isArray(e2))
              return e2.some(function(e3) {
                if (o.hasOwnProperty(e3)) {
                  var t3 = o[e3];
                  if (t3.test(r2))
                    return true;
                }
                return false;
              });
            if (e2 in o)
              return o[e2].test(r2);
            if (!e2 || "any" === e2) {
              for (var i2 in o)
                if (o.hasOwnProperty(i2)) {
                  var n2 = o[i2];
                  if (n2.test(r2))
                    return true;
                }
              return false;
            }
          }
          throw new Error("Invalid locale '".concat(e2, "'"));
        }, r.locales = void 0;
        var i, a = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var o = { "am-AM": /^(\+?374|0)((10|[9|7][0-9])\d{6}$|[2-4]\d{7}$)/, "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/, "ar-BH": /^(\+?973)?(3|6)\d{7}$/, "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/, "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/, "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/, "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/, "ar-JO": /^(\+?962|0)?7[789]\d{7}$/, "ar-KW": /^(\+?965)[569]\d{7}$/, "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/, "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/, "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/, "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/, "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/, "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/, "ar-TN": /^(\+?216)?[2459]\d{7}$/, "az-AZ": /^(\+994|0)(5[015]|7[07]|99)\d{7}$/, "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/, "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/, "bg-BG": /^(\+?359|0)?8[789]\d{7}$/, "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/, "ca-AD": /^(\+376)?[346]\d{5}$/, "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/, "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/, "de-DE": /^((\+49|0)[1|3])([0|5][0-45-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/, "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/, "de-CH": /^(\+41|0)([1-9])\d{1,9}$/, "de-LU": /^(\+352)?((6\d1)\d{6})$/, "dv-MV": /^(\+?960)?(7[2-9]|91|9[3-9])\d{7}$/, "el-GR": /^(\+?30|0)?(69\d{8})$/, "en-AU": /^(\+?61|0)4\d{8}$/, "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}))/, "en-GB": /^(\+?44|0)7\d{9}$/, "en-GG": /^(\+?44|0)1481\d{6}$/, "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/, "en-GY": /^(\+592|0)6\d{6}$/, "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/, "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/, "en-IE": /^(\+?353|0)8[356789]\d{7}$/, "en-IN": /^(\+?91|0)?[6789]\d{9}$/, "en-KE": /^(\+?254|0)(7|1)\d{8}$/, "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/, "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/, "en-MU": /^(\+?230|0)?\d{8}$/, "en-NA": /^(\+?264|0)(6|8)\d{7}$/, "en-NG": /^(\+?234|0)?[789]\d{9}$/, "en-NZ": /^(\+?64|0)[28]\d{7,9}$/, "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/, "en-PH": /^(09|\+639)\d{9}$/, "en-RW": /^(\+?250|0)?[7]\d{8}$/, "en-SG": /^(\+65)?[3689]\d{7}$/, "en-SL": /^(\+?232|0)\d{8}$/, "en-TZ": /^(\+?255|0)?[67]\d{8}$/, "en-UG": /^(\+?256|0)?[7]\d{8}$/, "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/, "en-ZA": /^(\+?27|0)\d{9}$/, "en-ZM": /^(\+?26)?09[567]\d{7}$/, "en-ZW": /^(\+263)[0-9]{9}$/, "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/, "es-AR": /^\+?549(11|[2368]\d)\d{8}$/, "es-BO": /^(\+?591)?(6|7)\d{7}$/, "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/, "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/, "es-CR": /^(\+506)?[2-8]\d{7}$/, "es-CU": /^(\+53|0053)?5\d{7}/, "es-DO": /^(\+?1)?8[024]9\d{7}$/, "es-HN": /^(\+?504)?[9|8]\d{7}$/, "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/, "es-ES": /^(\+?34)?[6|7]\d{8}$/, "es-PE": /^(\+?51)?9\d{8}$/, "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/, "es-PA": /^(\+?507)\d{7,8}$/, "es-PY": /^(\+?595|0)9[9876]\d{7}$/, "es-SV": /^(\+?503)?[67]\d{7}$/, "es-UY": /^(\+598|0)9[1-9][\d]{6}$/, "es-VE": /^(\+?58)?(2|4)\d{9}$/, "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/, "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/, "fi-FI": /^(\+?358|0)\s?(4(0|1|2|4|5|6)?|50)\s?(\d\s?){4,8}\d$/, "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/, "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/, "fr-BF": /^(\+226|0)[67]\d{7}$/, "fr-CM": /^(\+?237)6[0-9]{8}$/, "fr-FR": /^(\+?33|0)[67]\d{8}$/, "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/, "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/, "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/, "fr-PF": /^(\+?689)?8[789]\d{6}$/, "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/, "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/, "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/, "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/, "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/, "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/, "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/, "ka-GE": /^(\+?995)?(5|79)\d{7}$/, "kk-KZ": /^(\+?7|8)?7\d{9}$/, "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/, "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/, "lt-LT": /^(\+370|8)\d{8}$/, "lv-LV": /^(\+?371)2\d{7}$/, "ms-MY": /^(\+?6?01){1}(([0145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/, "mz-MZ": /^(\+?258)?8[234567]\d{7}$/, "nb-NO": /^(\+?47)?[49]\d{7}$/, "ne-NP": /^(\+?977)?9[78]\d{8}$/, "nl-BE": /^(\+?32|0)4\d{8}$/, "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/, "nn-NO": /^(\+?47)?[49]\d{7}$/, "pl-PL": /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/, "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[2-9]{1}\d{3}\-?\d{4}))$/, "pt-PT": /^(\+?351)?9[1236]\d{7}$/, "pt-AO": /^(\+244)\d{9}$/, "ro-RO": /^(\+?4?0)\s?7\d{2}(\/|\s|\.|\-)?\d{3}(\s|\.|\-)?\d{3}$/, "ru-RU": /^(\+?7|8)?9\d{9}$/, "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/, "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/, "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/, "sq-AL": /^(\+355|0)6[789]\d{6}$/, "sr-RS": /^(\+3816|06)[- \d]{5,9}$/, "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/, "tg-TJ": /^(\+?992)?[5][5]\d{7}$/, "th-TH": /^(\+66|66|0)\d{9}$/, "tr-TR": /^(\+?90|0)?5\d{9}$/, "tk-TM": /^(\+993|993|8)\d{8}$/, "uk-UA": /^(\+?38|8)?0\d{9}$/, "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/, "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/, "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/, "zh-TW": /^(\+?886\-?|0)?9\d{8}$/, "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/ };
        o["en-CA"] = o["en-US"], o["fr-CA"] = o["en-CA"], o["fr-BE"] = o["nl-BE"], o["zh-HK"] = o["en-HK"], o["zh-MO"] = o["en-MO"], o["ga-IE"] = o["en-IE"], o["fr-CH"] = o["de-CH"], o["it-CH"] = o["fr-CH"];
        var n = Object.keys(o);
        r.locales = n;
      }, { "./util/assertString": 99 }], 67: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, i.default)(e2), (0, n.default)(e2) && 24 === e2.length;
        };
        var i = a(e("./util/assertString")), n = a(e("./isHexadecimal"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isHexadecimal": 39, "./util/assertString": 99 }], 68: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /[^\x00-\x7F]/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 69: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), t2 && t2.no_symbols)
            return o.test(e2);
          return new RegExp("^[+-]?([0-9]*[".concat((t2 || {}).locale ? a.decimal[t2.locale] : ".", "])?[0-9]+$")).test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, a = e("./alpha");
        var o = /^[0-9]+$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./alpha": 5, "./util/assertString": 99 }], 70: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(0o)?[0-7]+$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 71: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2);
          var r2 = e2.replace(/\s/g, "").toUpperCase();
          return t2.toUpperCase() in a && a[t2].test(r2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { AM: /^[A-Z]{2}\d{7}$/, AR: /^[A-Z]{3}\d{6}$/, AT: /^[A-Z]\d{7}$/, AU: /^[A-Z]\d{7}$/, BE: /^[A-Z]{2}\d{6}$/, BG: /^\d{9}$/, BR: /^[A-Z]{2}\d{6}$/, BY: /^[A-Z]{2}\d{7}$/, CA: /^[A-Z]{2}\d{6}$/, CH: /^[A-Z]\d{7}$/, CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/, CY: /^[A-Z](\d{6}|\d{8})$/, CZ: /^\d{8}$/, DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/, DK: /^\d{9}$/, DZ: /^\d{9}$/, EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/, ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/, FI: /^[A-Z]{2}\d{7}$/, FR: /^\d{2}[A-Z]{2}\d{5}$/, GB: /^\d{9}$/, GR: /^[A-Z]{2}\d{7}$/, HR: /^\d{9}$/, HU: /^[A-Z]{2}(\d{6}|\d{7})$/, IE: /^[A-Z0-9]{2}\d{7}$/, IN: /^[A-Z]{1}-?\d{7}$/, ID: /^[A-C]\d{7}$/, IR: /^[A-Z]\d{8}$/, IS: /^(A)\d{7}$/, IT: /^[A-Z0-9]{2}\d{7}$/, JP: /^[A-Z]{2}\d{7}$/, KR: /^[MS]\d{8}$/, LT: /^[A-Z0-9]{8}$/, LU: /^[A-Z0-9]{8}$/, LV: /^[A-Z0-9]{2}\d{7}$/, LY: /^[A-Z0-9]{8}$/, MT: /^\d{7}$/, MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/, MY: /^[AHK]\d{8}$/, NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/, PL: /^[A-Z]{2}\d{7}$/, PT: /^[A-Z]\d{6}$/, RO: /^\d{8,9}$/, RU: /^\d{9}$/, SE: /^\d{8}$/, SL: /^(P)[A-Z]\d{7}$/, SK: /^[0-9A-Z]\d{7}$/, TR: /^[A-Z]\d{8}$/, UA: /^[A-Z]{2}\d{6}$/, US: /^\d{9}$/ };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 72: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2, { min: 0, max: 65535 });
        };
        var i, n = (i = e("./isInt")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isInt": 54 }], 73: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          {
            if ((0, n.default)(e2), t2 in l)
              return l[t2].test(e2);
            if ("any" === t2) {
              for (var r2 in l)
                if (l.hasOwnProperty(r2)) {
                  var i2 = l[r2];
                  if (i2.test(e2))
                    return true;
                }
              return false;
            }
          }
          throw new Error("Invalid locale '".concat(t2, "'"));
        }, r.locales = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^\d{4}$/, o = /^\d{5}$/, s = /^\d{6}$/, l = { AD: /^AD\d{3}$/, AT: a, AU: a, AZ: /^AZ\d{4}$/, BE: a, BG: a, BR: /^\d{5}-\d{3}$/, BY: /2[1-4]{1}\d{4}$/, CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i, CH: a, CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/, CZ: /^\d{3}\s?\d{2}$/, DE: o, DK: a, DO: o, DZ: o, EE: o, ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/, FI: o, FR: /^\d{2}\s?\d{3}$/, GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i, GR: /^\d{3}\s?\d{2}$/, HR: /^([1-5]\d{4}$)/, HT: /^HT\d{4}$/, HU: a, ID: o, IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i, IL: /^(\d{5}|\d{7})$/, IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/, IR: /\b(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}\b/, IS: /^\d{3}$/, IT: o, JP: /^\d{3}\-\d{4}$/, KE: o, KR: /^(\d{5}|\d{6})$/, LI: /^(948[5-9]|949[0-7])$/, LT: /^LT\-\d{5}$/, LU: a, LV: /^LV\-\d{4}$/, LK: o, MX: o, MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/, MY: o, NL: /^\d{4}\s?[a-z]{2}$/i, NO: a, NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i, NZ: a, PL: /^\d{2}\-\d{3}$/, PR: /^00[679]\d{2}([ -]\d{4})?$/, PT: /^\d{4}\-\d{3}?$/, RO: s, RU: s, SA: o, SE: /^[1-9]\d{2}\s?\d{2}$/, SG: s, SI: a, SK: /^\d{3}\s?\d{2}$/, TH: o, TN: a, TW: /^\d{3}(\d{2})?$/, UA: o, US: /^\d{5}(-\d{4})?$/, ZA: a, ZM: o }, u = Object.keys(l);
        r.locales = u;
      }, { "./util/assertString": 99 }], 74: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), c.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /([01][0-9]|2[0-3])/, o = /[0-5][0-9]/, s = new RegExp("[-+]".concat(a.source, ":").concat(o.source)), l = new RegExp("([zZ]|".concat(s.source, ")")), u = new RegExp("".concat(a.source, ":").concat(o.source, ":").concat(/([0-5][0-9]|60)/.source).concat(/(\.[0-9]+)?/.source)), d = new RegExp("".concat(/[0-9]{4}/.source, "-").concat(/(0[1-9]|1[0-2])/.source, "-").concat(/([12]\d|0[1-9]|3[01])/.source)), f = new RegExp("".concat(u.source).concat(l.source)), c = new RegExp("^".concat(d.source, "[ tT]").concat(f.source, "$"));
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 75: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1];
          return (0, n.default)(e2), t2 ? a.test(e2) || o.test(e2) || s.test(e2) || l.test(e2) : a.test(e2) || o.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/, o = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/, s = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)/, l = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 76: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, i.default)(e2), a.test(e2);
        };
        var i = n(e("./util/assertString"));
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var a = (0, n(e("./util/multilineRegex")).default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/multilineRegex": 102 }], 77: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 78: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null;
          (0, u.default)(e2);
          var r2 = (i2 = e2, o = i2, s = {}, Array.from(o).forEach(function(e3) {
            s[e3] ? s[e3] += 1 : s[e3] = 1;
          }), n = s, a = { length: i2.length, uniqueChars: Object.keys(n).length, uppercaseCount: 0, lowercaseCount: 0, numberCount: 0, symbolCount: 0 }, Object.keys(n).forEach(function(e3) {
            d.test(e3) ? a.uppercaseCount += n[e3] : f.test(e3) ? a.lowercaseCount += n[e3] : c.test(e3) ? a.numberCount += n[e3] : p.test(e3) && (a.symbolCount += n[e3]);
          }), a);
          var i2, n, a, o, s;
          if ((t2 = (0, l.default)(t2 || {}, h)).returnScore)
            return function(e3, t3) {
              var r3 = 0;
              r3 += e3.uniqueChars * t3.pointsPerUnique, r3 += (e3.length - e3.uniqueChars) * t3.pointsPerRepeat, 0 < e3.lowercaseCount && (r3 += t3.pointsForContainingLower);
              0 < e3.uppercaseCount && (r3 += t3.pointsForContainingUpper);
              0 < e3.numberCount && (r3 += t3.pointsForContainingNumber);
              0 < e3.symbolCount && (r3 += t3.pointsForContainingSymbol);
              return r3;
            }(r2, t2);
          return r2.length >= t2.minLength && r2.lowercaseCount >= t2.minLowercase && r2.uppercaseCount >= t2.minUppercase && r2.numberCount >= t2.minNumbers && r2.symbolCount >= t2.minSymbols;
        };
        var l = i(e("./util/merge")), u = i(e("./util/assertString"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var d = /^[A-Z]$/, f = /^[a-z]$/, c = /^[0-9]$/, p = /^[-#!$@%^&*()_+|~=`{}\[\]:";'<>?,.\/ ]$/, h = { minLength: 8, minLowercase: 1, minUppercase: 1, minNumbers: 1, minSymbols: 1, returnScore: false, pointsPerUnique: 1, pointsPerRepeat: 0.5, pointsForContainingLower: 10, pointsForContainingUpper: 10, pointsForContainingNumber: 10, pointsForContainingSymbol: 10 };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 79: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 80: [function(e, t, r) {
        "use strict";
        function o(e2) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "en-US";
          (0, i.default)(e2);
          var r2 = e2.slice(0);
          if (t2 in f)
            return t2 in h && (r2 = r2.replace(h[t2], "")), !!f[t2].test(r2) && (!(t2 in c) || c[t2](r2));
          throw new Error("Invalid locale '".concat(t2, "'"));
        };
        var i = n(e("./util/assertString")), l = function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          if (null === e2 || "object" !== o(e2) && "function" != typeof e2)
            return { default: e2 };
          var t2 = s();
          if (t2 && t2.has(e2))
            return t2.get(e2);
          var r2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var n2 in e2)
            if (Object.prototype.hasOwnProperty.call(e2, n2)) {
              var a2 = i2 ? Object.getOwnPropertyDescriptor(e2, n2) : null;
              a2 && (a2.get || a2.set) ? Object.defineProperty(r2, n2, a2) : r2[n2] = e2[n2];
            }
          r2.default = e2, t2 && t2.set(e2, r2);
          return r2;
        }(e("./util/algorithms")), v = n(e("./isDate"));
        function s() {
          if ("function" != typeof WeakMap)
            return null;
          var e2 = /* @__PURE__ */ new WeakMap();
          return s = function() {
            return e2;
          }, e2;
        }
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function a(e2) {
          return function(e3) {
            if (Array.isArray(e3))
              return u(e3);
          }(e2) || function(e3) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3))
              return Array.from(e3);
          }(e2) || function(e3, t2) {
            if (!e3)
              return;
            if ("string" == typeof e3)
              return u(e3, t2);
            var r2 = Object.prototype.toString.call(e3).slice(8, -1);
            "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
            if ("Map" === r2 || "Set" === r2)
              return Array.from(e3);
            if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
              return u(e3, t2);
          }(e2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function u(e2, t2) {
          (null == t2 || t2 > e2.length) && (t2 = e2.length);
          for (var r2 = 0, i2 = new Array(t2); r2 < t2; r2++)
            i2[r2] = e2[r2];
          return i2;
        }
        var d = { andover: ["10", "12"], atlanta: ["60", "67"], austin: ["50", "53"], brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"], cincinnati: ["30", "32", "35", "36", "37", "38", "61"], fresno: ["15", "24"], internet: ["20", "26", "27", "45", "46", "47"], kansas: ["40", "44"], memphis: ["94", "95"], ogden: ["80", "90"], philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"], sba: ["31"] };
        function _2(e2) {
          for (var t2 = false, r2 = false, i2 = 0; i2 < 3; i2++)
            if (!t2 && /[AEIOU]/.test(e2[i2]))
              t2 = true;
            else if (!r2 && t2 && "X" === e2[i2])
              r2 = true;
            else if (0 < i2) {
              if (t2 && !r2 && !/[AEIOU]/.test(e2[i2]))
                return false;
              if (r2 && !/X/.test(e2[i2]))
                return false;
            }
          return true;
        }
        var f = { "bg-BG": /^\d{10}$/, "cs-CZ": /^\d{6}\/{0,1}\d{3,4}$/, "de-AT": /^\d{9}$/, "de-DE": /^[1-9]\d{10}$/, "dk-DK": /^\d{6}-{0,1}\d{4}$/, "el-CY": /^[09]\d{7}[A-Z]$/, "el-GR": /^([0-4]|[7-9])\d{8}$/, "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i, "en-IE": /^\d{7}[A-W][A-IW]{0,1}$/i, "en-US": /^\d{2}[- ]{0,1}\d{7}$/, "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i, "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/, "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i, "fr-BE": /^\d{11}$/, "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/, "fr-LU": /^\d{13}$/, "hr-HR": /^\d{11}$/, "hu-HU": /^8\d{9}$/, "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i, "lv-LV": /^\d{6}-{0,1}\d{5}$/, "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i, "nl-NL": /^\d{9}$/, "pl-PL": /^\d{10,11}$/, "pt-BR": /(?:^\d{11}$)|(?:^\d{14}$)/, "pt-PT": /^\d{9}$/, "ro-RO": /^\d{13}$/, "sk-SK": /^\d{6}\/{0,1}\d{3,4}$/, "sl-SI": /^[1-9]\d{7}$/, "sv-SE": /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/ };
        f["lb-LU"] = f["fr-LU"], f["lt-LT"] = f["et-EE"], f["nl-BE"] = f["fr-BE"];
        var c = { "bg-BG": function(e2) {
          var t2 = e2.slice(0, 2), r2 = parseInt(e2.slice(2, 4), 10);
          t2 = 40 < r2 ? (r2 -= 40, "20".concat(t2)) : 20 < r2 ? (r2 -= 20, "18".concat(t2)) : "19".concat(t2), r2 < 10 && (r2 = "0".concat(r2));
          var i2 = "".concat(t2, "/").concat(r2, "/").concat(e2.slice(4, 6));
          if (!(0, v.default)(i2, "YYYY/MM/DD"))
            return false;
          for (var n2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), a2 = [2, 4, 8, 5, 10, 9, 7, 3, 6], o2 = 0, s2 = 0; s2 < a2.length; s2++)
            o2 += n2[s2] * a2[s2];
          return (o2 = o2 % 11 == 10 ? 0 : o2 % 11) === n2[9];
        }, "cs-CZ": function(e2) {
          e2 = e2.replace(/\W/, "");
          var t2 = parseInt(e2.slice(0, 2), 10);
          if (10 === e2.length)
            t2 = t2 < 54 ? "20".concat(t2) : "19".concat(t2);
          else {
            if ("000" === e2.slice(6))
              return false;
            if (!(t2 < 54))
              return false;
            t2 = "19".concat(t2);
          }
          3 === t2.length && (t2 = [t2.slice(0, 2), "0", t2.slice(2)].join(""));
          var r2 = parseInt(e2.slice(2, 4), 10);
          if (50 < r2 && (r2 -= 50), 20 < r2) {
            if (parseInt(t2, 10) < 2004)
              return false;
            r2 -= 20;
          }
          r2 < 10 && (r2 = "0".concat(r2));
          var i2 = "".concat(t2, "/").concat(r2, "/").concat(e2.slice(4, 6));
          if (!(0, v.default)(i2, "YYYY/MM/DD"))
            return false;
          if (10 === e2.length && parseInt(e2, 10) % 11 != 0) {
            var n2 = parseInt(e2.slice(0, 9), 10) % 11;
            if (!(parseInt(t2, 10) < 1986 && 10 === n2))
              return false;
            if (0 !== parseInt(e2.slice(9), 10))
              return false;
          }
          return true;
        }, "de-AT": function(e2) {
          return l.luhnCheck(e2);
        }, "de-DE": function(e2) {
          for (var t2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), r2 = [], i2 = 0; i2 < t2.length - 1; i2++) {
            r2.push("");
            for (var n2 = 0; n2 < t2.length - 1; n2++)
              t2[i2] === t2[n2] && (r2[i2] += n2);
          }
          if (2 !== (r2 = r2.filter(function(e3) {
            return 1 < e3.length;
          })).length && 3 !== r2.length)
            return false;
          if (3 === r2[0].length) {
            for (var a2 = r2[0].split("").map(function(e3) {
              return parseInt(e3, 10);
            }), o2 = 0, s2 = 0; s2 < a2.length - 1; s2++)
              a2[s2] + 1 === a2[s2 + 1] && (o2 += 1);
            if (2 === o2)
              return false;
          }
          return l.iso7064Check(e2);
        }, "dk-DK": function(e2) {
          e2 = e2.replace(/\W/, "");
          var t2 = parseInt(e2.slice(4, 6), 10);
          switch (e2.slice(6, 7)) {
            case "0":
            case "1":
            case "2":
            case "3":
              t2 = "19".concat(t2);
              break;
            case "4":
            case "9":
              t2 = t2 < 37 ? "20".concat(t2) : "19".concat(t2);
              break;
            default:
              if (t2 < 37)
                t2 = "20".concat(t2);
              else {
                if (!(58 < t2))
                  return false;
                t2 = "18".concat(t2);
              }
          }
          3 === t2.length && (t2 = [t2.slice(0, 2), "0", t2.slice(2)].join(""));
          var r2 = "".concat(t2, "/").concat(e2.slice(2, 4), "/").concat(e2.slice(0, 2));
          if (!(0, v.default)(r2, "YYYY/MM/DD"))
            return false;
          for (var i2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), n2 = 0, a2 = 4, o2 = 0; o2 < 9; o2++)
            n2 += i2[o2] * a2, 1 == (a2 -= 1) && (a2 = 7);
          return 1 != (n2 %= 11) && (0 === n2 ? 0 === i2[9] : i2[9] === 11 - n2);
        }, "el-CY": function(e2) {
          for (var t2 = e2.slice(0, 8).split("").map(function(e3) {
            return parseInt(e3, 10);
          }), r2 = 0, i2 = 1; i2 < t2.length; i2 += 2)
            r2 += t2[i2];
          for (var n2 = 0; n2 < t2.length; n2 += 2)
            t2[n2] < 2 ? r2 += 1 - t2[n2] : (r2 += 2 * (t2[n2] - 2) + 5, 4 < t2[n2] && (r2 += 2));
          return String.fromCharCode(r2 % 26 + 65) === e2.charAt(8);
        }, "el-GR": function(e2) {
          for (var t2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), r2 = 0, i2 = 0; i2 < 8; i2++)
            r2 += t2[i2] * Math.pow(2, 8 - i2);
          return r2 % 11 % 10 === t2[8];
        }, "en-IE": function(e2) {
          var t2 = l.reverseMultiplyAndSum(e2.split("").slice(0, 7).map(function(e3) {
            return parseInt(e3, 10);
          }), 8);
          return 9 === e2.length && "W" !== e2[8] && (t2 += 9 * (e2[8].charCodeAt(0) - 64)), 0 == (t2 %= 23) ? "W" === e2[7].toUpperCase() : e2[7].toUpperCase() === String.fromCharCode(64 + t2);
        }, "en-US": function(e2) {
          return -1 !== function() {
            var e3 = [];
            for (var t2 in d)
              d.hasOwnProperty(t2) && e3.push.apply(e3, a(d[t2]));
            return e3;
          }().indexOf(e2.substr(0, 2));
        }, "es-ES": function(e2) {
          var t2 = e2.toUpperCase().split("");
          if (isNaN(parseInt(t2[0], 10)) && 1 < t2.length) {
            var r2 = 0;
            switch (t2[0]) {
              case "Y":
                r2 = 1;
                break;
              case "Z":
                r2 = 2;
            }
            t2.splice(0, 1, r2);
          } else
            for (; t2.length < 9; )
              t2.unshift(0);
          t2 = t2.join("");
          var i2 = parseInt(t2.slice(0, 8), 10) % 23;
          return t2[8] === ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"][i2];
        }, "et-EE": function(e2) {
          var t2 = e2.slice(1, 3);
          switch (e2.slice(0, 1)) {
            case "1":
            case "2":
              t2 = "18".concat(t2);
              break;
            case "3":
            case "4":
              t2 = "19".concat(t2);
              break;
            default:
              t2 = "20".concat(t2);
          }
          var r2 = "".concat(t2, "/").concat(e2.slice(3, 5), "/").concat(e2.slice(5, 7));
          if (!(0, v.default)(r2, "YYYY/MM/DD"))
            return false;
          for (var i2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), n2 = 0, a2 = 1, o2 = 0; o2 < 10; o2++)
            n2 += i2[o2] * a2, 10 === (a2 += 1) && (a2 = 1);
          if (n2 % 11 == 10) {
            a2 = 3;
            for (var s2 = n2 = 0; s2 < 10; s2++)
              n2 += i2[s2] * a2, 10 === (a2 += 1) && (a2 = 1);
            if (n2 % 11 == 10)
              return 0 === i2[10];
          }
          return n2 % 11 === i2[10];
        }, "fi-FI": function(e2) {
          var t2 = e2.slice(4, 6);
          switch (e2.slice(6, 7)) {
            case "+":
              t2 = "18".concat(t2);
              break;
            case "-":
              t2 = "19".concat(t2);
              break;
            default:
              t2 = "20".concat(t2);
          }
          var r2 = "".concat(t2, "/").concat(e2.slice(2, 4), "/").concat(e2.slice(0, 2));
          if (!(0, v.default)(r2, "YYYY/MM/DD"))
            return false;
          var i2 = parseInt(e2.slice(0, 6) + e2.slice(7, 10), 10) % 31;
          return i2 < 10 ? i2 === parseInt(e2.slice(10), 10) : ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"][i2 -= 10] === e2.slice(10);
        }, "fr-BE": function(e2) {
          if ("00" !== e2.slice(2, 4) || "00" !== e2.slice(4, 6)) {
            var t2 = "".concat(e2.slice(0, 2), "/").concat(e2.slice(2, 4), "/").concat(e2.slice(4, 6));
            if (!(0, v.default)(t2, "YY/MM/DD"))
              return false;
          }
          var r2 = 97 - parseInt(e2.slice(0, 9), 10) % 97, i2 = parseInt(e2.slice(9, 11), 10);
          return r2 === i2 || (r2 = 97 - parseInt("2".concat(e2.slice(0, 9)), 10) % 97) === i2;
        }, "fr-FR": function(e2) {
          return e2 = e2.replace(/\s/g, ""), parseInt(e2.slice(0, 10), 10) % 511 === parseInt(e2.slice(10, 13), 10);
        }, "fr-LU": function(e2) {
          var t2 = "".concat(e2.slice(0, 4), "/").concat(e2.slice(4, 6), "/").concat(e2.slice(6, 8));
          return !!(0, v.default)(t2, "YYYY/MM/DD") && !!l.luhnCheck(e2.slice(0, 12)) && l.verhoeffCheck("".concat(e2.slice(0, 11)).concat(e2[12]));
        }, "hr-HR": function(e2) {
          return l.iso7064Check(e2);
        }, "hu-HU": function(e2) {
          for (var t2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), r2 = 8, i2 = 1; i2 < 9; i2++)
            r2 += t2[i2] * (i2 + 1);
          return r2 % 11 === t2[9];
        }, "it-IT": function(e2) {
          var t2 = e2.toUpperCase().split("");
          if (!_2(t2.slice(0, 3)))
            return false;
          if (!_2(t2.slice(3, 6)))
            return false;
          for (var r2 = { L: "0", M: "1", N: "2", P: "3", Q: "4", R: "5", S: "6", T: "7", U: "8", V: "9" }, i2 = 0, n2 = [6, 7, 9, 10, 12, 13, 14]; i2 < n2.length; i2++) {
            var a2 = n2[i2];
            t2[a2] in r2 && t2.splice(a2, 1, r2[t2[a2]]);
          }
          var o2 = { A: "01", B: "02", C: "03", D: "04", E: "05", H: "06", L: "07", M: "08", P: "09", R: "10", S: "11", T: "12" }[t2[8]], s2 = parseInt(t2[9] + t2[10], 10);
          40 < s2 && (s2 -= 40), s2 < 10 && (s2 = "0".concat(s2));
          var l2 = "".concat(t2[6]).concat(t2[7], "/").concat(o2, "/").concat(s2);
          if (!(0, v.default)(l2, "YY/MM/DD"))
            return false;
          for (var u2 = 0, d2 = 1; d2 < t2.length - 1; d2 += 2) {
            var f2 = parseInt(t2[d2], 10);
            isNaN(f2) && (f2 = t2[d2].charCodeAt(0) - 65), u2 += f2;
          }
          for (var c2 = { A: 1, B: 0, C: 5, D: 7, E: 9, F: 13, G: 15, H: 17, I: 19, J: 21, K: 2, L: 4, M: 18, N: 20, O: 11, P: 3, Q: 6, R: 8, S: 12, T: 14, U: 16, V: 10, W: 22, X: 25, Y: 24, Z: 23, 0: 1, 1: 0 }, p2 = 0; p2 < t2.length - 1; p2 += 2) {
            var h2 = 0;
            if (t2[p2] in c2)
              h2 = c2[t2[p2]];
            else {
              var m = parseInt(t2[p2], 10);
              h2 = 2 * m + 1, 4 < m && (h2 += 2);
            }
            u2 += h2;
          }
          return String.fromCharCode(65 + u2 % 26) === t2[15];
        }, "lv-LV": function(e2) {
          var t2 = (e2 = e2.replace(/\W/, "")).slice(0, 2);
          if ("32" === t2)
            return true;
          if ("00" !== e2.slice(2, 4)) {
            var r2 = e2.slice(4, 6);
            switch (e2[6]) {
              case "0":
                r2 = "18".concat(r2);
                break;
              case "1":
                r2 = "19".concat(r2);
                break;
              default:
                r2 = "20".concat(r2);
            }
            var i2 = "".concat(r2, "/").concat(e2.slice(2, 4), "/").concat(t2);
            if (!(0, v.default)(i2, "YYYY/MM/DD"))
              return false;
          }
          for (var n2 = 1101, a2 = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2], o2 = 0; o2 < e2.length - 1; o2++)
            n2 -= parseInt(e2[o2], 10) * a2[o2];
          return parseInt(e2[10], 10) === n2 % 11;
        }, "mt-MT": function(e2) {
          if (9 !== e2.length) {
            for (var t2 = e2.toUpperCase().split(""); t2.length < 8; )
              t2.unshift(0);
            switch (e2[7]) {
              case "A":
              case "P":
                if (0 === parseInt(t2[6], 10))
                  return false;
                break;
              default:
                var r2 = parseInt(t2.join("").slice(0, 5), 10);
                if (32e3 < r2)
                  return false;
                if (r2 === parseInt(t2.join("").slice(5, 7), 10))
                  return false;
            }
          }
          return true;
        }, "nl-NL": function(e2) {
          return l.reverseMultiplyAndSum(e2.split("").slice(0, 8).map(function(e3) {
            return parseInt(e3, 10);
          }), 9) % 11 === parseInt(e2[8], 10);
        }, "pl-PL": function(e2) {
          if (10 === e2.length) {
            for (var t2 = [6, 5, 7, 2, 3, 4, 5, 6, 7], r2 = 0, i2 = 0; i2 < t2.length; i2++)
              r2 += parseInt(e2[i2], 10) * t2[i2];
            return 10 != (r2 %= 11) && r2 === parseInt(e2[9], 10);
          }
          var n2 = e2.slice(0, 2), a2 = parseInt(e2.slice(2, 4), 10);
          80 < a2 ? (n2 = "18".concat(n2), a2 -= 80) : 60 < a2 ? (n2 = "22".concat(n2), a2 -= 60) : 40 < a2 ? (n2 = "21".concat(n2), a2 -= 40) : 20 < a2 ? (n2 = "20".concat(n2), a2 -= 20) : n2 = "19".concat(n2), a2 < 10 && (a2 = "0".concat(a2));
          var o2 = "".concat(n2, "/").concat(a2, "/").concat(e2.slice(4, 6));
          if (!(0, v.default)(o2, "YYYY/MM/DD"))
            return false;
          for (var s2 = 0, l2 = 1, u2 = 0; u2 < e2.length - 1; u2++)
            s2 += parseInt(e2[u2], 10) * l2 % 10, 10 < (l2 += 2) ? l2 = 1 : 5 === l2 && (l2 += 2);
          return (s2 = 10 - s2 % 10) === parseInt(e2[10], 10);
        }, "pt-BR": function(e2) {
          if (11 === e2.length) {
            var t2, r2;
            if (t2 = 0, "11111111111" === e2 || "22222222222" === e2 || "33333333333" === e2 || "44444444444" === e2 || "55555555555" === e2 || "66666666666" === e2 || "77777777777" === e2 || "88888888888" === e2 || "99999999999" === e2 || "00000000000" === e2)
              return false;
            for (var i2 = 1; i2 <= 9; i2++)
              t2 += parseInt(e2.substring(i2 - 1, i2), 10) * (11 - i2);
            if (10 == (r2 = 10 * t2 % 11) && (r2 = 0), r2 !== parseInt(e2.substring(9, 10), 10))
              return false;
            t2 = 0;
            for (var n2 = 1; n2 <= 10; n2++)
              t2 += parseInt(e2.substring(n2 - 1, n2), 10) * (12 - n2);
            return 10 == (r2 = 10 * t2 % 11) && (r2 = 0), r2 === parseInt(e2.substring(10, 11), 10);
          }
          if ("00000000000000" === e2 || "11111111111111" === e2 || "22222222222222" === e2 || "33333333333333" === e2 || "44444444444444" === e2 || "55555555555555" === e2 || "66666666666666" === e2 || "77777777777777" === e2 || "88888888888888" === e2 || "99999999999999" === e2)
            return false;
          for (var a2 = e2.length - 2, o2 = e2.substring(0, a2), s2 = e2.substring(a2), l2 = 0, u2 = a2 - 7, d2 = a2; 1 <= d2; d2--)
            l2 += o2.charAt(a2 - d2) * u2, (u2 -= 1) < 2 && (u2 = 9);
          var f2 = l2 % 11 < 2 ? 0 : 11 - l2 % 11;
          if (f2 !== parseInt(s2.charAt(0), 10))
            return false;
          a2 += 1, o2 = e2.substring(0, a2), l2 = 0, u2 = a2 - 7;
          for (var c2 = a2; 1 <= c2; c2--)
            l2 += o2.charAt(a2 - c2) * u2, (u2 -= 1) < 2 && (u2 = 9);
          return (f2 = l2 % 11 < 2 ? 0 : 11 - l2 % 11) === parseInt(s2.charAt(1), 10);
        }, "pt-PT": function(e2) {
          var t2 = 11 - l.reverseMultiplyAndSum(e2.split("").slice(0, 8).map(function(e3) {
            return parseInt(e3, 10);
          }), 9) % 11;
          return 9 < t2 ? 0 === parseInt(e2[8], 10) : t2 === parseInt(e2[8], 10);
        }, "ro-RO": function(e2) {
          if ("9000" === e2.slice(0, 4))
            return true;
          var t2 = e2.slice(1, 3);
          switch (e2[0]) {
            case "1":
            case "2":
              t2 = "19".concat(t2);
              break;
            case "3":
            case "4":
              t2 = "18".concat(t2);
              break;
            case "5":
            case "6":
              t2 = "20".concat(t2);
          }
          var r2 = "".concat(t2, "/").concat(e2.slice(3, 5), "/").concat(e2.slice(5, 7));
          if (8 === r2.length) {
            if (!(0, v.default)(r2, "YY/MM/DD"))
              return false;
          } else if (!(0, v.default)(r2, "YYYY/MM/DD"))
            return false;
          for (var i2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), n2 = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9], a2 = 0, o2 = 0; o2 < n2.length; o2++)
            a2 += i2[o2] * n2[o2];
          return a2 % 11 == 10 ? 1 === i2[12] : i2[12] === a2 % 11;
        }, "sk-SK": function(e2) {
          if (9 === e2.length) {
            if ("000" === (e2 = e2.replace(/\W/, "")).slice(6))
              return false;
            var t2 = parseInt(e2.slice(0, 2), 10);
            if (53 < t2)
              return false;
            t2 = t2 < 10 ? "190".concat(t2) : "19".concat(t2);
            var r2 = parseInt(e2.slice(2, 4), 10);
            50 < r2 && (r2 -= 50), r2 < 10 && (r2 = "0".concat(r2));
            var i2 = "".concat(t2, "/").concat(r2, "/").concat(e2.slice(4, 6));
            if (!(0, v.default)(i2, "YYYY/MM/DD"))
              return false;
          }
          return true;
        }, "sl-SI": function(e2) {
          var t2 = 11 - l.reverseMultiplyAndSum(e2.split("").slice(0, 7).map(function(e3) {
            return parseInt(e3, 10);
          }), 8) % 11;
          return 10 === t2 ? 0 === parseInt(e2[7], 10) : t2 === parseInt(e2[7], 10);
        }, "sv-SE": function(e2) {
          var t2 = e2.slice(0);
          11 < e2.length && (t2 = t2.slice(2));
          var r2 = "", i2 = t2.slice(2, 4), n2 = parseInt(t2.slice(4, 6), 10);
          if (11 < e2.length)
            r2 = e2.slice(0, 4);
          else if (r2 = e2.slice(0, 2), 11 === e2.length && n2 < 60) {
            var a2 = (/* @__PURE__ */ new Date()).getFullYear().toString(), o2 = parseInt(a2.slice(0, 2), 10);
            if (a2 = parseInt(a2, 10), "-" === e2[6])
              r2 = parseInt("".concat(o2).concat(r2), 10) > a2 ? "".concat(o2 - 1).concat(r2) : "".concat(o2).concat(r2);
            else if (r2 = "".concat(o2 - 1).concat(r2), a2 - parseInt(r2, 10) < 100)
              return false;
          }
          60 < n2 && (n2 -= 60), n2 < 10 && (n2 = "0".concat(n2));
          var s2 = "".concat(r2, "/").concat(i2, "/").concat(n2);
          if (8 === s2.length) {
            if (!(0, v.default)(s2, "YY/MM/DD"))
              return false;
          } else if (!(0, v.default)(s2, "YYYY/MM/DD"))
            return false;
          return l.luhnCheck(e2.replace(/\W/, ""));
        } };
        c["lb-LU"] = c["fr-LU"], c["lt-LT"] = c["et-EE"], c["nl-BE"] = c["fr-BE"];
        var p = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g, h = { "de-AT": p, "de-DE": /[\/\\]/g, "fr-BE": p };
        h["nl-BE"] = h["fr-BE"], t.exports = r.default, t.exports.default = r.default;
      }, { "./isDate": 25, "./util/algorithms": 98, "./util/assertString": 99 }], 81: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, _2.default)(e2), !e2 || /[\s<>]/.test(e2))
            return false;
          if (0 === e2.indexOf("mailto:"))
            return false;
          if ((t2 = (0, E.default)(t2, S)).validate_length && 2083 <= e2.length)
            return false;
          if (!t2.allow_fragments && e2.includes("#"))
            return false;
          if (!t2.allow_query_components && (e2.includes("?") || e2.includes("&")))
            return false;
          var r2, i2, n, a, o, s, l, u;
          if (1 < (l = (e2 = (l = (e2 = (l = e2.split("#")).shift()).split("?")).shift()).split("://")).length) {
            if (r2 = l.shift().toLowerCase(), t2.require_valid_protocol && -1 === t2.protocols.indexOf(r2))
              return false;
          } else {
            if (t2.require_protocol)
              return false;
            if ("//" === e2.substr(0, 2)) {
              if (!t2.allow_protocol_relative_urls)
                return false;
              l[0] = e2.substr(2);
            }
          }
          if ("" === (e2 = l.join("://")))
            return false;
          if ("" === (e2 = (l = e2.split("/")).shift()) && !t2.require_host)
            return true;
          if (1 < (l = e2.split("@")).length) {
            if (t2.disallow_auth)
              return false;
            if ("" === l[0])
              return false;
            if (0 <= (i2 = l.shift()).indexOf(":") && 2 < i2.split(":").length)
              return false;
            var d = i2.split(":"), f = (m = 2, function(e3) {
              if (Array.isArray(e3))
                return e3;
            }(h = d) || function(e3, t3) {
              if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3)) {
                var r3 = [], i3 = true, n2 = false, a2 = void 0;
                try {
                  for (var o2, s2 = e3[Symbol.iterator](); !(i3 = (o2 = s2.next()).done) && (r3.push(o2.value), !t3 || r3.length !== t3); i3 = true)
                    ;
                } catch (e4) {
                  n2 = true, a2 = e4;
                } finally {
                  try {
                    i3 || null == s2.return || s2.return();
                  } finally {
                    if (n2)
                      throw a2;
                  }
                }
                return r3;
              }
            }(h, m) || function(e3, t3) {
              if (e3) {
                if ("string" == typeof e3)
                  return A(e3, t3);
                var r3 = Object.prototype.toString.call(e3).slice(8, -1);
                return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? A(e3, t3) : void 0;
              }
            }(h, m) || function() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }()), c = f[0], p = f[1];
            if ("" === c && "" === p)
              return false;
          }
          var h, m;
          a = l.join("@"), u = s = null;
          var v = a.match(b);
          v ? (n = "", u = v[1], s = v[2] || null) : (l = a.split(":"), n = l.shift(), l.length && (s = l.join(":")));
          if (null !== s && 0 < s.length) {
            if (o = parseInt(s, 10), !/^[0-9]+$/.test(s) || o <= 0 || 65535 < o)
              return false;
          } else if (t2.require_port)
            return false;
          if (t2.host_whitelist)
            return O(n, t2.host_whitelist);
          if (!((0, y.default)(n) || (0, g.default)(n, t2) || u && (0, y.default)(u, 6)))
            return false;
          if (n = n || u, t2.host_blacklist && O(n, t2.host_blacklist))
            return false;
          return true;
        };
        var _2 = i(e("./util/assertString")), g = i(e("./isFQDN")), y = i(e("./isIP")), E = i(e("./util/merge"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function A(e2, t2) {
          (null == t2 || t2 > e2.length) && (t2 = e2.length);
          for (var r2 = 0, i2 = new Array(t2); r2 < t2; r2++)
            i2[r2] = e2[r2];
          return i2;
        }
        var S = { protocols: ["http", "https", "ftp"], require_tld: true, require_protocol: false, require_host: true, require_port: false, require_valid_protocol: true, allow_underscores: false, allow_trailing_dot: false, allow_protocol_relative_urls: false, allow_fragments: true, allow_query_components: true, validate_length: true }, b = /^\[([^\]]+)\](?::([0-9]+))?$/;
        function O(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2++) {
            var i2 = t2[r2];
            if (e2 === i2 || (n = i2, "[object RegExp]" === Object.prototype.toString.call(n) && i2.test(e2)))
              return true;
          }
          var n;
          return false;
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isFQDN": 32, "./isIP": 42, "./util/assertString": 99, "./util/merge": 101 }], 82: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2);
          var r2 = a[[void 0, null].includes(t2) ? "all" : t2];
          return !!r2 && r2.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { 1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i, 2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i, 3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i, 4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i, 5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i, all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 83: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), e2 === e2.toUpperCase();
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 84: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), (0, n.default)(t2), t2 in a)
            return a[t2].test(e2);
          throw new Error("Invalid country code: '".concat(t2, "'"));
        }, r.vatMatchers = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { GB: /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/, IT: /^(IT)?[0-9]{11}$/, NL: /^(NL)?[0-9]{9}B[0-9]{2}$/ };
        r.vatMatchers = a;
      }, { "./util/assertString": 99 }], 85: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.fullWidth.test(e2) && o.halfWidth.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, a = e("./isFullWidth"), o = e("./isHalfWidth");
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isFullWidth": 34, "./isHalfWidth": 36, "./util/assertString": 99 }], 86: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2);
          for (var r2 = e2.length - 1; 0 <= r2; r2--)
            if (-1 === t2.indexOf(e2[r2]))
              return false;
          return true;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 87: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2);
          var r2 = t2 ? new RegExp("^[".concat(t2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+"), "g") : /^\s+/g;
          return e2.replace(r2, "");
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 88: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2, r2) {
          (0, n.default)(e2), "[object RegExp]" !== Object.prototype.toString.call(t2) && (t2 = new RegExp(t2, r2));
          return t2.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 89: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          t2 = (0, o.default)(t2, s);
          var r2 = e2.split("@"), i2 = r2.pop(), n = [r2.join("@"), i2];
          if (n[1] = n[1].toLowerCase(), "gmail.com" === n[1] || "googlemail.com" === n[1]) {
            if (t2.gmail_remove_subaddress && (n[0] = n[0].split("+")[0]), t2.gmail_remove_dots && (n[0] = n[0].replace(/\.+/g, c)), !n[0].length)
              return false;
            (t2.all_lowercase || t2.gmail_lowercase) && (n[0] = n[0].toLowerCase()), n[1] = t2.gmail_convert_googlemaildotcom ? "gmail.com" : n[1];
          } else if (0 <= l.indexOf(n[1])) {
            if (t2.icloud_remove_subaddress && (n[0] = n[0].split("+")[0]), !n[0].length)
              return false;
            (t2.all_lowercase || t2.icloud_lowercase) && (n[0] = n[0].toLowerCase());
          } else if (0 <= u.indexOf(n[1])) {
            if (t2.outlookdotcom_remove_subaddress && (n[0] = n[0].split("+")[0]), !n[0].length)
              return false;
            (t2.all_lowercase || t2.outlookdotcom_lowercase) && (n[0] = n[0].toLowerCase());
          } else if (0 <= d.indexOf(n[1])) {
            if (t2.yahoo_remove_subaddress) {
              var a = n[0].split("-");
              n[0] = 1 < a.length ? a.slice(0, -1).join("-") : a[0];
            }
            if (!n[0].length)
              return false;
            (t2.all_lowercase || t2.yahoo_lowercase) && (n[0] = n[0].toLowerCase());
          } else
            0 <= f.indexOf(n[1]) ? ((t2.all_lowercase || t2.yandex_lowercase) && (n[0] = n[0].toLowerCase()), n[1] = "yandex.ru") : t2.all_lowercase && (n[0] = n[0].toLowerCase());
          return n.join("@");
        };
        var i, o = (i = e("./util/merge")) && i.__esModule ? i : { default: i };
        var s = { all_lowercase: true, gmail_lowercase: true, gmail_remove_dots: true, gmail_remove_subaddress: true, gmail_convert_googlemaildotcom: true, outlookdotcom_lowercase: true, outlookdotcom_remove_subaddress: true, yahoo_lowercase: true, yahoo_remove_subaddress: true, yandex_lowercase: true, icloud_lowercase: true, icloud_remove_subaddress: true }, l = ["icloud.com", "me.com"], u = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"], d = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"], f = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];
        function c(e2) {
          return 1 < e2.length ? e2 : "";
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/merge": 101 }], 90: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), t2) {
            var r2 = new RegExp("[".concat(t2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+$"), "g");
            return e2.replace(r2, "");
          }
          var i2 = e2.length - 1;
          for (; /\s/.test(e2.charAt(i2)); )
            i2 -= 1;
          return e2.slice(0, i2 + 1);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 91: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, i.default)(e2);
          var r2 = t2 ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
          return (0, n.default)(e2, r2);
        };
        var i = a(e("./util/assertString")), n = a(e("./blacklist"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./blacklist": 6, "./util/assertString": 99 }], 92: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), t2)
            return "1" === e2 || /^true$/i.test(e2);
          return "0" !== e2 && !/^false$/i.test(e2) && "" !== e2;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 93: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), e2 = Date.parse(e2), isNaN(e2) ? null : new Date(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 94: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2) ? parseFloat(e2) : NaN;
        };
        var i, n = (i = e("./isFloat")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isFloat": 33 }], 95: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), parseInt(e2, t2 || 10);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 96: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, i.default)((0, n.default)(e2, t2), t2);
        };
        var i = a(e("./rtrim")), n = a(e("./ltrim"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./ltrim": 87, "./rtrim": 90 }], 97: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), e2.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#x5C;/g, "\\").replace(/&#96;/g, "`").replace(/&amp;/g, "&");
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 98: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.iso7064Check = function(e2) {
          for (var t2 = 10, r2 = 0; r2 < e2.length - 1; r2++)
            t2 = (parseInt(e2[r2], 10) + t2) % 10 == 0 ? 9 : (parseInt(e2[r2], 10) + t2) % 10 * 2 % 11;
          return (t2 = 1 === t2 ? 0 : 11 - t2) === parseInt(e2[10], 10);
        }, r.luhnCheck = function(e2) {
          for (var t2 = 0, r2 = false, i = e2.length - 1; 0 <= i; i--) {
            if (r2) {
              var n = 2 * parseInt(e2[i], 10);
              t2 += 9 < n ? n.toString().split("").map(function(e3) {
                return parseInt(e3, 10);
              }).reduce(function(e3, t3) {
                return e3 + t3;
              }, 0) : n;
            } else
              t2 += parseInt(e2[i], 10);
            r2 = !r2;
          }
          return t2 % 10 == 0;
        }, r.reverseMultiplyAndSum = function(e2, t2) {
          for (var r2 = 0, i = 0; i < e2.length; i++)
            r2 += e2[i] * (t2 - i);
          return r2;
        }, r.verhoeffCheck = function(e2) {
          for (var t2 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]], r2 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]], i = e2.split("").reverse().join(""), n = 0, a = 0; a < i.length; a++)
            n = t2[n][r2[a % 8][parseInt(i[a], 10)]];
          return 0 === n;
        };
      }, {}], 99: [function(e, t, r) {
        "use strict";
        function i(e2) {
          return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          if (!("string" == typeof e2 || e2 instanceof String)) {
            var t2 = i(e2);
            throw null === e2 ? t2 = "null" : "object" === t2 && (t2 = e2.constructor.name), new TypeError("Expected a string but received a ".concat(t2));
          }
        }, t.exports = r.default, t.exports.default = r.default;
      }, {}], 100: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var i = function(e2, t2) {
          return e2.some(function(e3) {
            return t2 === e3;
          });
        };
        r.default = i, t.exports = r.default, t.exports.default = r.default;
      }, {}], 101: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function() {
          var e2 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}, t2 = 1 < arguments.length ? arguments[1] : void 0;
          for (var r2 in t2)
            void 0 === e2[r2] && (e2[r2] = t2[r2]);
          return e2;
        }, t.exports = r.default, t.exports.default = r.default;
      }, {}], 102: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          var r2 = e2.join("");
          return new RegExp(r2, t2);
        }, t.exports = r.default, t.exports.default = r.default;
      }, {}], 103: [function(e, t, r) {
        "use strict";
        function i(e2) {
          return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          "object" === i(e2) && null !== e2 ? e2 = "function" == typeof e2.toString ? e2.toString() : "[object Object]" : (null == e2 || isNaN(e2) && !e2.length) && (e2 = "");
          return String(e2);
        }, t.exports = r.default, t.exports.default = r.default;
      }, {}], 104: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), e2.replace(new RegExp("[^".concat(t2, "]+"), "g"), "");
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 105: [function(e, t, r) {
        "use strict";
        t.exports = { INVALID_TYPE: "Expected type {0} but found type {1}", INVALID_FORMAT: "Object didn't pass validation for format {0}: {1}", ENUM_MISMATCH: "No enum match for: {0}", ENUM_CASE_MISMATCH: "Enum does not match case for: {0}", ANY_OF_MISSING: "Data does not match any schemas from 'anyOf'", ONE_OF_MISSING: "Data does not match any schemas from 'oneOf'", ONE_OF_MULTIPLE: "Data is valid against more than one schema from 'oneOf'", NOT_PASSED: "Data matches schema from 'not'", ARRAY_LENGTH_SHORT: "Array is too short ({0}), minimum {1}", ARRAY_LENGTH_LONG: "Array is too long ({0}), maximum {1}", ARRAY_UNIQUE: "Array items are not unique (indexes {0} and {1})", ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed", MULTIPLE_OF: "Value {0} is not a multiple of {1}", MINIMUM: "Value {0} is less than minimum {1}", MINIMUM_EXCLUSIVE: "Value {0} is equal or less than exclusive minimum {1}", MAXIMUM: "Value {0} is greater than maximum {1}", MAXIMUM_EXCLUSIVE: "Value {0} is equal or greater than exclusive maximum {1}", OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({0}), minimum {1}", OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({0}), maximum {1}", OBJECT_MISSING_REQUIRED_PROPERTY: "Missing required property: {0}", OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed: {0}", OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {0} (due to key: {1})", MIN_LENGTH: "String is too short ({0} chars), minimum {1}", MAX_LENGTH: "String is too long ({0} chars), maximum {1}", PATTERN: "String does not match pattern {0}: {1}", KEYWORD_TYPE_EXPECTED: "Keyword '{0}' is expected to be of type '{1}'", KEYWORD_UNDEFINED_STRICT: "Keyword '{0}' must be defined in strict mode", KEYWORD_UNEXPECTED: "Keyword '{0}' is not expected to appear in the schema", KEYWORD_MUST_BE: "Keyword '{0}' must be {1}", KEYWORD_DEPENDENCY: "Keyword '{0}' requires keyword '{1}'", KEYWORD_PATTERN: "Keyword '{0}' is not a valid RegExp pattern: {1}", KEYWORD_VALUE_TYPE: "Each element of keyword '{0}' array must be a '{1}'", UNKNOWN_FORMAT: "There is no validation function for format '{0}'", CUSTOM_MODE_FORCE_PROPERTIES: "{0} must define at least one property if present", REF_UNRESOLVED: "Reference has not been resolved during compilation: {0}", UNRESOLVABLE_REFERENCE: "Reference could not be resolved: {0}", SCHEMA_NOT_REACHABLE: "Validator was not able to read schema with uri: {0}", SCHEMA_TYPE_EXPECTED: "Schema is expected to be of type 'object'", SCHEMA_NOT_AN_OBJECT: "Schema is not an object: {0}", ASYNC_TIMEOUT: "{0} asynchronous task(s) have timed out after {1} ms", PARENT_SCHEMA_VALIDATION_FAILED: "Schema failed to validate against its parent schema, see inner errors for details.", REMOTE_NOT_VALID: "Remote reference didn't compile successfully: {0}" };
      }, {}], 106: [function(e, t, r) {
        var i = e("validator"), n = { date: function(e2) {
          if ("string" != typeof e2)
            return true;
          var t2 = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(e2);
          return null !== t2 && !(t2[2] < "01" || "12" < t2[2] || t2[3] < "01" || "31" < t2[3]);
        }, "date-time": function(e2) {
          if ("string" != typeof e2)
            return true;
          var t2 = e2.toLowerCase().split("t");
          if (!n.date(t2[0]))
            return false;
          var r2 = /^([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?(z|([+-][0-9]{2}:[0-9]{2}))$/.exec(t2[1]);
          return null !== r2 && !("23" < r2[1] || "59" < r2[2] || "59" < r2[3]);
        }, email: function(e2) {
          return "string" != typeof e2 || i.isEmail(e2, { require_tld: true });
        }, hostname: function(e2) {
          if ("string" != typeof e2)
            return true;
          var t2 = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/.test(e2);
          if (t2) {
            if (255 < e2.length)
              return false;
            for (var r2 = e2.split("."), i2 = 0; i2 < r2.length; i2++)
              if (63 < r2[i2].length)
                return false;
          }
          return t2;
        }, "host-name": function(e2) {
          return n.hostname.call(this, e2);
        }, ipv4: function(e2) {
          return "string" != typeof e2 || i.isIP(e2, 4);
        }, ipv6: function(e2) {
          return "string" != typeof e2 || i.isIP(e2, 6);
        }, regex: function(e2) {
          try {
            return RegExp(e2), true;
          } catch (e3) {
            return false;
          }
        }, uri: function(e2) {
          return this.options.strictUris ? n["strict-uri"].apply(this, arguments) : "string" != typeof e2 || RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?").test(e2);
        }, "strict-uri": function(e2) {
          return "string" != typeof e2 || i.isURL(e2);
        } };
        t.exports = n;
      }, { validator: 4 }], 107: [function(e, t, p) {
        "use strict";
        var o = e("./FormatValidators"), s = e("./Report"), h = e("./Utils"), m = function(t2, e2) {
          return t2 && Array.isArray(t2.includeErrors) && 0 < t2.includeErrors.length && !e2.some(function(e3) {
            return t2.includeErrors.includes(e3);
          });
        }, u = { multipleOf: function(e2, t2, r) {
          if (!m(this.validateOptions, ["MULTIPLE_OF"]) && "number" == typeof r) {
            var i = String(t2.multipleOf), n = Math.pow(10, i.length - i.indexOf(".") - 1);
            "integer" !== h.whatIs(r * n / (t2.multipleOf * n)) && e2.addError("MULTIPLE_OF", [r, t2.multipleOf], null, t2);
          }
        }, maximum: function(e2, t2, r) {
          m(this.validateOptions, ["MAXIMUM", "MAXIMUM_EXCLUSIVE"]) || "number" == typeof r && (true !== t2.exclusiveMaximum ? r > t2.maximum && e2.addError("MAXIMUM", [r, t2.maximum], null, t2) : r >= t2.maximum && e2.addError("MAXIMUM_EXCLUSIVE", [r, t2.maximum], null, t2));
        }, exclusiveMaximum: function() {
        }, minimum: function(e2, t2, r) {
          m(this.validateOptions, ["MINIMUM", "MINIMUM_EXCLUSIVE"]) || "number" == typeof r && (true !== t2.exclusiveMinimum ? r < t2.minimum && e2.addError("MINIMUM", [r, t2.minimum], null, t2) : r <= t2.minimum && e2.addError("MINIMUM_EXCLUSIVE", [r, t2.minimum], null, t2));
        }, exclusiveMinimum: function() {
        }, maxLength: function(e2, t2, r) {
          m(this.validateOptions, ["MAX_LENGTH"]) || "string" == typeof r && h.ucs2decode(r).length > t2.maxLength && e2.addError("MAX_LENGTH", [r.length, t2.maxLength], null, t2);
        }, minLength: function(e2, t2, r) {
          m(this.validateOptions, ["MIN_LENGTH"]) || "string" == typeof r && h.ucs2decode(r).length < t2.minLength && e2.addError("MIN_LENGTH", [r.length, t2.minLength], null, t2);
        }, pattern: function(e2, t2, r) {
          m(this.validateOptions, ["PATTERN"]) || "string" == typeof r && false === RegExp(t2.pattern).test(r) && e2.addError("PATTERN", [t2.pattern, r], null, t2);
        }, additionalItems: function(e2, t2, r) {
          m(this.validateOptions, ["ARRAY_ADDITIONAL_ITEMS"]) || Array.isArray(r) && false === t2.additionalItems && Array.isArray(t2.items) && r.length > t2.items.length && e2.addError("ARRAY_ADDITIONAL_ITEMS", null, null, t2);
        }, items: function() {
        }, maxItems: function(e2, t2, r) {
          m(this.validateOptions, ["ARRAY_LENGTH_LONG"]) || Array.isArray(r) && r.length > t2.maxItems && e2.addError("ARRAY_LENGTH_LONG", [r.length, t2.maxItems], null, t2);
        }, minItems: function(e2, t2, r) {
          m(this.validateOptions, ["ARRAY_LENGTH_SHORT"]) || Array.isArray(r) && r.length < t2.minItems && e2.addError("ARRAY_LENGTH_SHORT", [r.length, t2.minItems], null, t2);
        }, uniqueItems: function(e2, t2, r) {
          if (!m(this.validateOptions, ["ARRAY_UNIQUE"]) && Array.isArray(r) && true === t2.uniqueItems) {
            var i = [];
            false === h.isUniqueArray(r, i) && e2.addError("ARRAY_UNIQUE", i, null, t2);
          }
        }, maxProperties: function(e2, t2, r) {
          if (!m(this.validateOptions, ["OBJECT_PROPERTIES_MAXIMUM"]) && "object" === h.whatIs(r)) {
            var i = Object.keys(r).length;
            i > t2.maxProperties && e2.addError("OBJECT_PROPERTIES_MAXIMUM", [i, t2.maxProperties], null, t2);
          }
        }, minProperties: function(e2, t2, r) {
          if (!m(this.validateOptions, ["OBJECT_PROPERTIES_MINIMUM"]) && "object" === h.whatIs(r)) {
            var i = Object.keys(r).length;
            i < t2.minProperties && e2.addError("OBJECT_PROPERTIES_MINIMUM", [i, t2.minProperties], null, t2);
          }
        }, required: function(e2, t2, r) {
          if (!m(this.validateOptions, ["OBJECT_MISSING_REQUIRED_PROPERTY"]) && "object" === h.whatIs(r))
            for (var i = t2.required.length; i--; ) {
              var n = t2.required[i];
              void 0 === r[n] && e2.addError("OBJECT_MISSING_REQUIRED_PROPERTY", [n], null, t2);
            }
        }, additionalProperties: function(e2, t2, r) {
          if (void 0 === t2.properties && void 0 === t2.patternProperties)
            return u.properties.call(this, e2, t2, r);
        }, patternProperties: function(e2, t2, r) {
          if (void 0 === t2.properties)
            return u.properties.call(this, e2, t2, r);
        }, properties: function(e2, t2, r) {
          if (!m(this.validateOptions, ["OBJECT_ADDITIONAL_PROPERTIES"]) && "object" === h.whatIs(r)) {
            var i = void 0 !== t2.properties ? t2.properties : {}, n = void 0 !== t2.patternProperties ? t2.patternProperties : {};
            if (false === t2.additionalProperties) {
              var a = Object.keys(r), o2 = Object.keys(i), s2 = Object.keys(n);
              a = h.difference(a, o2);
              for (var l = s2.length; l--; )
                for (var u2 = RegExp(s2[l]), d = a.length; d--; )
                  true === u2.test(a[d]) && a.splice(d, 1);
              if (0 < a.length) {
                var f = this.options.assumeAdditional.length;
                if (f)
                  for (; f--; ) {
                    var c = a.indexOf(this.options.assumeAdditional[f]);
                    -1 !== c && a.splice(c, 1);
                  }
                var p2 = a.length;
                if (p2)
                  for (; p2--; )
                    e2.addError("OBJECT_ADDITIONAL_PROPERTIES", [a[p2]], null, t2);
              }
            }
          }
        }, dependencies: function(e2, t2, r) {
          if (!m(this.validateOptions, ["OBJECT_DEPENDENCY_KEY"]) && "object" === h.whatIs(r))
            for (var i = Object.keys(t2.dependencies), n = i.length; n--; ) {
              var a = i[n];
              if (r[a]) {
                var o2 = t2.dependencies[a];
                if ("object" === h.whatIs(o2))
                  p.validate.call(this, e2, o2, r);
                else
                  for (var s2 = o2.length; s2--; ) {
                    var l = o2[s2];
                    void 0 === r[l] && e2.addError("OBJECT_DEPENDENCY_KEY", [l, a], null, t2);
                  }
              }
            }
        }, enum: function(e2, t2, r) {
          if (!m(this.validateOptions, ["ENUM_CASE_MISMATCH", "ENUM_MISMATCH"])) {
            for (var i = false, n = false, a = t2.enum.length; a--; ) {
              if (h.areEqual(r, t2.enum[a])) {
                i = true;
                break;
              }
              h.areEqual(r, t2.enum[a]), n = true;
            }
            if (false === i) {
              var o2 = n && this.options.enumCaseInsensitiveComparison ? "ENUM_CASE_MISMATCH" : "ENUM_MISMATCH";
              e2.addError(o2, [r], null, t2);
            }
          }
        }, type: function(e2, t2, r) {
          if (!m(this.validateOptions, ["INVALID_TYPE"])) {
            var i = h.whatIs(r);
            "string" == typeof t2.type ? i === t2.type || "integer" === i && "number" === t2.type || e2.addError("INVALID_TYPE", [t2.type, i], null, t2) : -1 !== t2.type.indexOf(i) || "integer" === i && -1 !== t2.type.indexOf("number") || e2.addError("INVALID_TYPE", [t2.type, i], null, t2);
          }
        }, allOf: function(e2, t2, r) {
          for (var i = t2.allOf.length; i--; ) {
            var n = p.validate.call(this, e2, t2.allOf[i], r);
            if (this.options.breakOnFirstError && false === n)
              break;
          }
        }, anyOf: function(e2, t2, r) {
          for (var i = [], n = false, a = t2.anyOf.length; a-- && false === n; ) {
            var o2 = new s(e2);
            i.push(o2), n = p.validate.call(this, o2, t2.anyOf[a], r);
          }
          false === n && e2.addError("ANY_OF_MISSING", void 0, i, t2);
        }, oneOf: function(e2, t2, r) {
          for (var i = 0, n = [], a = t2.oneOf.length; a--; ) {
            var o2 = new s(e2, { maxErrors: 1 });
            n.push(o2), true === p.validate.call(this, o2, t2.oneOf[a], r) && i++;
          }
          0 === i ? e2.addError("ONE_OF_MISSING", void 0, n, t2) : 1 < i && e2.addError("ONE_OF_MULTIPLE", null, null, t2);
        }, not: function(e2, t2, r) {
          var i = new s(e2);
          true === p.validate.call(this, i, t2.not, r) && e2.addError("NOT_PASSED", null, null, t2);
        }, definitions: function() {
        }, format: function(r, i, n) {
          var e2 = o[i.format];
          if ("function" == typeof e2) {
            if (m(this.validateOptions, ["INVALID_FORMAT"]))
              return;
            if (2 === e2.length) {
              var a = h.clone(r.path);
              r.addAsyncTask(e2, [n], function(e3) {
                if (true !== e3) {
                  var t2 = r.path;
                  r.path = a, r.addError("INVALID_FORMAT", [i.format, n], null, i), r.path = t2;
                }
              });
            } else
              true !== e2.call(this, n) && r.addError("INVALID_FORMAT", [i.format, n], null, i);
          } else
            true !== this.options.ignoreUnknownFormats && r.addError("UNKNOWN_FORMAT", [i.format], null, i);
        } };
        p.JsonValidators = u, p.validate = function(e2, t2, r) {
          e2.commonErrorMessage = "JSON_OBJECT_VALIDATION_FAILED";
          var i = h.whatIs(t2);
          if ("object" !== i)
            return e2.addError("SCHEMA_NOT_AN_OBJECT", [i], null, t2), false;
          var n = Object.keys(t2);
          if (0 === n.length)
            return true;
          var a = false;
          if (e2.rootSchema || (e2.rootSchema = t2, a = true), void 0 !== t2.$ref) {
            for (var o2 = 99; t2.$ref && 0 < o2; ) {
              if (!t2.__$refResolved) {
                e2.addError("REF_UNRESOLVED", [t2.$ref], null, t2);
                break;
              }
              if (t2.__$refResolved === t2)
                break;
              t2 = t2.__$refResolved, n = Object.keys(t2), o2--;
            }
            if (0 === o2)
              throw new Error("Circular dependency by $ref references!");
          }
          var s2 = h.whatIs(r);
          if (t2.type && (n.splice(n.indexOf("type"), 1), u.type.call(this, e2, t2, r), e2.errors.length && this.options.breakOnFirstError))
            return false;
          for (var l = n.length; l-- && !(u[n[l]] && (u[n[l]].call(this, e2, t2, r), e2.errors.length && this.options.breakOnFirstError)); )
            ;
          return 0 !== e2.errors.length && false !== this.options.breakOnFirstError || ("array" === s2 ? function(e3, t3, r2) {
            var i2 = r2.length;
            if (Array.isArray(t3.items))
              for (; i2--; )
                i2 < t3.items.length ? (e3.path.push(i2), p.validate.call(this, e3, t3.items[i2], r2[i2]), e3.path.pop()) : "object" == typeof t3.additionalItems && (e3.path.push(i2), p.validate.call(this, e3, t3.additionalItems, r2[i2]), e3.path.pop());
            else if ("object" == typeof t3.items)
              for (; i2--; )
                e3.path.push(i2), p.validate.call(this, e3, t3.items, r2[i2]), e3.path.pop();
          }.call(this, e2, t2, r) : "object" === s2 && function(e3, t3, r2) {
            var i2 = t3.additionalProperties;
            true !== i2 && void 0 !== i2 || (i2 = {});
            for (var n2 = t3.properties ? Object.keys(t3.properties) : [], a2 = t3.patternProperties ? Object.keys(t3.patternProperties) : [], o3 = Object.keys(r2), s3 = o3.length; s3--; ) {
              var l2 = o3[s3], u2 = r2[l2], d = [];
              -1 !== n2.indexOf(l2) && d.push(t3.properties[l2]);
              for (var f = a2.length; f--; ) {
                var c = a2[f];
                true === RegExp(c).test(l2) && d.push(t3.patternProperties[c]);
              }
              for (0 === d.length && false !== i2 && d.push(i2), f = d.length; f--; )
                e3.path.push(l2), p.validate.call(this, e3, d[f], u2), e3.path.pop();
            }
          }.call(this, e2, t2, r)), "function" == typeof this.options.customValidator && this.options.customValidator.call(this, e2, t2, r), a && (e2.rootSchema = void 0), 0 === e2.errors.length;
        };
      }, { "./FormatValidators": 106, "./Report": 109, "./Utils": 113 }], 108: [function(e, t, r) {
        "function" != typeof Number.isFinite && (Number.isFinite = function(e2) {
          return "number" == typeof e2 && (e2 == e2 && e2 !== 1 / 0 && e2 !== -1 / 0);
        });
      }, {}], 109: [function(e, t, r) {
        (function(d) {
          (function() {
            "use strict";
            var r2 = e("lodash.get"), n = e("./Errors"), f = e("./Utils");
            function i(e2, t2) {
              this.parentReport = e2 instanceof i ? e2 : void 0, this.options = e2 instanceof i ? e2.options : e2 || {}, this.reportOptions = t2 || {}, this.errors = [], this.path = [], this.asyncTasks = [], this.rootSchema = void 0, this.commonErrorMessage = void 0, this.json = void 0;
            }
            i.prototype.isValid = function() {
              if (0 < this.asyncTasks.length)
                throw new Error("Async tasks pending, can't answer isValid");
              return 0 === this.errors.length;
            }, i.prototype.addAsyncTask = function(e2, t2, r3) {
              this.asyncTasks.push([e2, t2, r3]);
            }, i.prototype.getAncestor = function(e2) {
              if (this.parentReport)
                return this.parentReport.getSchemaId() === e2 ? this.parentReport : this.parentReport.getAncestor(e2);
            }, i.prototype.processAsyncTasks = function(e2, r3) {
              var t2 = e2 || 2e3, i2 = this.asyncTasks.length, n2 = i2, a = false, o = this;
              function s() {
                d.nextTick(function() {
                  var e3 = 0 === o.errors.length, t3 = e3 ? null : o.errors;
                  r3(t3, e3);
                });
              }
              function l(t3) {
                return function(e3) {
                  a || (t3(e3), 0 == --i2 && s());
                };
              }
              if (0 === i2 || 0 < this.errors.length && this.options.breakOnFirstError)
                s();
              else {
                for (; n2--; ) {
                  var u = this.asyncTasks[n2];
                  u[0].apply(null, u[1].concat(l(u[2])));
                }
                setTimeout(function() {
                  0 < i2 && (a = true, o.addError("ASYNC_TIMEOUT", [i2, t2]), r3(o.errors, false));
                }, t2);
              }
            }, i.prototype.getPath = function(e2) {
              var t2 = [];
              return this.parentReport && (t2 = t2.concat(this.parentReport.path)), t2 = t2.concat(this.path), true !== e2 && (t2 = "#/" + t2.map(function(e3) {
                return e3 = e3.toString(), f.isAbsoluteUri(e3) ? "uri(" + e3 + ")" : e3.replace(/\~/g, "~0").replace(/\//g, "~1");
              }).join("/")), t2;
            }, i.prototype.getSchemaId = function() {
              if (!this.rootSchema)
                return null;
              var e2 = [];
              for (this.parentReport && (e2 = e2.concat(this.parentReport.path)), e2 = e2.concat(this.path); 0 < e2.length; ) {
                var t2 = r2(this.rootSchema, e2);
                if (t2 && t2.id)
                  return t2.id;
                e2.pop();
              }
              return this.rootSchema.id;
            }, i.prototype.hasError = function(e2, t2) {
              for (var r3 = this.errors.length; r3--; )
                if (this.errors[r3].code === e2) {
                  for (var i2 = true, n2 = this.errors[r3].params.length; n2--; )
                    this.errors[r3].params[n2] !== t2[n2] && (i2 = false);
                  if (i2)
                    return i2;
                }
              return false;
            }, i.prototype.addError = function(e2, t2, r3, i2) {
              if (!e2)
                throw new Error("No errorCode passed into addError()");
              this.addCustomError(e2, n[e2], t2, r3, i2);
            }, i.prototype.getJson = function() {
              for (var e2 = this; void 0 === e2.json; )
                if (void 0 === (e2 = e2.parentReport))
                  return;
              return e2.json;
            }, i.prototype.addCustomError = function(e2, t2, r3, i2, n2) {
              if (!(this.errors.length >= this.reportOptions.maxErrors)) {
                if (!t2)
                  throw new Error("No errorMessage known for code " + e2);
                for (var a = (r3 = r3 || []).length; a--; ) {
                  var o = f.whatIs(r3[a]), s = "object" === o || "null" === o ? JSON.stringify(r3[a]) : r3[a];
                  t2 = t2.replace("{" + a + "}", s);
                }
                var l = { code: e2, params: r3, message: t2, path: this.getPath(this.options.reportPathAsArray), schemaId: this.getSchemaId() };
                if (l[f.schemaSymbol] = n2, l[f.jsonSymbol] = this.getJson(), n2 && "string" == typeof n2 ? l.description = n2 : n2 && "object" == typeof n2 && (n2.title && (l.title = n2.title), n2.description && (l.description = n2.description)), null != i2) {
                  for (Array.isArray(i2) || (i2 = [i2]), l.inner = [], a = i2.length; a--; )
                    for (var u = i2[a], d2 = u.errors.length; d2--; )
                      l.inner.push(u.errors[d2]);
                  0 === l.inner.length && (l.inner = void 0);
                }
                this.errors.push(l);
              }
            }, t.exports = i;
          }).call(this);
        }).call(this, e("_process"));
      }, { "./Errors": 105, "./Utils": 113, _process: 3, "lodash.get": 1 }], 110: [function(e, t, r) {
        "use strict";
        var n = e("lodash.isequal"), _2 = e("./Report"), g = e("./SchemaCompilation"), y = e("./SchemaValidation"), a = e("./Utils");
        function E(e2) {
          var t2 = e2.indexOf("#");
          return -1 === t2 ? e2 : e2.slice(0, t2);
        }
        function A(e2, t2) {
          if ("object" == typeof e2 && null !== e2) {
            if (!t2)
              return e2;
            if (e2.id && (e2.id === t2 || "#" === e2.id[0] && e2.id.substring(1) === t2))
              return e2;
            var r2, i;
            if (Array.isArray(e2)) {
              for (r2 = e2.length; r2--; )
                if (i = A(e2[r2], t2))
                  return i;
            } else {
              var n2 = Object.keys(e2);
              for (r2 = n2.length; r2--; ) {
                var a2 = n2[r2];
                if (0 !== a2.indexOf("__$") && (i = A(e2[a2], t2)))
                  return i;
              }
            }
          }
        }
        r.cacheSchemaByUri = function(e2, t2) {
          var r2 = E(e2);
          r2 && (this.cache[r2] = t2);
        }, r.removeFromCacheByUri = function(e2) {
          var t2 = E(e2);
          t2 && delete this.cache[t2];
        }, r.checkCacheForUri = function(e2) {
          var t2 = E(e2);
          return !!t2 && null != this.cache[t2];
        }, r.getSchema = function(e2, t2) {
          return "object" == typeof t2 && (t2 = r.getSchemaByReference.call(this, e2, t2)), "string" == typeof t2 && (t2 = r.getSchemaByUri.call(this, e2, t2)), t2;
        }, r.getSchemaByReference = function(e2, t2) {
          for (var r2 = this.referenceCache.length; r2--; )
            if (n(this.referenceCache[r2][0], t2))
              return this.referenceCache[r2][1];
          var i = a.cloneDeep(t2);
          return this.referenceCache.push([t2, i]), i;
        }, r.getSchemaByUri = function(e2, t2, r2) {
          var i, n2, a2, o = E(t2), s = -1 === (n2 = (i = t2).indexOf("#")) ? void 0 : i.slice(n2 + 1), l = o ? this.cache[o] : r2;
          if (l && o && l !== r2) {
            var u;
            e2.path.push(o);
            var d = e2.getAncestor(l.id);
            if (d)
              u = d;
            else if (u = new _2(e2), g.compileSchema.call(this, u, l)) {
              var f = this.options;
              try {
                this.options = l.__$validationOptions || this.options, y.validateSchema.call(this, u, l);
              } finally {
                this.options = f;
              }
            }
            var c = u.isValid();
            if (c || e2.addError("REMOTE_NOT_VALID", [t2], u), e2.path.pop(), !c)
              return;
          }
          if (l && s)
            for (var p = s.split("/"), h = 0, m = p.length; l && h < m; h++) {
              var v = (a2 = p[h], decodeURIComponent(a2).replace(/~[0-1]/g, function(e3) {
                return "~1" === e3 ? "/" : "~";
              }));
              l = 0 === h ? A(l, v) : l[v];
            }
          return l;
        }, r.getRemotePath = E;
      }, { "./Report": 109, "./SchemaCompilation": 111, "./SchemaValidation": 112, "./Utils": 113, "lodash.isequal": 2 }], 111: [function(e, t, _2) {
        "use strict";
        var g = e("./Report"), y = e("./SchemaCache"), E = e("./Utils");
        function A(e2, t2) {
          if (E.isAbsoluteUri(t2))
            return t2;
          var r, i = e2.join(""), n = E.isAbsoluteUri(i), a = E.isRelativeUri(i), o = E.isRelativeUri(t2);
          n && o ? (r = i.match(/\/[^\/]*$/)) && (i = i.slice(0, r.index + 1)) : a && o ? i = "" : (r = i.match(/[^#/]+$/)) && (i = i.slice(0, r.index));
          var s = i + t2;
          return s = s.replace(/##/, "#");
        }
        var S = function(e2, t2) {
          for (var r = t2.length, i = 0; r--; ) {
            var n = new g(e2);
            _2.compileSchema.call(this, n, t2[r]) && i++, e2.errors = e2.errors.concat(n.errors);
          }
          return i;
        };
        function b(e2, t2) {
          for (var r = e2.length; r--; )
            if (e2[r].id === t2)
              return e2[r];
          return null;
        }
        _2.compileSchema = function(e2, t2) {
          if (e2.commonErrorMessage = "SCHEMA_COMPILATION_FAILED", "string" == typeof t2) {
            var r = y.getSchemaByUri.call(this, e2, t2);
            if (!r)
              return e2.addError("SCHEMA_NOT_REACHABLE", [t2]), false;
            t2 = r;
          }
          if (Array.isArray(t2))
            return function(e3, t3) {
              var r2, i2 = 0;
              do {
                for (var n2 = e3.errors.length; n2--; )
                  "UNRESOLVABLE_REFERENCE" === e3.errors[n2].code && e3.errors.splice(n2, 1);
                for (r2 = i2, i2 = S.call(this, e3, t3), n2 = t3.length; n2--; ) {
                  var a2 = t3[n2];
                  if (a2.__$missingReferences) {
                    for (var o2 = a2.__$missingReferences.length; o2--; ) {
                      var s2 = a2.__$missingReferences[o2], l2 = b(t3, s2.ref);
                      l2 && (s2.obj["__" + s2.key + "Resolved"] = l2, a2.__$missingReferences.splice(o2, 1));
                    }
                    0 === a2.__$missingReferences.length && delete a2.__$missingReferences;
                  }
                }
              } while (i2 !== t3.length && i2 !== r2);
              return e3.isValid();
            }.call(this, e2, t2);
          if (t2.__$compiled && t2.id && false === y.checkCacheForUri.call(this, t2.id) && (t2.__$compiled = void 0), t2.__$compiled)
            return true;
          t2.id && "string" == typeof t2.id && y.cacheSchemaByUri.call(this, t2.id, t2);
          var i = false;
          e2.rootSchema || (e2.rootSchema = t2, i = true);
          var n = e2.isValid();
          delete t2.__$missingReferences;
          for (var a = function e3(t3, r2, i2, n2) {
            if (r2 = r2 || [], i2 = i2 || [], n2 = n2 || [], "object" != typeof t3 || null === t3)
              return r2;
            var a2;
            if ("string" == typeof t3.id && i2.push(t3.id), "string" == typeof t3.$ref && void 0 === t3.__$refResolved && r2.push({ ref: A(i2, t3.$ref), key: "$ref", obj: t3, path: n2.slice(0) }), "string" == typeof t3.$schema && void 0 === t3.__$schemaResolved && r2.push({ ref: A(i2, t3.$schema), key: "$schema", obj: t3, path: n2.slice(0) }), Array.isArray(t3))
              for (a2 = t3.length; a2--; )
                n2.push(a2.toString()), e3(t3[a2], r2, i2, n2), n2.pop();
            else {
              var o2 = Object.keys(t3);
              for (a2 = o2.length; a2--; )
                0 !== o2[a2].indexOf("__$") && (n2.push(o2[a2]), e3(t3[o2[a2]], r2, i2, n2), n2.pop());
            }
            return "string" == typeof t3.id && i2.pop(), r2;
          }.call(this, t2), o = a.length; o--; ) {
            var s = a[o], l = y.getSchemaByUri.call(this, e2, s.ref, t2);
            if (!l) {
              var u = this.getSchemaReader();
              if (u) {
                var d = u(s.ref);
                if (d) {
                  d.id = s.ref;
                  var f = new g(e2);
                  _2.compileSchema.call(this, f, d) ? l = y.getSchemaByUri.call(this, e2, s.ref, t2) : e2.errors = e2.errors.concat(f.errors);
                }
              }
            }
            if (!l) {
              var c = e2.hasError("REMOTE_NOT_VALID", [s.ref]), p = E.isAbsoluteUri(s.ref), h = false, m = true === this.options.ignoreUnresolvableReferences;
              p && (h = y.checkCacheForUri.call(this, s.ref)), c || m && p || h || (Array.prototype.push.apply(e2.path, s.path), e2.addError("UNRESOLVABLE_REFERENCE", [s.ref]), e2.path = e2.path.slice(0, -s.path.length), n && (t2.__$missingReferences = t2.__$missingReferences || [], t2.__$missingReferences.push(s)));
            }
            s.obj["__" + s.key + "Resolved"] = l;
          }
          var v = e2.isValid();
          return v ? t2.__$compiled = true : t2.id && "string" == typeof t2.id && y.removeFromCacheByUri.call(this, t2.id), i && (e2.rootSchema = void 0), v;
        };
      }, { "./Report": 109, "./SchemaCache": 110, "./Utils": 113 }], 112: [function(e, t, d) {
        "use strict";
        var r = e("./FormatValidators"), f = e("./JsonValidation"), c = e("./Report"), p = e("./Utils"), h = { $ref: function(e2, t2) {
          "string" != typeof t2.$ref && e2.addError("KEYWORD_TYPE_EXPECTED", ["$ref", "string"]);
        }, $schema: function(e2, t2) {
          "string" != typeof t2.$schema && e2.addError("KEYWORD_TYPE_EXPECTED", ["$schema", "string"]);
        }, multipleOf: function(e2, t2) {
          "number" != typeof t2.multipleOf ? e2.addError("KEYWORD_TYPE_EXPECTED", ["multipleOf", "number"]) : t2.multipleOf <= 0 && e2.addError("KEYWORD_MUST_BE", ["multipleOf", "strictly greater than 0"]);
        }, maximum: function(e2, t2) {
          "number" != typeof t2.maximum && e2.addError("KEYWORD_TYPE_EXPECTED", ["maximum", "number"]);
        }, exclusiveMaximum: function(e2, t2) {
          "boolean" != typeof t2.exclusiveMaximum ? e2.addError("KEYWORD_TYPE_EXPECTED", ["exclusiveMaximum", "boolean"]) : void 0 === t2.maximum && e2.addError("KEYWORD_DEPENDENCY", ["exclusiveMaximum", "maximum"]);
        }, minimum: function(e2, t2) {
          "number" != typeof t2.minimum && e2.addError("KEYWORD_TYPE_EXPECTED", ["minimum", "number"]);
        }, exclusiveMinimum: function(e2, t2) {
          "boolean" != typeof t2.exclusiveMinimum ? e2.addError("KEYWORD_TYPE_EXPECTED", ["exclusiveMinimum", "boolean"]) : void 0 === t2.minimum && e2.addError("KEYWORD_DEPENDENCY", ["exclusiveMinimum", "minimum"]);
        }, maxLength: function(e2, t2) {
          "integer" !== p.whatIs(t2.maxLength) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["maxLength", "integer"]) : t2.maxLength < 0 && e2.addError("KEYWORD_MUST_BE", ["maxLength", "greater than, or equal to 0"]);
        }, minLength: function(e2, t2) {
          "integer" !== p.whatIs(t2.minLength) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["minLength", "integer"]) : t2.minLength < 0 && e2.addError("KEYWORD_MUST_BE", ["minLength", "greater than, or equal to 0"]);
        }, pattern: function(t2, r2) {
          if ("string" != typeof r2.pattern)
            t2.addError("KEYWORD_TYPE_EXPECTED", ["pattern", "string"]);
          else
            try {
              RegExp(r2.pattern);
            } catch (e2) {
              t2.addError("KEYWORD_PATTERN", ["pattern", r2.pattern]);
            }
        }, additionalItems: function(e2, t2) {
          var r2 = p.whatIs(t2.additionalItems);
          "boolean" !== r2 && "object" !== r2 ? e2.addError("KEYWORD_TYPE_EXPECTED", ["additionalItems", ["boolean", "object"]]) : "object" === r2 && (e2.path.push("additionalItems"), d.validateSchema.call(this, e2, t2.additionalItems), e2.path.pop());
        }, items: function(e2, t2) {
          var r2 = p.whatIs(t2.items);
          if ("object" === r2)
            e2.path.push("items"), d.validateSchema.call(this, e2, t2.items), e2.path.pop();
          else if ("array" === r2)
            for (var i = t2.items.length; i--; )
              e2.path.push("items"), e2.path.push(i.toString()), d.validateSchema.call(this, e2, t2.items[i]), e2.path.pop(), e2.path.pop();
          else
            e2.addError("KEYWORD_TYPE_EXPECTED", ["items", ["array", "object"]]);
          true === this.options.forceAdditional && void 0 === t2.additionalItems && Array.isArray(t2.items) && e2.addError("KEYWORD_UNDEFINED_STRICT", ["additionalItems"]), this.options.assumeAdditional && void 0 === t2.additionalItems && Array.isArray(t2.items) && (t2.additionalItems = false);
        }, maxItems: function(e2, t2) {
          "number" != typeof t2.maxItems ? e2.addError("KEYWORD_TYPE_EXPECTED", ["maxItems", "integer"]) : t2.maxItems < 0 && e2.addError("KEYWORD_MUST_BE", ["maxItems", "greater than, or equal to 0"]);
        }, minItems: function(e2, t2) {
          "integer" !== p.whatIs(t2.minItems) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["minItems", "integer"]) : t2.minItems < 0 && e2.addError("KEYWORD_MUST_BE", ["minItems", "greater than, or equal to 0"]);
        }, uniqueItems: function(e2, t2) {
          "boolean" != typeof t2.uniqueItems && e2.addError("KEYWORD_TYPE_EXPECTED", ["uniqueItems", "boolean"]);
        }, maxProperties: function(e2, t2) {
          "integer" !== p.whatIs(t2.maxProperties) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["maxProperties", "integer"]) : t2.maxProperties < 0 && e2.addError("KEYWORD_MUST_BE", ["maxProperties", "greater than, or equal to 0"]);
        }, minProperties: function(e2, t2) {
          "integer" !== p.whatIs(t2.minProperties) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["minProperties", "integer"]) : t2.minProperties < 0 && e2.addError("KEYWORD_MUST_BE", ["minProperties", "greater than, or equal to 0"]);
        }, required: function(e2, t2) {
          if ("array" !== p.whatIs(t2.required))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["required", "array"]);
          else if (0 === t2.required.length)
            e2.addError("KEYWORD_MUST_BE", ["required", "an array with at least one element"]);
          else {
            for (var r2 = t2.required.length; r2--; )
              "string" != typeof t2.required[r2] && e2.addError("KEYWORD_VALUE_TYPE", ["required", "string"]);
            false === p.isUniqueArray(t2.required) && e2.addError("KEYWORD_MUST_BE", ["required", "an array with unique items"]);
          }
        }, additionalProperties: function(e2, t2) {
          var r2 = p.whatIs(t2.additionalProperties);
          "boolean" !== r2 && "object" !== r2 ? e2.addError("KEYWORD_TYPE_EXPECTED", ["additionalProperties", ["boolean", "object"]]) : "object" === r2 && (e2.path.push("additionalProperties"), d.validateSchema.call(this, e2, t2.additionalProperties), e2.path.pop());
        }, properties: function(e2, t2) {
          if ("object" === p.whatIs(t2.properties)) {
            for (var r2 = Object.keys(t2.properties), i = r2.length; i--; ) {
              var n = r2[i], a = t2.properties[n];
              e2.path.push("properties"), e2.path.push(n), d.validateSchema.call(this, e2, a), e2.path.pop(), e2.path.pop();
            }
            true === this.options.forceAdditional && void 0 === t2.additionalProperties && e2.addError("KEYWORD_UNDEFINED_STRICT", ["additionalProperties"]), this.options.assumeAdditional && void 0 === t2.additionalProperties && (t2.additionalProperties = false), true === this.options.forceProperties && 0 === r2.length && e2.addError("CUSTOM_MODE_FORCE_PROPERTIES", ["properties"]);
          } else
            e2.addError("KEYWORD_TYPE_EXPECTED", ["properties", "object"]);
        }, patternProperties: function(t2, e2) {
          if ("object" === p.whatIs(e2.patternProperties)) {
            for (var r2 = Object.keys(e2.patternProperties), i = r2.length; i--; ) {
              var n = r2[i], a = e2.patternProperties[n];
              try {
                RegExp(n);
              } catch (e3) {
                t2.addError("KEYWORD_PATTERN", ["patternProperties", n]);
              }
              t2.path.push("patternProperties"), t2.path.push(n.toString()), d.validateSchema.call(this, t2, a), t2.path.pop(), t2.path.pop();
            }
            true === this.options.forceProperties && 0 === r2.length && t2.addError("CUSTOM_MODE_FORCE_PROPERTIES", ["patternProperties"]);
          } else
            t2.addError("KEYWORD_TYPE_EXPECTED", ["patternProperties", "object"]);
        }, dependencies: function(e2, t2) {
          if ("object" !== p.whatIs(t2.dependencies))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["dependencies", "object"]);
          else
            for (var r2 = Object.keys(t2.dependencies), i = r2.length; i--; ) {
              var n = r2[i], a = t2.dependencies[n], o = p.whatIs(a);
              if ("object" === o)
                e2.path.push("dependencies"), e2.path.push(n), d.validateSchema.call(this, e2, a), e2.path.pop(), e2.path.pop();
              else if ("array" === o) {
                var s = a.length;
                for (0 === s && e2.addError("KEYWORD_MUST_BE", ["dependencies", "not empty array"]); s--; )
                  "string" != typeof a[s] && e2.addError("KEYWORD_VALUE_TYPE", ["dependensices", "string"]);
                false === p.isUniqueArray(a) && e2.addError("KEYWORD_MUST_BE", ["dependencies", "an array with unique items"]);
              } else
                e2.addError("KEYWORD_VALUE_TYPE", ["dependencies", "object or array"]);
            }
        }, enum: function(e2, t2) {
          false === Array.isArray(t2.enum) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["enum", "array"]) : 0 === t2.enum.length ? e2.addError("KEYWORD_MUST_BE", ["enum", "an array with at least one element"]) : false === p.isUniqueArray(t2.enum) && e2.addError("KEYWORD_MUST_BE", ["enum", "an array with unique elements"]);
        }, type: function(e2, t2) {
          var r2 = ["array", "boolean", "integer", "number", "null", "object", "string"], i = r2.join(","), n = Array.isArray(t2.type);
          if (n) {
            for (var a = t2.type.length; a--; )
              -1 === r2.indexOf(t2.type[a]) && e2.addError("KEYWORD_TYPE_EXPECTED", ["type", i]);
            false === p.isUniqueArray(t2.type) && e2.addError("KEYWORD_MUST_BE", ["type", "an object with unique properties"]);
          } else
            "string" == typeof t2.type ? -1 === r2.indexOf(t2.type) && e2.addError("KEYWORD_TYPE_EXPECTED", ["type", i]) : e2.addError("KEYWORD_TYPE_EXPECTED", ["type", ["string", "array"]]);
          true === this.options.noEmptyStrings && ("string" === t2.type || n && -1 !== t2.type.indexOf("string")) && void 0 === t2.minLength && void 0 === t2.enum && void 0 === t2.format && (t2.minLength = 1), true === this.options.noEmptyArrays && ("array" === t2.type || n && -1 !== t2.type.indexOf("array")) && void 0 === t2.minItems && (t2.minItems = 1), true === this.options.forceProperties && ("object" === t2.type || n && -1 !== t2.type.indexOf("object")) && void 0 === t2.properties && void 0 === t2.patternProperties && e2.addError("KEYWORD_UNDEFINED_STRICT", ["properties"]), true === this.options.forceItems && ("array" === t2.type || n && -1 !== t2.type.indexOf("array")) && void 0 === t2.items && e2.addError("KEYWORD_UNDEFINED_STRICT", ["items"]), true === this.options.forceMinItems && ("array" === t2.type || n && -1 !== t2.type.indexOf("array")) && void 0 === t2.minItems && e2.addError("KEYWORD_UNDEFINED_STRICT", ["minItems"]), true === this.options.forceMaxItems && ("array" === t2.type || n && -1 !== t2.type.indexOf("array")) && void 0 === t2.maxItems && e2.addError("KEYWORD_UNDEFINED_STRICT", ["maxItems"]), true === this.options.forceMinLength && ("string" === t2.type || n && -1 !== t2.type.indexOf("string")) && void 0 === t2.minLength && void 0 === t2.format && void 0 === t2.enum && void 0 === t2.pattern && e2.addError("KEYWORD_UNDEFINED_STRICT", ["minLength"]), true === this.options.forceMaxLength && ("string" === t2.type || n && -1 !== t2.type.indexOf("string")) && void 0 === t2.maxLength && void 0 === t2.format && void 0 === t2.enum && void 0 === t2.pattern && e2.addError("KEYWORD_UNDEFINED_STRICT", ["maxLength"]);
        }, allOf: function(e2, t2) {
          if (false === Array.isArray(t2.allOf))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["allOf", "array"]);
          else if (0 === t2.allOf.length)
            e2.addError("KEYWORD_MUST_BE", ["allOf", "an array with at least one element"]);
          else
            for (var r2 = t2.allOf.length; r2--; )
              e2.path.push("allOf"), e2.path.push(r2.toString()), d.validateSchema.call(this, e2, t2.allOf[r2]), e2.path.pop(), e2.path.pop();
        }, anyOf: function(e2, t2) {
          if (false === Array.isArray(t2.anyOf))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["anyOf", "array"]);
          else if (0 === t2.anyOf.length)
            e2.addError("KEYWORD_MUST_BE", ["anyOf", "an array with at least one element"]);
          else
            for (var r2 = t2.anyOf.length; r2--; )
              e2.path.push("anyOf"), e2.path.push(r2.toString()), d.validateSchema.call(this, e2, t2.anyOf[r2]), e2.path.pop(), e2.path.pop();
        }, oneOf: function(e2, t2) {
          if (false === Array.isArray(t2.oneOf))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["oneOf", "array"]);
          else if (0 === t2.oneOf.length)
            e2.addError("KEYWORD_MUST_BE", ["oneOf", "an array with at least one element"]);
          else
            for (var r2 = t2.oneOf.length; r2--; )
              e2.path.push("oneOf"), e2.path.push(r2.toString()), d.validateSchema.call(this, e2, t2.oneOf[r2]), e2.path.pop(), e2.path.pop();
        }, not: function(e2, t2) {
          "object" !== p.whatIs(t2.not) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["not", "object"]) : (e2.path.push("not"), d.validateSchema.call(this, e2, t2.not), e2.path.pop());
        }, definitions: function(e2, t2) {
          if ("object" !== p.whatIs(t2.definitions))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["definitions", "object"]);
          else
            for (var r2 = Object.keys(t2.definitions), i = r2.length; i--; ) {
              var n = r2[i], a = t2.definitions[n];
              e2.path.push("definitions"), e2.path.push(n), d.validateSchema.call(this, e2, a), e2.path.pop(), e2.path.pop();
            }
        }, format: function(e2, t2) {
          "string" != typeof t2.format ? e2.addError("KEYWORD_TYPE_EXPECTED", ["format", "string"]) : void 0 === r[t2.format] && true !== this.options.ignoreUnknownFormats && e2.addError("UNKNOWN_FORMAT", [t2.format]);
        }, id: function(e2, t2) {
          "string" != typeof t2.id && e2.addError("KEYWORD_TYPE_EXPECTED", ["id", "string"]);
        }, title: function(e2, t2) {
          "string" != typeof t2.title && e2.addError("KEYWORD_TYPE_EXPECTED", ["title", "string"]);
        }, description: function(e2, t2) {
          "string" != typeof t2.description && e2.addError("KEYWORD_TYPE_EXPECTED", ["description", "string"]);
        }, default: function() {
        } };
        d.validateSchema = function(e2, t2) {
          if (e2.commonErrorMessage = "SCHEMA_VALIDATION_FAILED", Array.isArray(t2))
            return function(e3, t3) {
              for (var r3 = t3.length; r3--; )
                d.validateSchema.call(this, e3, t3[r3]);
              return e3.isValid();
            }.call(this, e2, t2);
          if (t2.__$validated)
            return true;
          var r2 = t2.$schema && t2.id !== t2.$schema;
          if (r2)
            if (t2.__$schemaResolved && t2.__$schemaResolved !== t2) {
              var i = new c(e2);
              false === f.validate.call(this, i, t2.__$schemaResolved, t2) && e2.addError("PARENT_SCHEMA_VALIDATION_FAILED", null, i);
            } else
              true !== this.options.ignoreUnresolvableReferences && e2.addError("REF_UNRESOLVED", [t2.$schema]);
          if (true === this.options.noTypeless) {
            if (void 0 !== t2.type) {
              var n = [];
              Array.isArray(t2.anyOf) && (n = n.concat(t2.anyOf)), Array.isArray(t2.oneOf) && (n = n.concat(t2.oneOf)), Array.isArray(t2.allOf) && (n = n.concat(t2.allOf)), n.forEach(function(e3) {
                e3.type || (e3.type = t2.type);
              });
            }
            void 0 === t2.enum && void 0 === t2.type && void 0 === t2.anyOf && void 0 === t2.oneOf && void 0 === t2.not && void 0 === t2.$ref && e2.addError("KEYWORD_UNDEFINED_STRICT", ["type"]);
          }
          for (var a = Object.keys(t2), o = a.length; o--; ) {
            var s = a[o];
            0 !== s.indexOf("__") && (void 0 !== h[s] ? h[s].call(this, e2, t2) : r2 || true === this.options.noExtraKeywords && e2.addError("KEYWORD_UNEXPECTED", [s]));
          }
          if (true === this.options.pedanticCheck) {
            if (t2.enum) {
              var l = p.clone(t2);
              for (delete l.enum, delete l.default, e2.path.push("enum"), o = t2.enum.length; o--; )
                e2.path.push(o.toString()), f.validate.call(this, e2, l, t2.enum[o]), e2.path.pop();
              e2.path.pop();
            }
            t2.default && (e2.path.push("default"), f.validate.call(this, e2, t2, t2.default), e2.path.pop());
          }
          var u = e2.isValid();
          return u && (t2.__$validated = true), u;
        };
      }, { "./FormatValidators": 106, "./JsonValidation": 107, "./Report": 109, "./Utils": 113 }], 113: [function(e, t, l) {
        "use strict";
        l.jsonSymbol = Symbol.for("z-schema/json"), l.schemaSymbol = Symbol.for("z-schema/schema");
        var u = l.sortedKeys = function(e2) {
          return Object.keys(e2).sort();
        };
        l.isAbsoluteUri = function(e2) {
          return /^https?:\/\//.test(e2);
        }, l.isRelativeUri = function(e2) {
          return /.+#/.test(e2);
        }, l.whatIs = function(e2) {
          var t2 = typeof e2;
          return "object" === t2 ? null === e2 ? "null" : Array.isArray(e2) ? "array" : "object" : "number" === t2 ? Number.isFinite(e2) ? e2 % 1 == 0 ? "integer" : "number" : Number.isNaN(e2) ? "not-a-number" : "unknown-number" : t2;
        }, l.areEqual = function e2(t2, r, i) {
          var n, a, o = (i = i || {}).caseInsensitiveComparison || false;
          if (t2 === r)
            return true;
          if (true === o && "string" == typeof t2 && "string" == typeof r && t2.toUpperCase() === r.toUpperCase())
            return true;
          if (Array.isArray(t2) && Array.isArray(r)) {
            if (t2.length !== r.length)
              return false;
            for (a = t2.length, n = 0; n < a; n++)
              if (!e2(t2[n], r[n], { caseInsensitiveComparison: o }))
                return false;
            return true;
          }
          if ("object" !== l.whatIs(t2) || "object" !== l.whatIs(r))
            return false;
          var s = u(t2);
          if (!e2(s, u(r), { caseInsensitiveComparison: o }))
            return false;
          for (a = s.length, n = 0; n < a; n++)
            if (!e2(t2[s[n]], r[s[n]], { caseInsensitiveComparison: o }))
              return false;
          return true;
        }, l.isUniqueArray = function(e2, t2) {
          var r, i, n = e2.length;
          for (r = 0; r < n; r++)
            for (i = r + 1; i < n; i++)
              if (l.areEqual(e2[r], e2[i]))
                return t2 && t2.push(r, i), false;
          return true;
        }, l.difference = function(e2, t2) {
          for (var r = [], i = e2.length; i--; )
            -1 === t2.indexOf(e2[i]) && r.push(e2[i]);
          return r;
        }, l.clone = function(e2) {
          if (void 0 !== e2) {
            if ("object" != typeof e2 || null === e2)
              return e2;
            var t2, r;
            if (Array.isArray(e2))
              for (t2 = [], r = e2.length; r--; )
                t2[r] = e2[r];
            else {
              t2 = {};
              var i = Object.keys(e2);
              for (r = i.length; r--; ) {
                var n = i[r];
                t2[n] = e2[n];
              }
            }
            return t2;
          }
        }, l.cloneDeep = function(e2) {
          var s = 0, l2 = /* @__PURE__ */ new Map(), u2 = [];
          return function e3(t2) {
            if ("object" != typeof t2 || null === t2)
              return t2;
            var r, i, n;
            if (void 0 !== (n = l2.get(t2)))
              return u2[n];
            if (l2.set(t2, s++), Array.isArray(t2))
              for (r = [], u2.push(r), i = t2.length; i--; )
                r[i] = e3(t2[i]);
            else {
              r = {}, u2.push(r);
              var a = Object.keys(t2);
              for (i = a.length; i--; ) {
                var o = a[i];
                r[o] = e3(t2[o]);
              }
            }
            return r;
          }(e2);
        }, l.ucs2decode = function(e2) {
          for (var t2, r, i = [], n = 0, a = e2.length; n < a; )
            55296 <= (t2 = e2.charCodeAt(n++)) && t2 <= 56319 && n < a ? 56320 == (64512 & (r = e2.charCodeAt(n++))) ? i.push(((1023 & t2) << 10) + (1023 & r) + 65536) : (i.push(t2), n--) : i.push(t2);
          return i;
        };
      }, {}], 114: [function(e, s, t) {
        (function(g) {
          (function() {
            "use strict";
            e("./Polyfills");
            var f = e("lodash.get"), c = e("./Report"), r = e("./FormatValidators"), p = e("./JsonValidation"), h = e("./SchemaCache"), m = e("./SchemaCompilation"), v = e("./SchemaValidation"), _2 = e("./Utils"), i = e("./schemas/schema.json"), n = e("./schemas/hyper-schema.json"), a = { asyncTimeout: 2e3, forceAdditional: false, assumeAdditional: false, enumCaseInsensitiveComparison: false, forceItems: false, forceMinItems: false, forceMaxItems: false, forceMinLength: false, forceMaxLength: false, forceProperties: false, ignoreUnresolvableReferences: false, noExtraKeywords: false, noTypeless: false, noEmptyStrings: false, noEmptyArrays: false, strictUris: false, strictMode: false, reportPathAsArray: false, breakOnFirstError: false, pedanticCheck: false, ignoreUnknownFormats: false, customValidator: null };
            function o(e2) {
              var t3;
              if ("object" == typeof e2) {
                for (var r2, i2 = Object.keys(e2), n2 = i2.length; n2--; )
                  if (r2 = i2[n2], void 0 === a[r2])
                    throw new Error("Unexpected option passed to constructor: " + r2);
                for (n2 = (i2 = Object.keys(a)).length; n2--; )
                  void 0 === e2[r2 = i2[n2]] && (e2[r2] = _2.clone(a[r2]));
                t3 = e2;
              } else
                t3 = _2.clone(a);
              return true === t3.strictMode && (t3.forceAdditional = true, t3.forceItems = true, t3.forceMaxLength = true, t3.forceProperties = true, t3.noExtraKeywords = true, t3.noTypeless = true, t3.noEmptyStrings = true, t3.noEmptyArrays = true), t3;
            }
            function t2(e2) {
              this.cache = {}, this.referenceCache = [], this.validateOptions = {}, this.options = o(e2);
              var t3 = o({});
              this.setRemoteReference("http://json-schema.org/draft-04/schema", i, t3), this.setRemoteReference("http://json-schema.org/draft-04/hyper-schema", n, t3);
            }
            t2.prototype.compileSchema = function(e2) {
              var t3 = new c(this.options);
              return e2 = h.getSchema.call(this, t3, e2), m.compileSchema.call(this, t3, e2), (this.lastReport = t3).isValid();
            }, t2.prototype.validateSchema = function(e2) {
              if (Array.isArray(e2) && 0 === e2.length)
                throw new Error(".validateSchema was called with an empty array");
              var t3 = new c(this.options);
              return e2 = h.getSchema.call(this, t3, e2), m.compileSchema.call(this, t3, e2) && v.validateSchema.call(this, t3, e2), (this.lastReport = t3).isValid();
            }, t2.prototype.validate = function(e2, t3, r2, i2) {
              "function" === _2.whatIs(r2) && (i2 = r2, r2 = {}), r2 || (r2 = {}), this.validateOptions = r2;
              var n2 = _2.whatIs(t3);
              if ("string" !== n2 && "object" !== n2) {
                var a2 = new Error("Invalid .validate call - schema must be a string or object but " + n2 + " was passed!");
                if (i2)
                  return void g.nextTick(function() {
                    i2(a2, false);
                  });
                throw a2;
              }
              var o2 = false, s2 = new c(this.options);
              if (s2.json = e2, "string" == typeof t3) {
                var l = t3;
                if (!(t3 = h.getSchema.call(this, s2, l)))
                  throw new Error("Schema with id '" + l + "' wasn't found in the validator cache!");
              } else
                t3 = h.getSchema.call(this, s2, t3);
              var u = false;
              o2 || (u = m.compileSchema.call(this, s2, t3)), u || (this.lastReport = s2, o2 = true);
              var d = false;
              if (o2 || (d = v.validateSchema.call(this, s2, t3)), d || (this.lastReport = s2, o2 = true), r2.schemaPath && (s2.rootSchema = t3, !(t3 = f(t3, r2.schemaPath))))
                throw new Error("Schema path '" + r2.schemaPath + "' wasn't found in the schema!");
              if (o2 || p.validate.call(this, s2, t3, e2), !i2) {
                if (0 < s2.asyncTasks.length)
                  throw new Error("This validation has async tasks and cannot be done in sync mode, please provide callback argument.");
                return (this.lastReport = s2).isValid();
              }
              s2.processAsyncTasks(this.options.asyncTimeout, i2);
            }, t2.prototype.getLastError = function() {
              if (0 === this.lastReport.errors.length)
                return null;
              var e2 = new Error();
              return e2.name = "z-schema validation error", e2.message = this.lastReport.commonErrorMessage, e2.details = this.lastReport.errors, e2;
            }, t2.prototype.getLastErrors = function() {
              return this.lastReport && 0 < this.lastReport.errors.length ? this.lastReport.errors : null;
            }, t2.prototype.getMissingReferences = function(e2) {
              for (var t3 = [], r2 = (e2 = e2 || this.lastReport.errors).length; r2--; ) {
                var i2 = e2[r2];
                if ("UNRESOLVABLE_REFERENCE" === i2.code) {
                  var n2 = i2.params[0];
                  -1 === t3.indexOf(n2) && t3.push(n2);
                }
                i2.inner && (t3 = t3.concat(this.getMissingReferences(i2.inner)));
              }
              return t3;
            }, t2.prototype.getMissingRemoteReferences = function() {
              for (var e2 = this.getMissingReferences(), t3 = [], r2 = e2.length; r2--; ) {
                var i2 = h.getRemotePath(e2[r2]);
                i2 && -1 === t3.indexOf(i2) && t3.push(i2);
              }
              return t3;
            }, t2.prototype.setRemoteReference = function(e2, t3, r2) {
              t3 = "string" == typeof t3 ? JSON.parse(t3) : _2.cloneDeep(t3), r2 && (t3.__$validationOptions = o(r2)), h.cacheSchemaByUri.call(this, e2, t3);
            }, t2.prototype.getResolvedSchema = function(e2) {
              var t3 = new c(this.options);
              e2 = h.getSchema.call(this, t3, e2), e2 = _2.cloneDeep(e2);
              var a2 = [], o2 = function(e3) {
                var t4, r2 = _2.whatIs(e3);
                if (("object" === r2 || "array" === r2) && !e3.___$visited) {
                  if (e3.___$visited = true, a2.push(e3), e3.$ref && e3.__$refResolved) {
                    var i2 = e3.__$refResolved, n2 = e3;
                    for (t4 in delete e3.$ref, delete e3.__$refResolved, i2)
                      i2.hasOwnProperty(t4) && (n2[t4] = i2[t4]);
                  }
                  for (t4 in e3)
                    e3.hasOwnProperty(t4) && (0 === t4.indexOf("__$") ? delete e3[t4] : o2(e3[t4]));
                }
              };
              if (o2(e2), a2.forEach(function(e3) {
                delete e3.___$visited;
              }), (this.lastReport = t3).isValid())
                return e2;
              throw this.getLastError();
            }, t2.prototype.setSchemaReader = function(e2) {
              return t2.setSchemaReader(e2);
            }, t2.prototype.getSchemaReader = function() {
              return t2.schemaReader;
            }, t2.schemaReader = void 0, t2.setSchemaReader = function(e2) {
              t2.schemaReader = e2;
            }, t2.registerFormat = function(e2, t3) {
              r[e2] = t3;
            }, t2.unregisterFormat = function(e2) {
              delete r[e2];
            }, t2.getRegisteredFormats = function() {
              return Object.keys(r);
            }, t2.getDefaultOptions = function() {
              return _2.cloneDeep(a);
            }, t2.schemaSymbol = _2.schemaSymbol, t2.jsonSymbol = _2.jsonSymbol, s.exports = t2;
          }).call(this);
        }).call(this, e("_process"));
      }, { "./FormatValidators": 106, "./JsonValidation": 107, "./Polyfills": 108, "./Report": 109, "./SchemaCache": 110, "./SchemaCompilation": 111, "./SchemaValidation": 112, "./Utils": 113, "./schemas/hyper-schema.json": 115, "./schemas/schema.json": 116, _process: 3, "lodash.get": 1 }], 115: [function(e, t, r) {
        t.exports = { $schema: "http://json-schema.org/draft-04/hyper-schema#", id: "http://json-schema.org/draft-04/hyper-schema#", title: "JSON Hyper-Schema", allOf: [{ $ref: "http://json-schema.org/draft-04/schema#" }], properties: { additionalItems: { anyOf: [{ type: "boolean" }, { $ref: "#" }] }, additionalProperties: { anyOf: [{ type: "boolean" }, { $ref: "#" }] }, dependencies: { additionalProperties: { anyOf: [{ $ref: "#" }, { type: "array" }] } }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }] }, definitions: { additionalProperties: { $ref: "#" } }, patternProperties: { additionalProperties: { $ref: "#" } }, properties: { additionalProperties: { $ref: "#" } }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" }, links: { type: "array", items: { $ref: "#/definitions/linkDescription" } }, fragmentResolution: { type: "string" }, media: { type: "object", properties: { type: { description: "A media type, as described in RFC 2046", type: "string" }, binaryEncoding: { description: "A content encoding scheme, as described in RFC 2045", type: "string" } } }, pathStart: { description: "Instances' URIs must start with this value for this schema to apply to them", type: "string", format: "uri" } }, definitions: { schemaArray: { type: "array", items: { $ref: "#" } }, linkDescription: { title: "Link Description Object", type: "object", required: ["href", "rel"], properties: { href: { description: "a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing", type: "string" }, rel: { description: "relation to the target resource of the link", type: "string" }, title: { description: "a title for the link", type: "string" }, targetSchema: { description: "JSON Schema describing the link target", $ref: "#" }, mediaType: { description: "media type (as defined by RFC 2046) describing the link target", type: "string" }, method: { description: 'method for requesting the target of the link (e.g. for HTTP this might be "GET" or "DELETE")', type: "string" }, encType: { description: "The media type in which to submit data along with the request", type: "string", default: "application/json" }, schema: { description: "Schema describing the data to submit along with the request", $ref: "#" } } } } };
      }, {}], 116: [function(e, t, r) {
        t.exports = { id: "http://json-schema.org/draft-04/schema#", $schema: "http://json-schema.org/draft-04/schema#", description: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, positiveInteger: { type: "integer", minimum: 0 }, positiveIntegerDefault0: { allOf: [{ $ref: "#/definitions/positiveInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, minItems: 1, uniqueItems: true } }, type: "object", properties: { id: { type: "string", format: "uri" }, $schema: { type: "string", format: "uri" }, title: { type: "string" }, description: { type: "string" }, default: {}, multipleOf: { type: "number", minimum: 0, exclusiveMinimum: true }, maximum: { type: "number" }, exclusiveMaximum: { type: "boolean", default: false }, minimum: { type: "number" }, exclusiveMinimum: { type: "boolean", default: false }, maxLength: { $ref: "#/definitions/positiveInteger" }, minLength: { $ref: "#/definitions/positiveIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { anyOf: [{ type: "boolean" }, { $ref: "#" }], default: {} }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: {} }, maxItems: { $ref: "#/definitions/positiveInteger" }, minItems: { $ref: "#/definitions/positiveIntegerDefault0" }, uniqueItems: { type: "boolean", default: false }, maxProperties: { $ref: "#/definitions/positiveInteger" }, minProperties: { $ref: "#/definitions/positiveIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { anyOf: [{ type: "boolean" }, { $ref: "#" }], default: {} }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, enum: { type: "array", minItems: 1, uniqueItems: true }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: true }] }, format: { type: "string" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, dependencies: { exclusiveMaximum: ["maximum"], exclusiveMinimum: ["minimum"] }, default: {} };
      }, {}] }, {}, [105, 106, 107, 108, 109, 110, 111, 112, 113, 114])(114);
    });
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/JsonSchema.js
var require_JsonSchema = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/JsonSchema.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonSchema = void 0;
    var os = __importStar(__require("os"));
    var path9 = __importStar(__require("path"));
    var JsonFile_1 = require_JsonFile();
    var FileSystem_1 = require_FileSystem();
    var Validator = require_ZSchema_browser_min();
    var JsonSchema = class _JsonSchema {
      constructor() {
        this._dependentSchemas = [];
        this._filename = "";
        this._validator = void 0;
        this._schemaObject = void 0;
      }
      /**
       * Registers a JsonSchema that will be loaded from a file on disk.
       * @remarks
       * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
       * until it the schema is actually used.
       */
      static fromFile(filename, options) {
        if (!FileSystem_1.FileSystem.exists(filename)) {
          throw new Error("Schema file not found: " + filename);
        }
        const schema = new _JsonSchema();
        schema._filename = filename;
        if (options) {
          schema._dependentSchemas = options.dependentSchemas || [];
        }
        return schema;
      }
      /**
       * Registers a JsonSchema that will be loaded from a file on disk.
       * @remarks
       * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
       * until it the schema is actually used.
       */
      static fromLoadedObject(schemaObject) {
        const schema = new _JsonSchema();
        schema._schemaObject = schemaObject;
        return schema;
      }
      static _collectDependentSchemas(collectedSchemas, dependentSchemas, seenObjects, seenIds) {
        for (const dependentSchema of dependentSchemas) {
          if (seenObjects.has(dependentSchema)) {
            continue;
          }
          seenObjects.add(dependentSchema);
          const schemaId = dependentSchema._ensureLoaded();
          if (schemaId === "") {
            throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced because is missing the "id" field`);
          }
          if (seenIds.has(schemaId)) {
            throw new Error(`This schema ${dependentSchema.shortName} has the same "id" as another schema in this set`);
          }
          seenIds.add(schemaId);
          collectedSchemas.push(dependentSchema);
          _JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas, seenObjects, seenIds);
        }
      }
      /**
       * Used to nicely format the ZSchema error tree.
       */
      static _formatErrorDetails(errorDetails) {
        return _JsonSchema._formatErrorDetailsHelper(errorDetails, "", "");
      }
      /**
       * Used by _formatErrorDetails.
       */
      static _formatErrorDetailsHelper(errorDetails, indent, buffer) {
        for (const errorDetail of errorDetails) {
          buffer += os.EOL + indent + `Error: ${errorDetail.path}`;
          if (errorDetail.description) {
            const MAX_LENGTH = 40;
            let truncatedDescription = errorDetail.description.trim();
            if (truncatedDescription.length > MAX_LENGTH) {
              truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3) + "...";
            }
            buffer += ` (${truncatedDescription})`;
          }
          buffer += os.EOL + indent + `       ${errorDetail.message}`;
          if (errorDetail.inner) {
            buffer = _JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + "  ", buffer);
          }
        }
        return buffer;
      }
      /**
       * Returns a short name for this schema, for use in error messages.
       * @remarks
       * If the schema was loaded from a file, then the base filename is used.  Otherwise, the "id"
       * field is used if available.
       */
      get shortName() {
        if (!this._filename) {
          if (this._schemaObject) {
            const schemaWithId = this._schemaObject;
            if (schemaWithId.id) {
              return schemaWithId.id;
            }
          }
          return "(anonymous schema)";
        } else {
          return path9.basename(this._filename);
        }
      }
      /**
       * If not already done, this loads the schema from disk and compiles it.
       * @remarks
       * Any dependencies will be compiled as well.
       */
      ensureCompiled() {
        this._ensureLoaded();
        if (!this._validator) {
          const newValidator = new Validator({
            breakOnFirstError: false,
            noTypeless: true,
            noExtraKeywords: true
          });
          const anythingSchema = {
            type: ["array", "boolean", "integer", "number", "object", "string"]
          };
          newValidator.setRemoteReference("http://json-schema.org/draft-04/schema", anythingSchema);
          const collectedSchemas = [];
          const seenObjects = /* @__PURE__ */ new Set();
          const seenIds = /* @__PURE__ */ new Set();
          _JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);
          for (const collectedSchema of collectedSchemas) {
            if (!newValidator.validateSchema(collectedSchema._schemaObject)) {
              throw new Error(`Failed to validate schema "${collectedSchema.shortName}":` + os.EOL + _JsonSchema._formatErrorDetails(newValidator.getLastErrors()));
            }
          }
          this._validator = newValidator;
        }
      }
      /**
       * Validates the specified JSON object against this JSON schema.  If the validation fails,
       * an exception will be thrown.
       * @param jsonObject - The JSON data to be validated
       * @param filenameForErrors - The filename that the JSON data was available, or an empty string
       *    if not applicable
       * @param options - Other options that control the validation
       */
      validateObject(jsonObject, filenameForErrors, options) {
        this.validateObjectWithCallback(jsonObject, (errorInfo) => {
          const prefix = options && options.customErrorHeader ? options.customErrorHeader : "JSON validation failed:";
          throw new Error(prefix + os.EOL + filenameForErrors + os.EOL + errorInfo.details);
        });
      }
      /**
       * Validates the specified JSON object against this JSON schema.  If the validation fails,
       * a callback is called for each validation error.
       */
      validateObjectWithCallback(jsonObject, errorCallback) {
        this.ensureCompiled();
        if (!this._validator.validate(jsonObject, this._schemaObject)) {
          const errorDetails = _JsonSchema._formatErrorDetails(this._validator.getLastErrors());
          const args = {
            details: errorDetails
          };
          errorCallback(args);
        }
      }
      _ensureLoaded() {
        if (!this._schemaObject) {
          this._schemaObject = JsonFile_1.JsonFile.load(this._filename);
        }
        return this._schemaObject.id || "";
      }
    };
    exports.JsonSchema = JsonSchema;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/FileWriter.js
var require_FileWriter = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/FileWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileWriter = void 0;
    var Import_1 = require_Import();
    var fsx = Import_1.Import.lazy("fs-extra", __require);
    var FileWriter = class _FileWriter {
      constructor(fileDescriptor, filePath) {
        this._fileDescriptor = fileDescriptor;
        this.filePath = filePath;
      }
      /**
       * Opens a new file handle to the file at the specified path and given mode.
       * Behind the scenes it uses `fs.openSync()`.
       * The behaviour of this function is platform specific.
       * See: https://nodejs.org/docs/latest-v8.x/api/fs.html#fs_fs_open_path_flags_mode_callback
       * @param filePath - The absolute or relative path to the file handle that should be opened.
       * @param flags - The flags for opening the handle
       */
      static open(filePath, flags) {
        return new _FileWriter(fsx.openSync(filePath, _FileWriter._convertFlagsForNode(flags)), filePath);
      }
      /**
       * Helper function to convert the file writer array to a Node.js style string (e.g. "wx" or "a").
       * @param flags - The flags that should be converted.
       */
      static _convertFlagsForNode(flags) {
        flags = Object.assign({ append: false, exclusive: false }, flags);
        return [flags.append ? "a" : "w", flags.exclusive ? "x" : ""].join("");
      }
      /**
       * Writes some text to the given file handle. Throws if the file handle has been closed.
       * Behind the scenes it uses `fs.writeSync()`.
       * @param text - The text to write to the file.
       */
      write(text) {
        if (!this._fileDescriptor) {
          throw new Error(`Cannot write to file, file descriptor has already been released.`);
        }
        fsx.writeSync(this._fileDescriptor, text);
      }
      /**
       * Closes the file handle permanently. No operations can be made on this file handle after calling this.
       * Behind the scenes it uses `fs.closeSync()` and releases the file descriptor to be re-used.
       *
       * @remarks
       * The `close()` method can be called more than once; additional calls are ignored.
       */
      close() {
        const fd = this._fileDescriptor;
        if (fd) {
          this._fileDescriptor = void 0;
          fsx.closeSync(fd);
        }
      }
      /**
       * Gets the statistics for the given file handle. Throws if the file handle has been closed.
       * Behind the scenes it uses `fs.statSync()`.
       */
      getStatistics() {
        if (!this._fileDescriptor) {
          throw new Error(`Cannot get file statistics, file descriptor has already been released.`);
        }
        return fsx.fstatSync(this._fileDescriptor);
      }
    };
    exports.FileWriter = FileWriter;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/LockFile.js
var require_LockFile = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/LockFile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LockFile = exports.getProcessStartTime = exports.getProcessStartTimeFromProcStat = void 0;
    var path9 = __importStar(__require("path"));
    var child_process = __importStar(__require("child_process"));
    var FileSystem_1 = require_FileSystem();
    var FileWriter_1 = require_FileWriter();
    var Async_1 = require_Async();
    var procStatStartTimePos = 22;
    function getProcessStartTimeFromProcStat(stat) {
      let values = stat.trimRight().split(" ");
      let i = values.length - 1;
      while (i >= 0 && // charAt returns an empty string if the index is out of bounds.
      values[i].charAt(values[i].length - 1) !== ")") {
        i -= 1;
      }
      if (i < 1) {
        return void 0;
      }
      const value2 = values.slice(1, i + 1).join(" ");
      values = [values[0], value2].concat(values.slice(i + 1));
      if (values.length < procStatStartTimePos) {
        return void 0;
      }
      const startTimeJiffies = values[procStatStartTimePos - 1];
      return startTimeJiffies;
    }
    exports.getProcessStartTimeFromProcStat = getProcessStartTimeFromProcStat;
    function getProcessStartTime(pid) {
      const pidString = pid.toString();
      if (pid < 0 || pidString.indexOf("e") >= 0 || pidString.indexOf("E") >= 0) {
        throw new Error(`"pid" is negative or too large`);
      }
      let args;
      if (process.platform === "darwin") {
        args = [`-p ${pidString}`, "-o lstart"];
      } else if (process.platform === "linux") {
        args = ["-p", pidString, "-o", "lstart"];
      } else {
        throw new Error(`Unsupported system: ${process.platform}`);
      }
      const psResult = child_process.spawnSync("ps", args, {
        encoding: "utf8"
      });
      const psStdout = psResult.stdout;
      if (psResult.status !== 0 && !psStdout && process.platform === "linux") {
        let stat;
        try {
          stat = FileSystem_1.FileSystem.readFile(`/proc/${pidString}/stat`);
        } catch (error) {
          if (error.code !== "ENOENT") {
            throw error;
          }
          return void 0;
        }
        if (stat !== void 0) {
          const startTimeJiffies = getProcessStartTimeFromProcStat(stat);
          if (startTimeJiffies === void 0) {
            throw new Error(`Could not retrieve the start time of process ${pidString} from the OS because the contents of /proc/${pidString}/stat have an unexpected format`);
          }
          return startTimeJiffies;
        }
      }
      if (!psStdout) {
        throw new Error(`Unexpected output from "ps" command`);
      }
      const psSplit = psStdout.split("\n");
      if (psSplit[1] === "") {
        return void 0;
      }
      if (psSplit[1]) {
        const trimmed = psSplit[1].trim();
        if (trimmed.length > 10) {
          return trimmed;
        }
      }
      throw new Error(`Unexpected output from the "ps" command`);
    }
    exports.getProcessStartTime = getProcessStartTime;
    var LockFile = class _LockFile {
      constructor(fileWriter, filePath, dirtyWhenAcquired) {
        this._fileWriter = fileWriter;
        this._filePath = filePath;
        this._dirtyWhenAcquired = dirtyWhenAcquired;
      }
      /**
       * Returns the path of the lockfile that will be created when a lock is successfully acquired.
       * @param resourceFolder - The folder where the lock file will be created
       * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
       *   the filename of the temporary file created to manage the lock.
       * @param pid - The PID for the current Node.js process (`process.pid`), which is used by the locking algorithm.
       */
      static getLockFilePath(resourceFolder, resourceName, pid = process.pid) {
        if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {
          throw new Error(`The resource name "${resourceName}" is invalid. It must be an alphanumberic string with only "-" or "." It must start with an alphanumeric character.`);
        }
        if (process.platform === "win32") {
          return path9.join(path9.resolve(resourceFolder), `${resourceName}.lock`);
        } else if (process.platform === "linux" || process.platform === "darwin") {
          return path9.join(path9.resolve(resourceFolder), `${resourceName}#${pid}.lock`);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
      }
      /**
       * Attempts to create a lockfile with the given filePath.
       * @param resourceFolder - The folder where the lock file will be created
       * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
       *   the filename of the temporary file created to manage the lock.
       * @returns If successful, returns a `LockFile` instance.  If unable to get a lock, returns `undefined`.
       */
      static tryAcquire(resourceFolder, resourceName) {
        FileSystem_1.FileSystem.ensureFolder(resourceFolder);
        if (process.platform === "win32") {
          return _LockFile._tryAcquireWindows(resourceFolder, resourceName);
        } else if (process.platform === "linux" || process.platform === "darwin") {
          return _LockFile._tryAcquireMacOrLinux(resourceFolder, resourceName);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
      }
      /**
       * Attempts to create the lockfile.  Will continue to loop at every 100ms until the lock becomes available
       * or the maxWaitMs is surpassed.
       *
       * @remarks
       * This function is subject to starvation, whereby it does not ensure that the process that has been
       * waiting the longest to acquire the lock will get it first. This means that a process could theoretically
       * wait for the lock forever, while other processes skipped it in line and acquired the lock first.
       *
       * @param resourceFolder - The folder where the lock file will be created
       * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
       *   the filename of the temporary file created to manage the lock.
       * @param maxWaitMs - The maximum number of milliseconds to wait for the lock before reporting an error
       */
      static acquire(resourceFolder, resourceName, maxWaitMs) {
        const interval = 100;
        const startTime = Date.now();
        const retryLoop = async () => {
          const lock = _LockFile.tryAcquire(resourceFolder, resourceName);
          if (lock) {
            return lock;
          }
          if (maxWaitMs && Date.now() > startTime + maxWaitMs) {
            throw new Error(`Exceeded maximum wait time to acquire lock for resource "${resourceName}"`);
          }
          await Async_1.Async.sleep(interval);
          return retryLoop();
        };
        return retryLoop();
      }
      /**
       * Attempts to acquire the lock on a Linux or OSX machine
       */
      static _tryAcquireMacOrLinux(resourceFolder, resourceName) {
        let dirtyWhenAcquired = false;
        const pid = process.pid;
        const startTime = _LockFile._getStartTime(pid);
        if (!startTime) {
          throw new Error(`Unable to calculate start time for current process.`);
        }
        const pidLockFilePath = _LockFile.getLockFilePath(resourceFolder, resourceName);
        let lockFileHandle;
        let lockFile;
        try {
          lockFileHandle = FileWriter_1.FileWriter.open(pidLockFilePath);
          lockFileHandle.write(startTime);
          const currentBirthTimeMs = lockFileHandle.getStatistics().birthtime.getTime();
          let smallestBirthTimeMs = currentBirthTimeMs;
          let smallestBirthTimePid = pid.toString();
          const files = FileSystem_1.FileSystem.readFolderItemNames(resourceFolder);
          const lockFileRegExp = /^(.+)#([0-9]+)\.lock$/;
          let match;
          let otherPid;
          for (const fileInFolder of files) {
            if ((match = fileInFolder.match(lockFileRegExp)) && match[1] === resourceName && (otherPid = match[2]) !== pid.toString()) {
              const fileInFolderPath = path9.join(resourceFolder, fileInFolder);
              dirtyWhenAcquired = true;
              const otherPidCurrentStartTime = _LockFile._getStartTime(parseInt(otherPid, 10));
              let otherPidOldStartTime;
              let otherBirthtimeMs;
              try {
                otherPidOldStartTime = FileSystem_1.FileSystem.readFile(fileInFolderPath);
                otherBirthtimeMs = FileSystem_1.FileSystem.getStatistics(fileInFolderPath).birthtime.getTime();
              } catch (error) {
                if (FileSystem_1.FileSystem.isNotExistError(error)) {
                  continue;
                }
              }
              if (otherPidOldStartTime === "" && otherBirthtimeMs !== void 0) {
                if (otherBirthtimeMs > currentBirthTimeMs) {
                  continue;
                } else if (otherBirthtimeMs - currentBirthTimeMs < 0 && // it was created before us AND
                otherBirthtimeMs - currentBirthTimeMs > -1e3) {
                  return void 0;
                }
              }
              if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {
                FileSystem_1.FileSystem.deleteFile(fileInFolderPath);
                continue;
              }
              if (otherBirthtimeMs !== void 0) {
                if (otherBirthtimeMs < smallestBirthTimeMs || otherBirthtimeMs === smallestBirthTimeMs && otherPid < smallestBirthTimePid) {
                  smallestBirthTimeMs = otherBirthtimeMs;
                  smallestBirthTimePid = otherPid;
                }
              }
            }
          }
          if (smallestBirthTimePid !== pid.toString()) {
            return void 0;
          }
          lockFile = new _LockFile(lockFileHandle, pidLockFilePath, dirtyWhenAcquired);
          lockFileHandle = void 0;
        } finally {
          if (lockFileHandle) {
            lockFileHandle.close();
            FileSystem_1.FileSystem.deleteFile(pidLockFilePath);
          }
        }
        return lockFile;
      }
      /**
       * Attempts to acquire the lock using Windows
       * This algorithm is much simpler since we can rely on the operating system
       */
      static _tryAcquireWindows(resourceFolder, resourceName) {
        const lockFilePath = _LockFile.getLockFilePath(resourceFolder, resourceName);
        let dirtyWhenAcquired = false;
        let fileHandle;
        let lockFile;
        try {
          if (FileSystem_1.FileSystem.exists(lockFilePath)) {
            dirtyWhenAcquired = true;
            FileSystem_1.FileSystem.deleteFile(lockFilePath);
          }
          try {
            fileHandle = FileWriter_1.FileWriter.open(lockFilePath, { exclusive: true });
          } catch (error) {
            return void 0;
          }
          lockFile = new _LockFile(fileHandle, lockFilePath, dirtyWhenAcquired);
          fileHandle = void 0;
        } finally {
          if (fileHandle) {
            fileHandle.close();
          }
        }
        return lockFile;
      }
      /**
       * Unlocks a file and optionally removes it from disk.
       * This can only be called once.
       *
       * @param deleteFile - Whether to delete the lockfile from disk. Defaults to true.
       */
      release(deleteFile = true) {
        if (this.isReleased) {
          throw new Error(`The lock for file "${path9.basename(this._filePath)}" has already been released.`);
        }
        this._fileWriter.close();
        if (deleteFile) {
          FileSystem_1.FileSystem.deleteFile(this._filePath);
        }
        this._fileWriter = void 0;
      }
      /**
       * Returns the initial state of the lock.
       * This can be used to detect if the previous process was terminated before releasing the resource.
       */
      get dirtyWhenAcquired() {
        return this._dirtyWhenAcquired;
      }
      /**
       * Returns the absolute path to the lockfile
       */
      get filePath() {
        return this._filePath;
      }
      /**
       * Returns true if this lock is currently being held.
       */
      get isReleased() {
        return this._fileWriter === void 0;
      }
    };
    exports.LockFile = LockFile;
    LockFile._getStartTime = getProcessStartTime;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/MapExtensions.js
var require_MapExtensions = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/MapExtensions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapExtensions = void 0;
    var MapExtensions = class {
      /**
       * Adds all the (key, value) pairs from the source map into the target map.
       * @remarks
       * This function modifies targetMap.  Any existing keys will be overwritten.
       * @param targetMap - The map that entries will be added to
       * @param sourceMap - The map containing the entries to be added
       */
      static mergeFromMap(targetMap, sourceMap) {
        for (const pair of sourceMap.entries()) {
          targetMap.set(pair[0], pair[1]);
        }
      }
      /**
       * Converts a string-keyed map to an object.
       * @remarks
       * This function has the same effect as Object.fromEntries(map.entries())
       * in supported versions of Node (\>= 12.0.0).
       * @param map - The map that the object properties will be sourced from
       */
      static toObject(map) {
        const object = {};
        for (const [key, value] of map.entries()) {
          object[key] = value;
        }
        return object;
      }
    };
    exports.MapExtensions = MapExtensions;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/MinimumHeap.js
var require_MinimumHeap = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/MinimumHeap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MinimumHeap = void 0;
    var MinimumHeap = class {
      /**
       * Constructs a new MinimumHeap instance.
       * @param comparator - a comparator function that determines the order of the items in the heap.
       *   If the comparator returns a value less than zero, then `a` will be considered less than `b`.
       *   If the comparator returns zero, then `a` and `b` are considered equal.
       *   Otherwise, `a` will be considered greater than `b`.
       */
      constructor(comparator) {
        this._items = [];
        this._comparator = comparator;
      }
      /**
       * Returns the number of items in the heap.
       * @returns the number of items in the heap.
       */
      get size() {
        return this._items.length;
      }
      /**
       * Retrieves the root item from the heap without removing it.
       * @returns the root item, or `undefined` if the heap is empty
       */
      peek() {
        return this._items[0];
      }
      /**
       * Retrieves and removes the root item from the heap. The next smallest item will become the new root.
       * @returns the root item, or `undefined` if the heap is empty
       */
      poll() {
        if (this.size > 0) {
          const result = this._items[0];
          const item = this._items.pop();
          const size = this.size;
          if (size === 0) {
            return result;
          }
          let index = 0;
          let smallerChildIndex = 1;
          while (smallerChildIndex < size) {
            let smallerChild = this._items[smallerChildIndex];
            const rightChildIndex = smallerChildIndex + 1;
            if (rightChildIndex < size) {
              const rightChild = this._items[rightChildIndex];
              if (this._comparator(rightChild, smallerChild) < 0) {
                smallerChildIndex = rightChildIndex;
                smallerChild = rightChild;
              }
            }
            if (this._comparator(smallerChild, item) < 0) {
              this._items[index] = smallerChild;
              index = smallerChildIndex;
              smallerChildIndex = index * 2 + 1;
            } else {
              break;
            }
          }
          this._items[index] = item;
          return result;
        }
      }
      /**
       * Pushes an item into the heap.
       * @param item - the item to push
       */
      push(item) {
        let index = this.size;
        while (index > 0) {
          const parentIndex = (index + 1 >> 1) - 1;
          const parent = this._items[parentIndex];
          if (this._comparator(item, parent) < 0) {
            this._items[index] = parent;
            index = parentIndex;
          } else {
            break;
          }
        }
        this._items[index] = item;
      }
    };
    exports.MinimumHeap = MinimumHeap;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/ProtectableMapView.js
var require_ProtectableMapView = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/ProtectableMapView.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtectableMapView = void 0;
    var ProtectableMapView = class extends Map {
      constructor(owner, parameters) {
        super();
        this._owner = owner;
        this._parameters = parameters;
      }
      clear() {
        if (this._parameters.onClear) {
          this._parameters.onClear(this._owner);
        }
        super.clear();
      }
      delete(key) {
        if (this._parameters.onDelete) {
          this._parameters.onDelete(this._owner, key);
        }
        return super.delete(key);
      }
      set(key, value) {
        let modifiedValue = value;
        if (this._parameters.onSet) {
          modifiedValue = this._parameters.onSet(this._owner, key, modifiedValue);
        }
        super.set(key, modifiedValue);
        return this;
      }
      // INTERNAL USAGE ONLY
      _clearUnprotected() {
        super.clear();
      }
      // INTERNAL USAGE ONLY
      _deleteUnprotected(key) {
        return super.delete(key);
      }
      // INTERNAL USAGE ONLY
      _setUnprotected(key, value) {
        super.set(key, value);
      }
    };
    exports.ProtectableMapView = ProtectableMapView;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/ProtectableMap.js
var require_ProtectableMap = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/ProtectableMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtectableMap = void 0;
    var ProtectableMapView_1 = require_ProtectableMapView();
    var ProtectableMap = class {
      constructor(parameters) {
        this._protectedView = new ProtectableMapView_1.ProtectableMapView(this, parameters);
      }
      /**
       * The owner of the protectable map should return this object via its public API.
       */
      get protectedView() {
        return this._protectedView;
      }
      // ---------------------------------------------------------------------------
      // lib.es2015.collections contract - write operations
      /**
       * Removes all entries from the map.
       * This operation does NOT invoke the ProtectableMap onClear() hook.
       */
      clear() {
        this._protectedView._clearUnprotected();
      }
      /**
       * Removes the specified key from the map.
       * This operation does NOT invoke the ProtectableMap onDelete() hook.
       */
      delete(key) {
        return this._protectedView._deleteUnprotected(key);
      }
      /**
       * Sets a value for the specified key.
       * This operation does NOT invoke the ProtectableMap onSet() hook.
       */
      set(key, value) {
        this._protectedView._setUnprotected(key, value);
        return this;
      }
      // ---------------------------------------------------------------------------
      // lib.es2015.collections contract - read operations
      /**
       * Performs an operation for each (key, value) entries in the map.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      forEach(callbackfn, thisArg) {
        this._protectedView.forEach(callbackfn);
      }
      /**
       * Retrieves the value for the specified key.
       * @returns undefined if the value is undefined OR if the key is missing;
       * otherwise returns the value associated with the key.
       */
      get(key) {
        return this._protectedView.get(key);
      }
      /**
       * Returns true if the specified key belongs to the map.
       */
      has(key) {
        return this._protectedView.has(key);
      }
      /**
       * Returns the number of (key, value) entries in the map.
       */
      get size() {
        return this._protectedView.size;
      }
    };
    exports.ProtectableMap = ProtectableMap;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Sort.js
var require_Sort = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sort = void 0;
    var Sort = class _Sort {
      /**
       * Compares `x` and `y` using the JavaScript `>` and `<` operators.  This function is suitable for usage as
       * the callback for `array.sort()`.
       *
       * @remarks
       *
       * The JavaScript ordering is generalized so that `undefined` \< `null` \< all other values.
       *
       * @returns -1 if `x` is smaller than `y`, 1 if `x` is greater than `y`, or 0 if the values are equal.
       *
       * @example
       *
       * ```ts
       * let array: number[] = [3, 6, 2];
       * array.sort(Sort.compareByValue);  // [2, 3, 6]
       * ```
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static compareByValue(x, y) {
        if (x === y) {
          return 0;
        }
        if (x === void 0) {
          return -1;
        }
        if (y === void 0) {
          return 1;
        }
        if (x === null) {
          return -1;
        }
        if (y === null) {
          return 1;
        }
        if (x < y) {
          return -1;
        }
        if (x > y) {
          return 1;
        }
        return 0;
      }
      /**
       * Sorts the array according to a key which is obtained from the array elements.
       * The result is guaranteed to be a stable sort.
       *
       * @example
       *
       * ```ts
       * let array: string[] = [ 'aaa', 'bb', 'c' ];
       * Sort.sortBy(array, x => x.length);  // [ 'c', 'bb', 'aaa' ]
       * ```
       */
      static sortBy(array, keySelector, comparer = _Sort.compareByValue) {
        array.sort((x, y) => comparer(keySelector(x), keySelector(y)));
      }
      /**
       * Returns true if the collection is already sorted.
       */
      static isSorted(collection, comparer = _Sort.compareByValue) {
        let isFirst = true;
        let previous = void 0;
        for (const element of collection) {
          if (isFirst) {
            isFirst = false;
          } else if (comparer(previous, element) > 0) {
            return false;
          }
          previous = element;
        }
        return true;
      }
      /**
       * Returns true if the collection is already sorted by the specified key.
       *
       * @example
       *
       * ```ts
       * let array: string[] = [ 'a', 'bb', 'ccc' ];
       * Sort.isSortedBy(array, x => x.length); // true
       * ```
       */
      static isSortedBy(collection, keySelector, comparer = _Sort.compareByValue) {
        let isFirst = true;
        let previousKey = void 0;
        for (const element of collection) {
          const key = keySelector(element);
          if (isFirst) {
            isFirst = false;
          } else if (comparer(previousKey, key) > 0) {
            return false;
          }
          previousKey = key;
        }
        return true;
      }
      /**
       * Sorts the entries in a Map object according to the map keys.
       * The result is guaranteed to be a stable sort.
       *
       * @example
       *
       * ```ts
       * let map: Map<string, number> = new Map<string, number>();
       * map.set('zebra', 1);
       * map.set('goose', 2);
       * map.set('aardvark', 3);
       * Sort.sortMapKeys(map);
       * console.log(JSON.stringify(Array.from(map.keys()))); // ["aardvark","goose","zebra"]
       * ```
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static sortMapKeys(map, keyComparer = _Sort.compareByValue) {
        if (_Sort.isSorted(map.keys(), keyComparer)) {
          return;
        }
        const pairs = Array.from(map.entries());
        _Sort.sortBy(pairs, (x) => x[0], keyComparer);
        map.clear();
        for (const pair of pairs) {
          map.set(pair[0], pair[1]);
        }
      }
      /**
       * Sorts the entries in a Set object according to the specified keys.
       * The result is guaranteed to be a stable sort.
       *
       * @example
       *
       * ```ts
       * let set: Set<string> = new Set<string>();
       * set.add('aaa');
       * set.add('bb');
       * set.add('c');
       * Sort.sortSetBy(set, x => x.length);
       * console.log(Array.from(set)); // ['c', 'bb', 'aaa']
       * ```
       */
      static sortSetBy(set, keySelector, keyComparer = _Sort.compareByValue) {
        if (_Sort.isSortedBy(set, keySelector, keyComparer)) {
          return;
        }
        const array = Array.from(set);
        array.sort((x, y) => keyComparer(keySelector(x), keySelector(y)));
        set.clear();
        for (const item of array) {
          set.add(item);
        }
      }
      /**
       * Sorts the entries in a Set object.  The result is guaranteed to be a stable sort.
       *
       * @example
       *
       * ```ts
       * let set: Set<string> = new Set<string>();
       * set.add('zebra');
       * set.add('goose');
       * set.add('aardvark');
       * Sort.sortSet(set);
       * console.log(Array.from(set)); // ['aardvark', 'goose', 'zebra']
       * ```
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static sortSet(set, comparer = _Sort.compareByValue) {
        if (_Sort.isSorted(set, comparer)) {
          return;
        }
        const array = Array.from(set);
        array.sort((x, y) => comparer(x, y));
        set.clear();
        for (const item of array) {
          set.add(item);
        }
      }
    };
    exports.Sort = Sort;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/StringBuilder.js
var require_StringBuilder = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/StringBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringBuilder = void 0;
    var StringBuilder = class {
      constructor() {
        this._chunks = [];
      }
      /** {@inheritDoc IStringBuilder.append} */
      append(text) {
        this._chunks.push(text);
      }
      /** {@inheritDoc IStringBuilder.toString} */
      toString() {
        if (this._chunks.length === 0) {
          return "";
        }
        if (this._chunks.length > 1) {
          const joined = this._chunks.join("");
          this._chunks.length = 1;
          this._chunks[0] = joined;
        }
        return this._chunks[0];
      }
    };
    exports.StringBuilder = StringBuilder;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/SubprocessTerminator.js
var require_SubprocessTerminator = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/SubprocessTerminator.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubprocessTerminator = void 0;
    var process_1 = __importDefault(__require("process"));
    var Executable_1 = require_Executable();
    var SubprocessTerminator = class _SubprocessTerminator {
      /**
       * Registers a child process so that it will be terminated automatically if the current process
       * is terminated.
       */
      static killProcessTreeOnExit(subprocess, subprocessOptions) {
        if (typeof subprocess.exitCode === "number") {
          return;
        }
        _SubprocessTerminator._validateSubprocessOptions(subprocessOptions);
        _SubprocessTerminator._ensureInitialized();
        const pid = subprocess.pid;
        if (pid === void 0) {
          return;
        }
        subprocess.on("close", (code, signal) => {
          if (_SubprocessTerminator._subprocessesByPid.delete(pid)) {
            _SubprocessTerminator._logDebug(`untracking #${pid}`);
          }
        });
        _SubprocessTerminator._subprocessesByPid.set(pid, {
          subprocess,
          subprocessOptions
        });
        _SubprocessTerminator._logDebug(`tracking #${pid}`);
      }
      /**
       * Terminate the child process and all of its children.
       */
      static killProcessTree(subprocess, subprocessOptions) {
        const pid = subprocess.pid;
        if (pid === void 0) {
          return;
        }
        if (_SubprocessTerminator._subprocessesByPid.delete(pid)) {
          _SubprocessTerminator._logDebug(`untracking #${pid} via killProcessTree()`);
        }
        _SubprocessTerminator._validateSubprocessOptions(subprocessOptions);
        if (typeof subprocess.exitCode === "number") {
          return;
        }
        _SubprocessTerminator._logDebug(`terminating #${pid}`);
        if (_SubprocessTerminator._isWindows) {
          const result = Executable_1.Executable.spawnSync("TaskKill.exe", [
            "/T",
            // "Terminates the specified process and any child processes which were started by it."
            "/F",
            // Without this, TaskKill will try to use WM_CLOSE which doesn't work with CLI tools
            "/PID",
            pid.toString()
          ]);
          if (result.status) {
            const output = result.output.join("\n");
            if (output.indexOf("not found") >= 0) {
            } else {
              throw new Error(`TaskKill.exe returned exit code ${result.status}:
` + output + "\n");
            }
          }
        } else {
          process_1.default.kill(-pid, "SIGKILL");
        }
      }
      // Install the hooks
      static _ensureInitialized() {
        if (!_SubprocessTerminator._initialized) {
          _SubprocessTerminator._initialized = true;
          _SubprocessTerminator._logDebug("initialize");
          process_1.default.prependListener("SIGTERM", _SubprocessTerminator._onTerminateSignal);
          process_1.default.prependListener("SIGINT", _SubprocessTerminator._onTerminateSignal);
          process_1.default.prependListener("exit", _SubprocessTerminator._onExit);
        }
      }
      // Uninstall the hooks and perform cleanup
      static _cleanupChildProcesses() {
        if (_SubprocessTerminator._initialized) {
          _SubprocessTerminator._initialized = false;
          process_1.default.removeListener("SIGTERM", _SubprocessTerminator._onTerminateSignal);
          process_1.default.removeListener("SIGINT", _SubprocessTerminator._onTerminateSignal);
          const trackedSubprocesses = Array.from(_SubprocessTerminator._subprocessesByPid.values());
          let firstError = void 0;
          for (const trackedSubprocess of trackedSubprocesses) {
            try {
              _SubprocessTerminator.killProcessTree(trackedSubprocess.subprocess, { detached: true });
            } catch (error) {
              if (firstError === void 0) {
                firstError = error;
              }
            }
          }
          if (firstError !== void 0) {
            console.error("\nAn unexpected error was encountered while attempting to clean up child processes:");
            console.error(firstError.toString());
            if (!process_1.default.exitCode) {
              process_1.default.exitCode = 1;
            }
          }
        }
      }
      static _validateSubprocessOptions(subprocessOptions) {
        if (!_SubprocessTerminator._isWindows) {
          if (!subprocessOptions.detached) {
            throw new Error("killProcessTree() requires detached=true on this operating system");
          }
        }
      }
      static _onExit(exitCode) {
        _SubprocessTerminator._logDebug(`received exit(${exitCode})`);
        _SubprocessTerminator._cleanupChildProcesses();
        _SubprocessTerminator._logDebug(`finished exit()`);
      }
      static _onTerminateSignal(signal) {
        _SubprocessTerminator._logDebug(`received signal ${signal}`);
        _SubprocessTerminator._cleanupChildProcesses();
        _SubprocessTerminator._logDebug(`relaying ${signal}`);
        process_1.default.kill(process_1.default.pid, signal);
      }
      // For debugging
      static _logDebug(message) {
      }
    };
    exports.SubprocessTerminator = SubprocessTerminator;
    SubprocessTerminator._initialized = false;
    SubprocessTerminator._subprocessesByPid = /* @__PURE__ */ new Map();
    SubprocessTerminator._isWindows = process_1.default.platform === "win32";
    SubprocessTerminator.RECOMMENDED_OPTIONS = {
      detached: process_1.default.platform !== "win32"
    };
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Terminal/ITerminalProvider.js
var require_ITerminalProvider = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Terminal/ITerminalProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TerminalProviderSeverity = void 0;
    var TerminalProviderSeverity;
    (function(TerminalProviderSeverity2) {
      TerminalProviderSeverity2[TerminalProviderSeverity2["log"] = 0] = "log";
      TerminalProviderSeverity2[TerminalProviderSeverity2["warning"] = 1] = "warning";
      TerminalProviderSeverity2[TerminalProviderSeverity2["error"] = 2] = "error";
      TerminalProviderSeverity2[TerminalProviderSeverity2["verbose"] = 3] = "verbose";
      TerminalProviderSeverity2[TerminalProviderSeverity2["debug"] = 4] = "debug";
    })(TerminalProviderSeverity || (exports.TerminalProviderSeverity = TerminalProviderSeverity = {}));
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Terminal/Terminal.js
var require_Terminal = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Terminal/Terminal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Terminal = void 0;
    var ITerminalProvider_1 = require_ITerminalProvider();
    var Colors_1 = require_Colors();
    var Terminal = class {
      constructor(provider) {
        this._providers = /* @__PURE__ */ new Set();
        this._providers.add(provider);
      }
      /**
       * {@inheritdoc ITerminal.registerProvider}
       */
      registerProvider(provider) {
        this._providers.add(provider);
      }
      /**
       * {@inheritdoc ITerminal.unregisterProvider}
       */
      unregisterProvider(provider) {
        if (this._providers.has(provider)) {
          this._providers.delete(provider);
        }
      }
      /**
       * {@inheritdoc ITerminal.write}
       */
      write(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.log);
      }
      /**
       * {@inheritdoc ITerminal.writeLine}
       */
      writeLine(...messageParts) {
        this.write(...messageParts, Colors_1.eolSequence);
      }
      /**
       * {@inheritdoc ITerminal.writeWarning}
       */
      writeWarning(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow })), ITerminalProvider_1.TerminalProviderSeverity.warning);
      }
      /**
       * {@inheritdoc ITerminal.writeWarningLine}
       */
      writeWarningLine(...messageParts) {
        this._writeSegmentsToProviders([
          ...messageParts.map((part) => Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow })),
          Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.warning);
      }
      /**
       * {@inheritdoc ITerminal.writeError}
       */
      writeError(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red })), ITerminalProvider_1.TerminalProviderSeverity.error);
      }
      /**
       * {@inheritdoc ITerminal.writeErrorLine}
       */
      writeErrorLine(...messageParts) {
        this._writeSegmentsToProviders([
          ...messageParts.map((part) => Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red })),
          Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.error);
      }
      /**
       * {@inheritdoc ITerminal.writeVerbose}
       */
      writeVerbose(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.verbose);
      }
      /**
       * {@inheritdoc ITerminal.writeVerboseLine}
       */
      writeVerboseLine(...messageParts) {
        this.writeVerbose(...messageParts, Colors_1.eolSequence);
      }
      /**
       * {@inheritdoc ITerminal.writeDebug}
       */
      writeDebug(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.debug);
      }
      /**
       * {@inheritdoc ITerminal.writeDebugLine}
       */
      writeDebugLine(...messageParts) {
        this.writeDebug(...messageParts, Colors_1.eolSequence);
      }
      _writeSegmentsToProviders(segments, severity) {
        const withColorText = {};
        const withoutColorText = {};
        let withColorLines;
        let withoutColorLines;
        this._providers.forEach((provider) => {
          const eol = provider.eolCharacter;
          let textToWrite;
          if (provider.supportsColor) {
            if (!withColorLines) {
              withColorLines = this._serializeFormattableTextSegments(segments, true);
            }
            if (!withColorText[eol]) {
              withColorText[eol] = withColorLines.join(eol);
            }
            textToWrite = withColorText[eol];
          } else {
            if (!withoutColorLines) {
              withoutColorLines = this._serializeFormattableTextSegments(segments, false);
            }
            if (!withoutColorText[eol]) {
              withoutColorText[eol] = withoutColorLines.join(eol);
            }
            textToWrite = withoutColorText[eol];
          }
          provider.write(textToWrite, severity);
        });
      }
      _serializeFormattableTextSegments(segments, withColor) {
        const lines = [];
        let segmentsToJoin = [];
        let lastSegmentWasEol = false;
        for (let i = 0; i < segments.length; i++) {
          const segment = Colors_1.Colors._normalizeStringOrColorableSequence(segments[i]);
          lastSegmentWasEol = !!segment.isEol;
          if (lastSegmentWasEol) {
            lines.push(segmentsToJoin.join(""));
            segmentsToJoin = [];
          } else {
            if (withColor) {
              const startColorCodes = [];
              const endColorCodes = [];
              switch (segment.foregroundColor) {
                case Colors_1.ColorValue.Black: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.BlackForeground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                  break;
                }
                case Colors_1.ColorValue.Red: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.RedForeground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                  break;
                }
                case Colors_1.ColorValue.Green: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.GreenForeground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                  break;
                }
                case Colors_1.ColorValue.Yellow: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.YellowForeground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                  break;
                }
                case Colors_1.ColorValue.Blue: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.BlueForeground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                  break;
                }
                case Colors_1.ColorValue.Magenta: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaForeground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                  break;
                }
                case Colors_1.ColorValue.Cyan: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.CyanForeground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                  break;
                }
                case Colors_1.ColorValue.White: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteForeground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                  break;
                }
                case Colors_1.ColorValue.Gray: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.GrayForeground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                  break;
                }
              }
              switch (segment.backgroundColor) {
                case Colors_1.ColorValue.Black: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.BlackBackground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                  break;
                }
                case Colors_1.ColorValue.Red: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.RedBackground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                  break;
                }
                case Colors_1.ColorValue.Green: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.GreenBackground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                  break;
                }
                case Colors_1.ColorValue.Yellow: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.YellowBackground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                  break;
                }
                case Colors_1.ColorValue.Blue: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.BlueBackground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                  break;
                }
                case Colors_1.ColorValue.Magenta: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaBackground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                  break;
                }
                case Colors_1.ColorValue.Cyan: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.CyanBackground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                  break;
                }
                case Colors_1.ColorValue.White: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteBackground);
                  endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                  break;
                }
                case Colors_1.ColorValue.Gray: {
                  startColorCodes.push(Colors_1.ConsoleColorCodes.GrayBackground);
                  endColorCodes.push(49);
                  break;
                }
              }
              if (segment.textAttributes) {
                for (const textAttribute of segment.textAttributes) {
                  switch (textAttribute) {
                    case Colors_1.TextAttribute.Bold: {
                      startColorCodes.push(Colors_1.ConsoleColorCodes.Bold);
                      endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                      break;
                    }
                    case Colors_1.TextAttribute.Dim: {
                      startColorCodes.push(Colors_1.ConsoleColorCodes.Dim);
                      endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                      break;
                    }
                    case Colors_1.TextAttribute.Underline: {
                      startColorCodes.push(Colors_1.ConsoleColorCodes.Underline);
                      endColorCodes.push(Colors_1.ConsoleColorCodes.UnderlineOff);
                      break;
                    }
                    case Colors_1.TextAttribute.Blink: {
                      startColorCodes.push(Colors_1.ConsoleColorCodes.Blink);
                      endColorCodes.push(Colors_1.ConsoleColorCodes.BlinkOff);
                      break;
                    }
                    case Colors_1.TextAttribute.InvertColor: {
                      startColorCodes.push(Colors_1.ConsoleColorCodes.InvertColor);
                      endColorCodes.push(Colors_1.ConsoleColorCodes.InvertColorOff);
                      break;
                    }
                    case Colors_1.TextAttribute.Hidden: {
                      startColorCodes.push(Colors_1.ConsoleColorCodes.Hidden);
                      endColorCodes.push(Colors_1.ConsoleColorCodes.HiddenOff);
                      break;
                    }
                  }
                }
              }
              for (let j = 0; j < startColorCodes.length; j++) {
                const code = startColorCodes[j];
                segmentsToJoin.push(...["\x1B[", code.toString(), "m"]);
              }
              segmentsToJoin.push(segment.text);
              for (let j = endColorCodes.length - 1; j >= 0; j--) {
                const code = endColorCodes[j];
                segmentsToJoin.push(...["\x1B[", code.toString(), "m"]);
              }
            } else {
              segmentsToJoin.push(segment.text);
            }
          }
        }
        if (segmentsToJoin.length > 0) {
          lines.push(segmentsToJoin.join(""));
        }
        if (lastSegmentWasEol) {
          lines.push("");
        }
        return lines;
      }
    };
    exports.Terminal = Terminal;
  }
});

// ../../node_modules/colors/lib/styles.js
var require_styles = __commonJS({
  "../../node_modules/colors/lib/styles.js"(exports, module) {
    "use strict";
    var styles = {};
    module["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// ../../node_modules/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "../../node_modules/colors/lib/system/has-flag.js"(exports, module) {
    "use strict";
    module.exports = function(flag, argv2) {
      argv2 = argv2 || process.argv;
      var terminatorPos = argv2.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv2.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// ../../node_modules/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "../../node_modules/colors/lib/system/supports-colors.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// ../../node_modules/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "../../node_modules/colors/lib/custom/trap.js"(exports, module) {
    "use strict";
    module["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// ../../node_modules/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "../../node_modules/colors/lib/custom/zalgo.js"(exports, module) {
    "use strict";
    module["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// ../../node_modules/colors/lib/maps/america.js
var require_america = __commonJS({
  "../../node_modules/colors/lib/maps/america.js"(exports, module) {
    "use strict";
    var colors = require_colors();
    module["exports"] = /* @__PURE__ */ function() {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    }();
  }
});

// ../../node_modules/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "../../node_modules/colors/lib/maps/zebra.js"(exports, module) {
    "use strict";
    var colors = require_colors();
    module["exports"] = function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  }
});

// ../../node_modules/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "../../node_modules/colors/lib/maps/rainbow.js"(exports, module) {
    "use strict";
    var colors = require_colors();
    module["exports"] = /* @__PURE__ */ function() {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    }();
  }
});

// ../../node_modules/colors/lib/maps/random.js
var require_random = __commonJS({
  "../../node_modules/colors/lib/maps/random.js"(exports, module) {
    "use strict";
    var colors = require_colors();
    module["exports"] = /* @__PURE__ */ function() {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    }();
  }
});

// ../../node_modules/colors/lib/colors.js
var require_colors = __commonJS({
  "../../node_modules/colors/lib/colors.js"(exports, module) {
    "use strict";
    var colors = {};
    module["exports"] = colors;
    colors.themes = {};
    var util = __require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      return ansiStyles[style].open + str + ansiStyles[style].close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg !== void 0 && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, code.close + "\n" + code.open);
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america();
    colors.maps.zebra = require_zebra();
    colors.maps.rainbow = require_rainbow();
    colors.maps.random = require_random();
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// ../../node_modules/colors/safe.js
var require_safe = __commonJS({
  "../../node_modules/colors/safe.js"(exports, module) {
    "use strict";
    var colors = require_colors();
    module["exports"] = colors;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Terminal/ConsoleTerminalProvider.js
var require_ConsoleTerminalProvider = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Terminal/ConsoleTerminalProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConsoleTerminalProvider = void 0;
    var os_1 = __require("os");
    var safe_1 = require_safe();
    var ITerminalProvider_1 = require_ITerminalProvider();
    var ConsoleTerminalProvider = class {
      constructor(options = {}) {
        this.verboseEnabled = false;
        this.debugEnabled = false;
        this.verboseEnabled = !!options.verboseEnabled;
        this.debugEnabled = !!options.debugEnabled;
      }
      /**
       * {@inheritDoc ITerminalProvider.write}
       */
      write(data, severity) {
        switch (severity) {
          case ITerminalProvider_1.TerminalProviderSeverity.warning:
          case ITerminalProvider_1.TerminalProviderSeverity.error: {
            process.stderr.write(data);
            break;
          }
          case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
            if (this.verboseEnabled) {
              process.stdout.write(data);
            }
            break;
          }
          case ITerminalProvider_1.TerminalProviderSeverity.debug: {
            if (this.debugEnabled) {
              process.stdout.write(data);
            }
            break;
          }
          case ITerminalProvider_1.TerminalProviderSeverity.log:
          default: {
            process.stdout.write(data);
            break;
          }
        }
      }
      /**
       * {@inheritDoc ITerminalProvider.eolCharacter}
       */
      get eolCharacter() {
        return os_1.EOL;
      }
      /**
       * {@inheritDoc ITerminalProvider.supportsColor}
       */
      get supportsColor() {
        return safe_1.enabled;
      }
    };
    exports.ConsoleTerminalProvider = ConsoleTerminalProvider;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Terminal/StringBufferTerminalProvider.js
var require_StringBufferTerminalProvider = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Terminal/StringBufferTerminalProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringBufferTerminalProvider = void 0;
    var ITerminalProvider_1 = require_ITerminalProvider();
    var StringBuilder_1 = require_StringBuilder();
    var Text_1 = require_Text();
    var AnsiEscape_1 = require_AnsiEscape();
    var StringBufferTerminalProvider = class {
      constructor(supportsColor = false) {
        this._standardBuffer = new StringBuilder_1.StringBuilder();
        this._verboseBuffer = new StringBuilder_1.StringBuilder();
        this._debugBuffer = new StringBuilder_1.StringBuilder();
        this._warningBuffer = new StringBuilder_1.StringBuilder();
        this._errorBuffer = new StringBuilder_1.StringBuilder();
        this._supportsColor = supportsColor;
      }
      /**
       * {@inheritDoc ITerminalProvider.write}
       */
      write(data, severity) {
        switch (severity) {
          case ITerminalProvider_1.TerminalProviderSeverity.warning: {
            this._warningBuffer.append(data);
            break;
          }
          case ITerminalProvider_1.TerminalProviderSeverity.error: {
            this._errorBuffer.append(data);
            break;
          }
          case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
            this._verboseBuffer.append(data);
            break;
          }
          case ITerminalProvider_1.TerminalProviderSeverity.debug: {
            this._debugBuffer.append(data);
            break;
          }
          case ITerminalProvider_1.TerminalProviderSeverity.log:
          default: {
            this._standardBuffer.append(data);
            break;
          }
        }
      }
      /**
       * {@inheritDoc ITerminalProvider.eolCharacter}
       */
      get eolCharacter() {
        return "[n]";
      }
      /**
       * {@inheritDoc ITerminalProvider.supportsColor}
       */
      get supportsColor() {
        return this._supportsColor;
      }
      /**
       * Get everything that has been written at log-level severity.
       */
      getOutput(options) {
        return this._normalizeOutput(this._standardBuffer.toString(), options);
      }
      /**
       * Get everything that has been written at verbose-level severity.
       */
      getVerbose(options) {
        return this._normalizeOutput(this._verboseBuffer.toString(), options);
      }
      /**
       * Get everything that has been written at debug-level severity.
       */
      getDebugOutput(options) {
        return this._normalizeOutput(this._debugBuffer.toString(), options);
      }
      /**
       * Get everything that has been written at error-level severity.
       */
      getErrorOutput(options) {
        return this._normalizeOutput(this._errorBuffer.toString(), options);
      }
      /**
       * Get everything that has been written at warning-level severity.
       */
      getWarningOutput(options) {
        return this._normalizeOutput(this._warningBuffer.toString(), options);
      }
      _normalizeOutput(s, options) {
        options = Object.assign({ normalizeSpecialCharacters: true }, options || {});
        s = Text_1.Text.convertToLf(s);
        if (options.normalizeSpecialCharacters) {
          return AnsiEscape_1.AnsiEscape.formatForTests(s, { encodeNewlines: true });
        } else {
          return s;
        }
      }
    };
    exports.StringBufferTerminalProvider = StringBufferTerminalProvider;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Terminal/PrefixProxyTerminalProvider.js
var require_PrefixProxyTerminalProvider = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Terminal/PrefixProxyTerminalProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrefixProxyTerminalProvider = void 0;
    var Text_1 = require_Text();
    var PrefixProxyTerminalProvider = class {
      constructor(options) {
        const { terminalProvider } = options;
        this._parentTerminalProvider = terminalProvider;
        if (options.prefix !== void 0) {
          const { prefix } = options;
          this._getPrefix = () => prefix;
        } else {
          const { getPrefix } = options;
          this._getPrefix = getPrefix;
        }
        this._isOnNewline = true;
        this._newlineRegex = new RegExp(`${Text_1.Text.escapeRegExp(terminalProvider.eolCharacter)}|\\n`, "g");
      }
      /** @override */
      get supportsColor() {
        return this._parentTerminalProvider.supportsColor;
      }
      /** @override */
      get eolCharacter() {
        return this._parentTerminalProvider.eolCharacter;
      }
      /** @override */
      write(data, severity) {
        let currentIndex = 0;
        let newlineMatch;
        while (newlineMatch = this._newlineRegex.exec(data)) {
          const newlineIndex = newlineMatch.index;
          const newIndex = newlineIndex + newlineMatch[0].length;
          const prefix = this._isOnNewline ? this._getPrefix() : "";
          const dataToWrite = `${prefix}${data.substring(currentIndex, newIndex)}`;
          this._parentTerminalProvider.write(dataToWrite, severity);
          currentIndex = newIndex;
          this._isOnNewline = true;
        }
        const remainingData = data.substring(currentIndex);
        if (remainingData.length) {
          const prefix = this._isOnNewline ? this._getPrefix() : "";
          this._parentTerminalProvider.write(`${prefix}${remainingData}`, severity);
          this._isOnNewline = false;
        }
      }
    };
    exports.PrefixProxyTerminalProvider = PrefixProxyTerminalProvider;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/Terminal/TerminalWritable.js
var require_TerminalWritable = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/Terminal/TerminalWritable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TerminalWritable = void 0;
    var ITerminalProvider_1 = require_ITerminalProvider();
    var stream_1 = __require("stream");
    var TerminalWritable = class extends stream_1.Writable {
      constructor(options) {
        const { terminal, severity, writableOptions } = options;
        super(writableOptions);
        this._writev = void 0;
        switch (severity) {
          case ITerminalProvider_1.TerminalProviderSeverity.log:
            this._writeMethod = terminal.write.bind(terminal);
            break;
          case ITerminalProvider_1.TerminalProviderSeverity.verbose:
            this._writeMethod = terminal.writeVerbose.bind(terminal);
            break;
          case ITerminalProvider_1.TerminalProviderSeverity.debug:
            this._writeMethod = terminal.writeDebug.bind(terminal);
            break;
          case ITerminalProvider_1.TerminalProviderSeverity.warning:
            this._writeMethod = terminal.writeWarning.bind(terminal);
            break;
          case ITerminalProvider_1.TerminalProviderSeverity.error:
            this._writeMethod = terminal.writeError.bind(terminal);
            break;
          default:
            throw new Error(`Unknown severity: ${severity}`);
        }
      }
      _write(chunk, encoding, callback) {
        try {
          const chunkData = typeof chunk === "string" ? chunk : Buffer.from(chunk);
          this._writeMethod(chunkData.toString());
        } catch (e) {
          callback(e);
          return;
        }
        callback();
      }
    };
    exports.TerminalWritable = TerminalWritable;
  }
});

// ../../node_modules/@rushstack/node-core-library/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/@rushstack/node-core-library/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeUuid = exports.TerminalWritable = exports.PrefixProxyTerminalProvider = exports.StringBufferTerminalProvider = exports.ConsoleTerminalProvider = exports.TerminalProviderSeverity = exports.TextAttribute = exports.ColorValue = exports.Colors = exports.Terminal = exports.SubprocessTerminator = exports.StringBuilder = exports.LegacyAdapters = exports.FileWriter = exports.FileSystem = exports.AlreadyExistsBehavior = exports.Sort = exports.NewlineKind = exports.Text = exports.Encoding = exports.Path = exports.PackageNameParser = exports.PackageName = exports.PackageJsonLookup = exports.ProtectableMap = exports.PosixModeBits = exports.MinimumHeap = exports.MapExtensions = exports.LockFile = exports.JsonSchema = exports.JsonFile = exports.JsonSyntax = exports.InternalError = exports.Import = exports.FileError = exports.Executable = exports.EnvironmentMap = exports.Enum = exports.FolderConstants = exports.FileConstants = exports.AsyncQueue = exports.Async = exports.AnsiEscape = exports.AlreadyReportedError = void 0;
    var AlreadyReportedError_1 = require_AlreadyReportedError();
    Object.defineProperty(exports, "AlreadyReportedError", { enumerable: true, get: function() {
      return AlreadyReportedError_1.AlreadyReportedError;
    } });
    var AnsiEscape_1 = require_AnsiEscape();
    Object.defineProperty(exports, "AnsiEscape", { enumerable: true, get: function() {
      return AnsiEscape_1.AnsiEscape;
    } });
    var Async_1 = require_Async();
    Object.defineProperty(exports, "Async", { enumerable: true, get: function() {
      return Async_1.Async;
    } });
    Object.defineProperty(exports, "AsyncQueue", { enumerable: true, get: function() {
      return Async_1.AsyncQueue;
    } });
    var Constants_1 = require_Constants();
    Object.defineProperty(exports, "FileConstants", { enumerable: true, get: function() {
      return Constants_1.FileConstants;
    } });
    Object.defineProperty(exports, "FolderConstants", { enumerable: true, get: function() {
      return Constants_1.FolderConstants;
    } });
    var Enum_1 = require_Enum();
    Object.defineProperty(exports, "Enum", { enumerable: true, get: function() {
      return Enum_1.Enum;
    } });
    var EnvironmentMap_1 = require_EnvironmentMap();
    Object.defineProperty(exports, "EnvironmentMap", { enumerable: true, get: function() {
      return EnvironmentMap_1.EnvironmentMap;
    } });
    var Executable_1 = require_Executable();
    Object.defineProperty(exports, "Executable", { enumerable: true, get: function() {
      return Executable_1.Executable;
    } });
    var FileError_1 = require_FileError();
    Object.defineProperty(exports, "FileError", { enumerable: true, get: function() {
      return FileError_1.FileError;
    } });
    var Import_1 = require_Import();
    Object.defineProperty(exports, "Import", { enumerable: true, get: function() {
      return Import_1.Import;
    } });
    var InternalError_1 = require_InternalError();
    Object.defineProperty(exports, "InternalError", { enumerable: true, get: function() {
      return InternalError_1.InternalError;
    } });
    var JsonFile_1 = require_JsonFile();
    Object.defineProperty(exports, "JsonSyntax", { enumerable: true, get: function() {
      return JsonFile_1.JsonSyntax;
    } });
    Object.defineProperty(exports, "JsonFile", { enumerable: true, get: function() {
      return JsonFile_1.JsonFile;
    } });
    var JsonSchema_1 = require_JsonSchema();
    Object.defineProperty(exports, "JsonSchema", { enumerable: true, get: function() {
      return JsonSchema_1.JsonSchema;
    } });
    var LockFile_1 = require_LockFile();
    Object.defineProperty(exports, "LockFile", { enumerable: true, get: function() {
      return LockFile_1.LockFile;
    } });
    var MapExtensions_1 = require_MapExtensions();
    Object.defineProperty(exports, "MapExtensions", { enumerable: true, get: function() {
      return MapExtensions_1.MapExtensions;
    } });
    var MinimumHeap_1 = require_MinimumHeap();
    Object.defineProperty(exports, "MinimumHeap", { enumerable: true, get: function() {
      return MinimumHeap_1.MinimumHeap;
    } });
    var PosixModeBits_1 = require_PosixModeBits();
    Object.defineProperty(exports, "PosixModeBits", { enumerable: true, get: function() {
      return PosixModeBits_1.PosixModeBits;
    } });
    var ProtectableMap_1 = require_ProtectableMap();
    Object.defineProperty(exports, "ProtectableMap", { enumerable: true, get: function() {
      return ProtectableMap_1.ProtectableMap;
    } });
    var PackageJsonLookup_1 = require_PackageJsonLookup();
    Object.defineProperty(exports, "PackageJsonLookup", { enumerable: true, get: function() {
      return PackageJsonLookup_1.PackageJsonLookup;
    } });
    var PackageName_1 = require_PackageName();
    Object.defineProperty(exports, "PackageName", { enumerable: true, get: function() {
      return PackageName_1.PackageName;
    } });
    Object.defineProperty(exports, "PackageNameParser", { enumerable: true, get: function() {
      return PackageName_1.PackageNameParser;
    } });
    var Path_1 = require_Path();
    Object.defineProperty(exports, "Path", { enumerable: true, get: function() {
      return Path_1.Path;
    } });
    var Text_1 = require_Text();
    Object.defineProperty(exports, "Encoding", { enumerable: true, get: function() {
      return Text_1.Encoding;
    } });
    Object.defineProperty(exports, "Text", { enumerable: true, get: function() {
      return Text_1.Text;
    } });
    Object.defineProperty(exports, "NewlineKind", { enumerable: true, get: function() {
      return Text_1.NewlineKind;
    } });
    var Sort_1 = require_Sort();
    Object.defineProperty(exports, "Sort", { enumerable: true, get: function() {
      return Sort_1.Sort;
    } });
    var FileSystem_1 = require_FileSystem();
    Object.defineProperty(exports, "AlreadyExistsBehavior", { enumerable: true, get: function() {
      return FileSystem_1.AlreadyExistsBehavior;
    } });
    Object.defineProperty(exports, "FileSystem", { enumerable: true, get: function() {
      return FileSystem_1.FileSystem;
    } });
    var FileWriter_1 = require_FileWriter();
    Object.defineProperty(exports, "FileWriter", { enumerable: true, get: function() {
      return FileWriter_1.FileWriter;
    } });
    var LegacyAdapters_1 = require_LegacyAdapters();
    Object.defineProperty(exports, "LegacyAdapters", { enumerable: true, get: function() {
      return LegacyAdapters_1.LegacyAdapters;
    } });
    var StringBuilder_1 = require_StringBuilder();
    Object.defineProperty(exports, "StringBuilder", { enumerable: true, get: function() {
      return StringBuilder_1.StringBuilder;
    } });
    var SubprocessTerminator_1 = require_SubprocessTerminator();
    Object.defineProperty(exports, "SubprocessTerminator", { enumerable: true, get: function() {
      return SubprocessTerminator_1.SubprocessTerminator;
    } });
    var Terminal_1 = require_Terminal();
    Object.defineProperty(exports, "Terminal", { enumerable: true, get: function() {
      return Terminal_1.Terminal;
    } });
    var Colors_1 = require_Colors();
    Object.defineProperty(exports, "Colors", { enumerable: true, get: function() {
      return Colors_1.Colors;
    } });
    Object.defineProperty(exports, "ColorValue", { enumerable: true, get: function() {
      return Colors_1.ColorValue;
    } });
    Object.defineProperty(exports, "TextAttribute", { enumerable: true, get: function() {
      return Colors_1.TextAttribute;
    } });
    var ITerminalProvider_1 = require_ITerminalProvider();
    Object.defineProperty(exports, "TerminalProviderSeverity", { enumerable: true, get: function() {
      return ITerminalProvider_1.TerminalProviderSeverity;
    } });
    var ConsoleTerminalProvider_1 = require_ConsoleTerminalProvider();
    Object.defineProperty(exports, "ConsoleTerminalProvider", { enumerable: true, get: function() {
      return ConsoleTerminalProvider_1.ConsoleTerminalProvider;
    } });
    var StringBufferTerminalProvider_1 = require_StringBufferTerminalProvider();
    Object.defineProperty(exports, "StringBufferTerminalProvider", { enumerable: true, get: function() {
      return StringBufferTerminalProvider_1.StringBufferTerminalProvider;
    } });
    var PrefixProxyTerminalProvider_1 = require_PrefixProxyTerminalProvider();
    Object.defineProperty(exports, "PrefixProxyTerminalProvider", { enumerable: true, get: function() {
      return PrefixProxyTerminalProvider_1.PrefixProxyTerminalProvider;
    } });
    var TerminalWritable_1 = require_TerminalWritable();
    Object.defineProperty(exports, "TerminalWritable", { enumerable: true, get: function() {
      return TerminalWritable_1.TerminalWritable;
    } });
    var TypeUuid_1 = require_TypeUuid();
    Object.defineProperty(exports, "TypeUuid", { enumerable: true, get: function() {
      return TypeUuid_1.TypeUuid;
    } });
  }
});

// ../../node_modules/readdir-glob/node_modules/minimatch/lib/path.js
var require_path = __commonJS({
  "../../node_modules/readdir-glob/node_modules/minimatch/lib/path.js"(exports, module) {
    "use strict";
    var isWindows = typeof process === "object" && process && process.platform === "win32";
    module.exports = isWindows ? { sep: "\\" } : { sep: "/" };
  }
});

// ../../node_modules/readdir-glob/node_modules/brace-expansion/index.js
var require_brace_expansion2 = __commonJS({
  "../../node_modules/readdir-glob/node_modules/brace-expansion/index.js"(exports, module) {
    "use strict";
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand2(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// ../../node_modules/readdir-glob/node_modules/minimatch/minimatch.js
var require_minimatch2 = __commonJS({
  "../../node_modules/readdir-glob/node_modules/minimatch/minimatch.js"(exports, module) {
    "use strict";
    var minimatch = module.exports = (p, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    module.exports = minimatch;
    var path9 = require_path();
    minimatch.sep = path9.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR;
    var expand2 = require_brace_expansion2();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      const orig = minimatch;
      const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m.defaults = (options) => orig.defaults(ext(def, options));
      m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m;
    };
    minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand2(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options)
          options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        let re = "";
        let hasMagic = false;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        let dotTravAllowed = pattern.charAt(0) === ".";
        let dotFileAllowed = options.dot || dotTravAllowed;
        const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              if (inClass && pattern.charAt(i + 1) === "-") {
                re += c;
                continue;
              }
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(": {
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              const plEntry = {
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              };
              this.debug(this.pattern, "	", plEntry);
              patternListStack.push(plEntry);
              re += plEntry.open;
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            }
            case ")": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\)";
                continue;
              }
              patternListStack.pop();
              clearStateChar();
              hasMagic = true;
              pl = plEntry;
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(Object.assign(pl, { reEnd: re.length }));
              }
              continue;
            }
            case "|": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              continue;
            }
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                re += c;
              } catch (er) {
                re = re.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = true;
              inClass = false;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.slice(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substring(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const closeParensBefore = nlBefore.split(")").length;
          const openParensBefore = nlBefore.split("(").length - closeParensBefore;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart() + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (options.nocase && !hasMagic) {
          hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        const options = this.options;
        if (path9.sep !== "/") {
          f = f.split(path9.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
    minimatch.Minimatch = Minimatch;
  }
});

// ../../node_modules/readdir-glob/index.js
var require_readdir_glob = __commonJS({
  "../../node_modules/readdir-glob/index.js"(exports, module) {
    "use strict";
    module.exports = readdirGlob;
    var fs3 = __require("fs");
    var { EventEmitter } = __require("events");
    var { Minimatch } = require_minimatch2();
    var { resolve: resolve4 } = __require("path");
    function readdir(dir, strict) {
      return new Promise((resolve5, reject) => {
        fs3.readdir(dir, { withFileTypes: true }, (err, files) => {
          if (err) {
            switch (err.code) {
              case "ENOTDIR":
                if (strict) {
                  reject(err);
                } else {
                  resolve5([]);
                }
                break;
              case "ENOTSUP":
              case "ENOENT":
              case "ENAMETOOLONG":
              case "UNKNOWN":
                resolve5([]);
                break;
              case "ELOOP":
              default:
                reject(err);
                break;
            }
          } else {
            resolve5(files);
          }
        });
      });
    }
    function stat(file, followSymlinks) {
      return new Promise((resolve5, reject) => {
        const statFunc = followSymlinks ? fs3.stat : fs3.lstat;
        statFunc(file, (err, stats) => {
          if (err) {
            switch (err.code) {
              case "ENOENT":
                if (followSymlinks) {
                  resolve5(stat(file, false));
                } else {
                  resolve5(null);
                }
                break;
              default:
                resolve5(null);
                break;
            }
          } else {
            resolve5(stats);
          }
        });
      });
    }
    async function* exploreWalkAsync(dir, path9, followSymlinks, useStat, shouldSkip, strict) {
      let files = await readdir(path9 + dir, strict);
      for (const file of files) {
        let name = file.name;
        if (name === void 0) {
          name = file;
          useStat = true;
        }
        const filename = dir + "/" + name;
        const relative = filename.slice(1);
        const absolute = path9 + "/" + relative;
        let stats = null;
        if (useStat || followSymlinks) {
          stats = await stat(absolute, followSymlinks);
        }
        if (!stats && file.name !== void 0) {
          stats = file;
        }
        if (stats === null) {
          stats = { isDirectory: () => false };
        }
        if (stats.isDirectory()) {
          if (!shouldSkip(relative)) {
            yield { relative, absolute, stats };
            yield* exploreWalkAsync(filename, path9, followSymlinks, useStat, shouldSkip, false);
          }
        } else {
          yield { relative, absolute, stats };
        }
      }
    }
    async function* explore(path9, followSymlinks, useStat, shouldSkip) {
      yield* exploreWalkAsync("", path9, followSymlinks, useStat, shouldSkip, true);
    }
    function readOptions(options) {
      return {
        pattern: options.pattern,
        dot: !!options.dot,
        noglobstar: !!options.noglobstar,
        matchBase: !!options.matchBase,
        nocase: !!options.nocase,
        ignore: options.ignore,
        skip: options.skip,
        follow: !!options.follow,
        stat: !!options.stat,
        nodir: !!options.nodir,
        mark: !!options.mark,
        silent: !!options.silent,
        absolute: !!options.absolute
      };
    }
    var ReaddirGlob = class extends EventEmitter {
      constructor(cwd, options, cb) {
        super();
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        this.options = readOptions(options || {});
        this.matchers = [];
        if (this.options.pattern) {
          const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];
          this.matchers = matchers.map(
            (m) => new Minimatch(m, {
              dot: this.options.dot,
              noglobstar: this.options.noglobstar,
              matchBase: this.options.matchBase,
              nocase: this.options.nocase
            })
          );
        }
        this.ignoreMatchers = [];
        if (this.options.ignore) {
          const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];
          this.ignoreMatchers = ignorePatterns.map(
            (ignore) => new Minimatch(ignore, { dot: true })
          );
        }
        this.skipMatchers = [];
        if (this.options.skip) {
          const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];
          this.skipMatchers = skipPatterns.map(
            (skip) => new Minimatch(skip, { dot: true })
          );
        }
        this.iterator = explore(resolve4(cwd || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));
        this.paused = false;
        this.inactive = false;
        this.aborted = false;
        if (cb) {
          this._matches = [];
          this.on("match", (match) => this._matches.push(this.options.absolute ? match.absolute : match.relative));
          this.on("error", (err) => cb(err));
          this.on("end", () => cb(null, this._matches));
        }
        setTimeout(() => this._next(), 0);
      }
      _shouldSkipDirectory(relative) {
        return this.skipMatchers.some((m) => m.match(relative));
      }
      _fileMatches(relative, isDirectory) {
        const file = relative + (isDirectory ? "/" : "");
        return (this.matchers.length === 0 || this.matchers.some((m) => m.match(file))) && !this.ignoreMatchers.some((m) => m.match(file)) && (!this.options.nodir || !isDirectory);
      }
      _next() {
        if (!this.paused && !this.aborted) {
          this.iterator.next().then((obj) => {
            if (!obj.done) {
              const isDirectory = obj.value.stats.isDirectory();
              if (this._fileMatches(obj.value.relative, isDirectory)) {
                let relative = obj.value.relative;
                let absolute = obj.value.absolute;
                if (this.options.mark && isDirectory) {
                  relative += "/";
                  absolute += "/";
                }
                if (this.options.stat) {
                  this.emit("match", { relative, absolute, stat: obj.value.stats });
                } else {
                  this.emit("match", { relative, absolute });
                }
              }
              this._next(this.iterator);
            } else {
              this.emit("end");
            }
          }).catch((err) => {
            this.abort();
            this.emit("error", err);
            if (!err.code && !this.options.silent) {
              console.error(err);
            }
          });
        } else {
          this.inactive = true;
        }
      }
      abort() {
        this.aborted = true;
      }
      pause() {
        this.paused = true;
      }
      resume() {
        this.paused = false;
        if (this.inactive) {
          this.inactive = false;
          this._next();
        }
      }
    };
    function readdirGlob(pattern, options, cb) {
      return new ReaddirGlob(pattern, options, cb);
    }
    readdirGlob.ReaddirGlob = ReaddirGlob;
  }
});

// ../../node_modules/async/dist/async.js
var require_async2 = __commonJS({
  "../../node_modules/async/dist/async.js"(exports, module) {
    "use strict";
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.async = {}));
    })(exports, function(exports2) {
      "use strict";
      function apply(fn, ...args) {
        return (...callArgs) => fn(...args, ...callArgs);
      }
      function initialParams(fn) {
        return function(...args) {
          var callback = args.pop();
          return fn.call(this, args, callback);
        };
      }
      var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
      var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
      var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
      function fallback(fn) {
        setTimeout(fn, 0);
      }
      function wrap(defer) {
        return (fn, ...args) => defer(() => fn(...args));
      }
      var _defer$1;
      if (hasQueueMicrotask) {
        _defer$1 = queueMicrotask;
      } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
      } else if (hasNextTick) {
        _defer$1 = process.nextTick;
      } else {
        _defer$1 = fallback;
      }
      var setImmediate$1 = wrap(_defer$1);
      function asyncify(func) {
        if (isAsync(func)) {
          return function(...args) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
          };
        }
        return initialParams(function(args, callback) {
          var result;
          try {
            result = func.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (result && typeof result.then === "function") {
            return handlePromise(result, callback);
          } else {
            callback(null, result);
          }
        });
      }
      function handlePromise(promise, callback) {
        return promise.then((value) => {
          invokeCallback(callback, null, value);
        }, (err) => {
          invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
        });
      }
      function invokeCallback(callback, error, value) {
        try {
          callback(error, value);
        } catch (err) {
          setImmediate$1((e) => {
            throw e;
          }, err);
        }
      }
      function isAsync(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      }
      function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === "AsyncGenerator";
      }
      function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] === "function";
      }
      function wrapAsync(asyncFn) {
        if (typeof asyncFn !== "function")
          throw new Error("expected a function");
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
      function awaitify(asyncFn, arity) {
        if (!arity)
          arity = asyncFn.length;
        if (!arity)
          throw new Error("arity is undefined");
        function awaitable(...args) {
          if (typeof args[arity - 1] === "function") {
            return asyncFn.apply(this, args);
          }
          return new Promise((resolve4, reject2) => {
            args[arity - 1] = (err, ...cbArgs) => {
              if (err)
                return reject2(err);
              resolve4(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
          });
        }
        return awaitable;
      }
      function applyEach$1(eachfn) {
        return function applyEach2(fns, ...callArgs) {
          const go = awaitify(function(callback) {
            var that = this;
            return eachfn(fns, (fn, cb) => {
              wrapAsync(fn).apply(that, callArgs.concat(cb));
            }, callback);
          });
          return go;
        };
      }
      function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);
        return eachfn(arr, (value, _2, iterCb) => {
          var index2 = counter++;
          _iteratee(value, (err, v) => {
            results[index2] = v;
            iterCb(err);
          });
        }, (err) => {
          callback(err, results);
        });
      }
      function isArrayLike(value) {
        return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
      }
      const breakLoop = {};
      function once(fn) {
        function wrapper(...args) {
          if (fn === null)
            return;
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper;
      }
      function getIterator(coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
      }
      function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
          return ++i < len ? { value: coll[i], key: i } : null;
        };
      }
      function createES2015Iterator(iterator2) {
        var i = -1;
        return function next() {
          var item = iterator2.next();
          if (item.done)
            return null;
          i++;
          return { value: item.value, key: i };
        };
      }
      function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [];
        var i = -1;
        var len = okeys.length;
        return function next() {
          var key = okeys[++i];
          if (key === "__proto__") {
            return next();
          }
          return i < len ? { value: obj[key], key } : null;
        };
      }
      function createIterator(coll) {
        if (isArrayLike(coll)) {
          return createArrayIterator(coll);
        }
        var iterator2 = getIterator(coll);
        return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
      }
      function onlyOnce(fn) {
        return function(...args) {
          if (fn === null)
            throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        };
      }
      function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;
        function replenish() {
          if (running >= limit || awaiting || done)
            return;
          awaiting = true;
          generator.next().then(({ value, done: iterDone }) => {
            if (canceled || done)
              return;
            awaiting = false;
            if (iterDone) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
          }).catch(handleError);
        }
        function iterateeCallback(err, result) {
          running -= 1;
          if (canceled)
            return;
          if (err)
            return handleError(err);
          if (err === false) {
            done = true;
            canceled = true;
            return;
          }
          if (result === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          }
          replenish();
        }
        function handleError(err) {
          if (canceled)
            return;
          awaiting = false;
          done = true;
          callback(err);
        }
        replenish();
      }
      var eachOfLimit$2 = (limit) => {
        return (obj, iteratee, callback) => {
          callback = once(callback);
          if (limit <= 0) {
            throw new RangeError("concurrency limit cannot be less than 1");
          }
          if (!obj) {
            return callback(null);
          }
          if (isAsyncGenerator(obj)) {
            return asyncEachOfLimit(obj, limit, iteratee, callback);
          }
          if (isAsyncIterable(obj)) {
            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
          }
          var nextElem = createIterator(obj);
          var done = false;
          var canceled = false;
          var running = 0;
          var looping = false;
          function iterateeCallback(err, value) {
            if (canceled)
              return;
            running -= 1;
            if (err) {
              done = true;
              callback(err);
            } else if (err === false) {
              done = true;
              canceled = true;
            } else if (value === breakLoop || done && running <= 0) {
              done = true;
              return callback(null);
            } else if (!looping) {
              replenish();
            }
          }
          function replenish() {
            looping = true;
            while (running < limit && !done) {
              var elem = nextElem();
              if (elem === null) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running += 1;
              iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
          }
          replenish();
        };
      };
      function eachOfLimit(coll, limit, iteratee, callback) {
        return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
      }
      var eachOfLimit$1 = awaitify(eachOfLimit, 4);
      function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index2 = 0, completed = 0, { length } = coll, canceled = false;
        if (length === 0) {
          callback(null);
        }
        function iteratorCallback(err, value) {
          if (err === false) {
            canceled = true;
          }
          if (canceled === true)
            return;
          if (err) {
            callback(err);
          } else if (++completed === length || value === breakLoop) {
            callback(null);
          }
        }
        for (; index2 < length; index2++) {
          iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
        }
      }
      function eachOfGeneric(coll, iteratee, callback) {
        return eachOfLimit$1(coll, Infinity, iteratee, callback);
      }
      function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
      }
      var eachOf$1 = awaitify(eachOf, 3);
      function map(coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback);
      }
      var map$1 = awaitify(map, 3);
      var applyEach = applyEach$1(map$1);
      function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$1(coll, 1, iteratee, callback);
      }
      var eachOfSeries$1 = awaitify(eachOfSeries, 3);
      function mapSeries(coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
      }
      var mapSeries$1 = awaitify(mapSeries, 3);
      var applyEachSeries = applyEach$1(mapSeries$1);
      const PROMISE_SYMBOL = Symbol("promiseCallback");
      function promiseCallback() {
        let resolve4, reject2;
        function callback(err, ...args) {
          if (err)
            return reject2(err);
          resolve4(args.length > 1 ? args : args[0]);
        }
        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
          resolve4 = res, reject2 = rej;
        });
        return callback;
      }
      function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== "number") {
          callback = concurrency;
          concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
          return callback(null);
        }
        if (!concurrency) {
          concurrency = numTasks;
        }
        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;
        var listeners = /* @__PURE__ */ Object.create(null);
        var readyTasks = [];
        var readyToCheck = [];
        var uncheckedDependencies = {};
        Object.keys(tasks).forEach((key) => {
          var task5 = tasks[key];
          if (!Array.isArray(task5)) {
            enqueueTask(key, [task5]);
            readyToCheck.push(key);
            return;
          }
          var dependencies = task5.slice(0, task5.length - 1);
          var remainingDependencies = dependencies.length;
          if (remainingDependencies === 0) {
            enqueueTask(key, task5);
            readyToCheck.push(key);
            return;
          }
          uncheckedDependencies[key] = remainingDependencies;
          dependencies.forEach((dependencyName) => {
            if (!tasks[dependencyName]) {
              throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
            }
            addListener(dependencyName, () => {
              remainingDependencies--;
              if (remainingDependencies === 0) {
                enqueueTask(key, task5);
              }
            });
          });
        });
        checkForDeadlocks();
        processQueue();
        function enqueueTask(key, task5) {
          readyTasks.push(() => runTask(key, task5));
        }
        function processQueue() {
          if (canceled)
            return;
          if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
          }
          while (readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
          }
        }
        function addListener(taskName, fn) {
          var taskListeners = listeners[taskName];
          if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
          }
          taskListeners.push(fn);
        }
        function taskComplete(taskName) {
          var taskListeners = listeners[taskName] || [];
          taskListeners.forEach((fn) => fn());
          processQueue();
        }
        function runTask(key, task5) {
          if (hasError)
            return;
          var taskCallback = onlyOnce((err, ...result) => {
            runningTasks--;
            if (err === false) {
              canceled = true;
              return;
            }
            if (result.length < 2) {
              [result] = result;
            }
            if (err) {
              var safeResults = {};
              Object.keys(results).forEach((rkey) => {
                safeResults[rkey] = results[rkey];
              });
              safeResults[key] = result;
              hasError = true;
              listeners = /* @__PURE__ */ Object.create(null);
              if (canceled)
                return;
              callback(err, safeResults);
            } else {
              results[key] = result;
              taskComplete(key);
            }
          });
          runningTasks++;
          var taskFn = wrapAsync(task5[task5.length - 1]);
          if (task5.length > 1) {
            taskFn(results, taskCallback);
          } else {
            taskFn(taskCallback);
          }
        }
        function checkForDeadlocks() {
          var currentTask;
          var counter = 0;
          while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            getDependents(currentTask).forEach((dependent) => {
              if (--uncheckedDependencies[dependent] === 0) {
                readyToCheck.push(dependent);
              }
            });
          }
          if (counter !== numTasks) {
            throw new Error(
              "async.auto cannot execute tasks due to a recursive dependency"
            );
          }
        }
        function getDependents(taskName) {
          var result = [];
          Object.keys(tasks).forEach((key) => {
            const task5 = tasks[key];
            if (Array.isArray(task5) && task5.indexOf(taskName) >= 0) {
              result.push(key);
            }
          });
          return result;
        }
        return callback[PROMISE_SYMBOL];
      }
      var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
      var ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      function stripComments(string) {
        let stripped = "";
        let index2 = 0;
        let endBlockComment = string.indexOf("*/");
        while (index2 < string.length) {
          if (string[index2] === "/" && string[index2 + 1] === "/") {
            let endIndex = string.indexOf("\n", index2);
            index2 = endIndex === -1 ? string.length : endIndex;
          } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
            let endIndex = string.indexOf("*/", index2);
            if (endIndex !== -1) {
              index2 = endIndex + 2;
              endBlockComment = string.indexOf("*/", index2);
            } else {
              stripped += string[index2];
              index2++;
            }
          } else {
            stripped += string[index2];
            index2++;
          }
        }
        return stripped;
      }
      function parseParams(func) {
        const src = stripComments(func.toString());
        let match = src.match(FN_ARGS);
        if (!match) {
          match = src.match(ARROW_FN_ARGS);
        }
        if (!match)
          throw new Error("could not parse args in autoInject\nSource:\n" + src);
        let [, args] = match;
        return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
      }
      function autoInject(tasks, callback) {
        var newTasks = {};
        Object.keys(tasks).forEach((key) => {
          var taskFn = tasks[key];
          var params;
          var fnIsAsync = isAsync(taskFn);
          var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
          if (Array.isArray(taskFn)) {
            params = [...taskFn];
            taskFn = params.pop();
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
          } else if (hasNoDeps) {
            newTasks[key] = taskFn;
          } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            if (!fnIsAsync)
              params.pop();
            newTasks[key] = params.concat(newTask);
          }
          function newTask(results, taskCb) {
            var newArgs = params.map((name) => results[name]);
            newArgs.push(taskCb);
            wrapAsync(taskFn)(...newArgs);
          }
        });
        return auto(newTasks, callback);
      }
      class DLL {
        constructor() {
          this.head = this.tail = null;
          this.length = 0;
        }
        removeLink(node) {
          if (node.prev)
            node.prev.next = node.next;
          else
            this.head = node.next;
          if (node.next)
            node.next.prev = node.prev;
          else
            this.tail = node.prev;
          node.prev = node.next = null;
          this.length -= 1;
          return node;
        }
        empty() {
          while (this.head)
            this.shift();
          return this;
        }
        insertAfter(node, newNode) {
          newNode.prev = node;
          newNode.next = node.next;
          if (node.next)
            node.next.prev = newNode;
          else
            this.tail = newNode;
          node.next = newNode;
          this.length += 1;
        }
        insertBefore(node, newNode) {
          newNode.prev = node.prev;
          newNode.next = node;
          if (node.prev)
            node.prev.next = newNode;
          else
            this.head = newNode;
          node.prev = newNode;
          this.length += 1;
        }
        unshift(node) {
          if (this.head)
            this.insertBefore(this.head, node);
          else
            setInitial(this, node);
        }
        push(node) {
          if (this.tail)
            this.insertAfter(this.tail, node);
          else
            setInitial(this, node);
        }
        shift() {
          return this.head && this.removeLink(this.head);
        }
        pop() {
          return this.tail && this.removeLink(this.tail);
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          var cur = this.head;
          while (cur) {
            yield cur.data;
            cur = cur.next;
          }
        }
        remove(testFn) {
          var curr = this.head;
          while (curr) {
            var { next } = curr;
            if (testFn(curr)) {
              this.removeLink(curr);
            }
            curr = next;
          }
          return this;
        }
      }
      function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
      }
      function queue$1(worker, concurrency, payload) {
        if (concurrency == null) {
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new RangeError("Concurrency must not be zero");
        }
        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
          error: [],
          drain: [],
          saturated: [],
          unsaturated: [],
          empty: []
        };
        function on(event, handler2) {
          events[event].push(handler2);
        }
        function once2(event, handler2) {
          const handleAndRemove = (...args) => {
            off(event, handleAndRemove);
            handler2(...args);
          };
          events[event].push(handleAndRemove);
        }
        function off(event, handler2) {
          if (!event)
            return Object.keys(events).forEach((ev) => events[ev] = []);
          if (!handler2)
            return events[event] = [];
          events[event] = events[event].filter((ev) => ev !== handler2);
        }
        function trigger(event, ...args) {
          events[event].forEach((handler2) => handler2(...args));
        }
        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          var res, rej;
          function promiseCallback2(err, ...args) {
            if (err)
              return rejectOnError ? rej(err) : res();
            if (args.length <= 1)
              return res(args[0]);
            res(args);
          }
          var item = q._createTaskItem(
            data,
            rejectOnError ? promiseCallback2 : callback || promiseCallback2
          );
          if (insertAtFront) {
            q._tasks.unshift(item);
          } else {
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
          if (rejectOnError || !callback) {
            return new Promise((resolve4, reject2) => {
              res = resolve4;
              rej = reject2;
            });
          }
        }
        function _createCB(tasks) {
          return function(err, ...args) {
            numRunning -= 1;
            for (var i = 0, l = tasks.length; i < l; i++) {
              var task5 = tasks[i];
              var index2 = workersList.indexOf(task5);
              if (index2 === 0) {
                workersList.shift();
              } else if (index2 > 0) {
                workersList.splice(index2, 1);
              }
              task5.callback(err, ...args);
              if (err != null) {
                trigger("error", err, task5.data);
              }
            }
            if (numRunning <= q.concurrency - q.buffer) {
              trigger("unsaturated");
            }
            if (q.idle()) {
              trigger("drain");
            }
            q.process();
          };
        }
        function _maybeDrain(data) {
          if (data.length === 0 && q.idle()) {
            setImmediate$1(() => trigger("drain"));
            return true;
          }
          return false;
        }
        const eventMethod = (name) => (handler2) => {
          if (!handler2) {
            return new Promise((resolve4, reject2) => {
              once2(name, (err, data) => {
                if (err)
                  return reject2(err);
                resolve4(data);
              });
            });
          }
          off(name);
          on(name, handler2);
        };
        var isProcessing = false;
        var q = {
          _tasks: new DLL(),
          _createTaskItem(data, callback) {
            return {
              data,
              callback
            };
          },
          *[Symbol.iterator]() {
            yield* q._tasks[Symbol.iterator]();
          },
          concurrency,
          payload,
          buffer: concurrency / 4,
          started: false,
          paused: false,
          push(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, false, false, callback));
            }
            return _insert(data, false, false, callback);
          },
          pushAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, false, true, callback));
            }
            return _insert(data, false, true, callback);
          },
          kill() {
            off();
            q._tasks.empty();
          },
          unshift(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, true, false, callback));
            }
            return _insert(data, true, false, callback);
          },
          unshiftAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, true, true, callback));
            }
            return _insert(data, true, true, callback);
          },
          remove(testFn) {
            q._tasks.remove(testFn);
          },
          process() {
            if (isProcessing) {
              return;
            }
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
              var tasks = [], data = [];
              var l = q._tasks.length;
              if (q.payload)
                l = Math.min(l, q.payload);
              for (var i = 0; i < l; i++) {
                var node = q._tasks.shift();
                tasks.push(node);
                workersList.push(node);
                data.push(node.data);
              }
              numRunning += 1;
              if (q._tasks.length === 0) {
                trigger("empty");
              }
              if (numRunning === q.concurrency) {
                trigger("saturated");
              }
              var cb = onlyOnce(_createCB(tasks));
              _worker(data, cb);
            }
            isProcessing = false;
          },
          length() {
            return q._tasks.length;
          },
          running() {
            return numRunning;
          },
          workersList() {
            return workersList;
          },
          idle() {
            return q._tasks.length + numRunning === 0;
          },
          pause() {
            q.paused = true;
          },
          resume() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            setImmediate$1(q.process);
          }
        };
        Object.defineProperties(q, {
          saturated: {
            writable: false,
            value: eventMethod("saturated")
          },
          unsaturated: {
            writable: false,
            value: eventMethod("unsaturated")
          },
          empty: {
            writable: false,
            value: eventMethod("empty")
          },
          drain: {
            writable: false,
            value: eventMethod("drain")
          },
          error: {
            writable: false,
            value: eventMethod("error")
          }
        });
        return q;
      }
      function cargo$1(worker, payload) {
        return queue$1(worker, 1, payload);
      }
      function cargo(worker, concurrency, payload) {
        return queue$1(worker, concurrency, payload);
      }
      function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb) => {
          _iteratee(memo, x, (err, v) => {
            memo = v;
            iterCb(err);
          });
        }, (err) => callback(err, memo));
      }
      var reduce$1 = awaitify(reduce, 4);
      function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function(...args) {
          var that = this;
          var cb = args[args.length - 1];
          if (typeof cb == "function") {
            args.pop();
          } else {
            cb = promiseCallback();
          }
          reduce$1(
            _functions,
            args,
            (newargs, fn, iterCb) => {
              fn.apply(that, newargs.concat((err, ...nextargs) => {
                iterCb(err, nextargs);
              }));
            },
            (err, results) => cb(err, ...results)
          );
          return cb[PROMISE_SYMBOL];
        };
      }
      function compose(...args) {
        return seq(...args.reverse());
      }
      function mapLimit(coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var mapLimit$1 = awaitify(mapLimit, 4);
      function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, ...args) => {
            if (err)
              return iterCb(err);
            return iterCb(err, args);
          });
        }, (err, mapResults) => {
          var result = [];
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              result = result.concat(...mapResults[i]);
            }
          }
          return callback(err, result);
        });
      }
      var concatLimit$1 = awaitify(concatLimit, 4);
      function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback);
      }
      var concat$1 = awaitify(concat, 3);
      function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback);
      }
      var concatSeries$1 = awaitify(concatSeries, 3);
      function constant$1(...args) {
        return function(...ignoredArgs) {
          var callback = ignoredArgs.pop();
          return callback(null, ...args);
        };
      }
      function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
          var testPassed = false;
          var testResult;
          const iteratee = wrapAsync(_iteratee);
          eachfn(arr, (value, _2, callback) => {
            iteratee(value, (err, result) => {
              if (err || err === false)
                return callback(err);
              if (check(result) && !testResult) {
                testPassed = true;
                testResult = getResult(true, value);
                return callback(null, breakLoop);
              }
              callback();
            });
          }, (err) => {
            if (err)
              return cb(err);
            cb(null, testPassed ? testResult : getResult(false));
          });
        };
      }
      function detect(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
      }
      var detect$1 = awaitify(detect, 3);
      function detectLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var detectLimit$1 = awaitify(detectLimit, 4);
      function detectSeries(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
      }
      var detectSeries$1 = awaitify(detectSeries, 3);
      function consoleFunc(name) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
          if (typeof console === "object") {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              resultArgs.forEach((x) => console[name](x));
            }
          }
        });
      }
      var dir = consoleFunc("dir");
      function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;
        function next(err, ...args) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          results = args;
          _test(...args, check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          if (!truth)
            return callback(null, ...results);
          _fn(next);
        }
        return check(null, true);
      }
      var doWhilst$1 = awaitify(doWhilst, 3);
      function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
          const cb = args.pop();
          _test(...args, (err, truth) => cb(err, !truth));
        }, callback);
      }
      function _withoutIndex(iteratee) {
        return (value, index2, callback) => iteratee(value, callback);
      }
      function eachLimit$2(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var each = awaitify(eachLimit$2, 3);
      function eachLimit(coll, limit, iteratee, callback) {
        return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachLimit$1 = awaitify(eachLimit, 4);
      function eachSeries(coll, iteratee, callback) {
        return eachLimit$1(coll, 1, iteratee, callback);
      }
      var eachSeries$1 = awaitify(eachSeries, 3);
      function ensureAsync(fn) {
        if (isAsync(fn))
          return fn;
        return function(...args) {
          var callback = args.pop();
          var sync = true;
          args.push((...innerArgs) => {
            if (sync) {
              setImmediate$1(() => callback(...innerArgs));
            } else {
              callback(...innerArgs);
            }
          });
          fn.apply(this, args);
          sync = false;
        };
      }
      function every(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
      }
      var every$1 = awaitify(every, 3);
      function everyLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var everyLimit$1 = awaitify(everyLimit, 4);
      function everySeries(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var everySeries$1 = awaitify(everySeries, 3);
      function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            truthValues[index2] = !!v;
            iterCb(err);
          });
        }, (err) => {
          if (err)
            return callback(err);
          var results = [];
          for (var i = 0; i < arr.length; i++) {
            if (truthValues[i])
              results.push(arr[i]);
          }
          callback(null, results);
        });
      }
      function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            if (err)
              return iterCb(err);
            if (v) {
              results.push({ index: index2, value: x });
            }
            iterCb(err);
          });
        }, (err) => {
          if (err)
            return callback(err);
          callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
        });
      }
      function _filter(eachfn, coll, iteratee, callback) {
        var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter2(eachfn, coll, wrapAsync(iteratee), callback);
      }
      function filter(coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback);
      }
      var filter$1 = awaitify(filter, 3);
      function filterLimit(coll, limit, iteratee, callback) {
        return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var filterLimit$1 = awaitify(filterLimit, 4);
      function filterSeries(coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback);
      }
      var filterSeries$1 = awaitify(filterSeries, 3);
      function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task5 = wrapAsync(ensureAsync(fn));
        function next(err) {
          if (err)
            return done(err);
          if (err === false)
            return;
          task5(next);
        }
        return next();
      }
      var forever$1 = awaitify(forever, 2);
      function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, key) => {
            if (err)
              return iterCb(err);
            return iterCb(err, { key, val });
          });
        }, (err, mapResults) => {
          var result = {};
          var { hasOwnProperty } = Object.prototype;
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              var { key } = mapResults[i];
              var { val } = mapResults[i];
              if (hasOwnProperty.call(result, key)) {
                result[key].push(val);
              } else {
                result[key] = [val];
              }
            }
          }
          return callback(err, result);
        });
      }
      var groupByLimit$1 = awaitify(groupByLimit, 4);
      function groupBy(coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback);
      }
      function groupBySeries(coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback);
      }
      var log = consoleFunc("log");
      function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit$2(limit)(obj, (val, key, next) => {
          _iteratee(val, key, (err, result) => {
            if (err)
              return next(err);
            newObj[key] = result;
            next(err);
          });
        }, (err) => callback(err, newObj));
      }
      var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
      function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, Infinity, iteratee, callback);
      }
      function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback);
      }
      function memoize(fn, hasher = (v) => v) {
        var memo = /* @__PURE__ */ Object.create(null);
        var queues = /* @__PURE__ */ Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback) => {
          var key = hasher(...args);
          if (key in memo) {
            setImmediate$1(() => callback(null, ...memo[key]));
          } else if (key in queues) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            _fn(...args, (err, ...resultArgs) => {
              if (!err) {
                memo[key] = resultArgs;
              }
              var q = queues[key];
              delete queues[key];
              for (var i = 0, l = q.length; i < l; i++) {
                q[i](err, ...resultArgs);
              }
            });
          }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      }
      var _defer;
      if (hasNextTick) {
        _defer = process.nextTick;
      } else if (hasSetImmediate) {
        _defer = setImmediate;
      } else {
        _defer = fallback;
      }
      var nextTick = wrap(_defer);
      var _parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, (task5, key, taskCb) => {
          wrapAsync(task5)((err, ...result) => {
            if (result.length < 2) {
              [result] = result;
            }
            results[key] = result;
            taskCb(err);
          });
        }, (err) => callback(err, results));
      }, 3);
      function parallel2(tasks, callback) {
        return _parallel(eachOf$1, tasks, callback);
      }
      function parallelLimit(tasks, limit, callback) {
        return _parallel(eachOfLimit$2(limit), tasks, callback);
      }
      function queue(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue$1((items, cb) => {
          _worker(items[0], cb);
        }, concurrency, 1);
      }
      class Heap {
        constructor() {
          this.heap = [];
          this.pushCount = Number.MIN_SAFE_INTEGER;
        }
        get length() {
          return this.heap.length;
        }
        empty() {
          this.heap = [];
          return this;
        }
        percUp(index2) {
          let p;
          while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
            let t = this.heap[index2];
            this.heap[index2] = this.heap[p];
            this.heap[p] = t;
            index2 = p;
          }
        }
        percDown(index2) {
          let l;
          while ((l = leftChi(index2)) < this.heap.length) {
            if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
              l = l + 1;
            }
            if (smaller(this.heap[index2], this.heap[l])) {
              break;
            }
            let t = this.heap[index2];
            this.heap[index2] = this.heap[l];
            this.heap[l] = t;
            index2 = l;
          }
        }
        push(node) {
          node.pushCount = ++this.pushCount;
          this.heap.push(node);
          this.percUp(this.heap.length - 1);
        }
        unshift(node) {
          return this.heap.push(node);
        }
        shift() {
          let [top] = this.heap;
          this.heap[0] = this.heap[this.heap.length - 1];
          this.heap.pop();
          this.percDown(0);
          return top;
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          for (let i = 0; i < this.heap.length; i++) {
            yield this.heap[i].data;
          }
        }
        remove(testFn) {
          let j = 0;
          for (let i = 0; i < this.heap.length; i++) {
            if (!testFn(this.heap[i])) {
              this.heap[j] = this.heap[i];
              j++;
            }
          }
          this.heap.splice(j);
          for (let i = parent(this.heap.length - 1); i >= 0; i--) {
            this.percDown(i);
          }
          return this;
        }
      }
      function leftChi(i) {
        return (i << 1) + 1;
      }
      function parent(i) {
        return (i + 1 >> 1) - 1;
      }
      function smaller(x, y) {
        if (x.priority !== y.priority) {
          return x.priority < y.priority;
        } else {
          return x.pushCount < y.pushCount;
        }
      }
      function priorityQueue(worker, concurrency) {
        var q = queue(worker, concurrency);
        var {
          push,
          pushAsync
        } = q;
        q._tasks = new Heap();
        q._createTaskItem = ({ data, priority }, callback) => {
          return {
            data,
            priority,
            callback
          };
        };
        function createDataItems(tasks, priority) {
          if (!Array.isArray(tasks)) {
            return { data: tasks, priority };
          }
          return tasks.map((data) => {
            return { data, priority };
          });
        }
        q.push = function(data, priority = 0, callback) {
          return push(createDataItems(data, priority), callback);
        };
        q.pushAsync = function(data, priority = 0, callback) {
          return pushAsync(createDataItems(data, priority), callback);
        };
        delete q.unshift;
        delete q.unshiftAsync;
        return q;
      }
      function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks))
          return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length)
          return callback();
        for (var i = 0, l = tasks.length; i < l; i++) {
          wrapAsync(tasks[i])(callback);
        }
      }
      var race$1 = awaitify(race, 2);
      function reduceRight(array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
      }
      function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
          args.push((error, ...cbArgs) => {
            let retVal = {};
            if (error) {
              retVal.error = error;
            }
            if (cbArgs.length > 0) {
              var value = cbArgs;
              if (cbArgs.length <= 1) {
                [value] = cbArgs;
              }
              retVal.value = value;
            }
            reflectCallback(null, retVal);
          });
          return _fn.apply(this, args);
        });
      }
      function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
          results = tasks.map(reflect);
        } else {
          results = {};
          Object.keys(tasks).forEach((key) => {
            results[key] = reflect.call(this, tasks[key]);
          });
        }
        return results;
      }
      function reject$2(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
          iteratee(value, (err, v) => {
            cb(err, !v);
          });
        }, callback);
      }
      function reject(coll, iteratee, callback) {
        return reject$2(eachOf$1, coll, iteratee, callback);
      }
      var reject$1 = awaitify(reject, 3);
      function rejectLimit(coll, limit, iteratee, callback) {
        return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var rejectLimit$1 = awaitify(rejectLimit, 4);
      function rejectSeries(coll, iteratee, callback) {
        return reject$2(eachOfSeries$1, coll, iteratee, callback);
      }
      var rejectSeries$1 = awaitify(rejectSeries, 3);
      function constant(value) {
        return function() {
          return value;
        };
      }
      const DEFAULT_TIMES = 5;
      const DEFAULT_INTERVAL = 0;
      function retry(opts, task5, callback) {
        var options = {
          times: DEFAULT_TIMES,
          intervalFunc: constant(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && typeof opts === "function") {
          callback = task5 || promiseCallback();
          task5 = opts;
        } else {
          parseTimes(options, opts);
          callback = callback || promiseCallback();
        }
        if (typeof task5 !== "function") {
          throw new Error("Invalid arguments for async.retry");
        }
        var _task = wrapAsync(task5);
        var attempt = 1;
        function retryAttempt() {
          _task((err, ...args) => {
            if (err === false)
              return;
            if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
              setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
              callback(err, ...args);
            }
          });
        }
        retryAttempt();
        return callback[PROMISE_SYMBOL];
      }
      function parseTimes(acc, t) {
        if (typeof t === "object") {
          acc.times = +t.times || DEFAULT_TIMES;
          acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);
          acc.errorFilter = t.errorFilter;
        } else if (typeof t === "number" || typeof t === "string") {
          acc.times = +t || DEFAULT_TIMES;
        } else {
          throw new Error("Invalid arguments for async.retry");
        }
      }
      function retryable(opts, task5) {
        if (!task5) {
          task5 = opts;
          opts = null;
        }
        let arity = opts && opts.arity || task5.length;
        if (isAsync(task5)) {
          arity += 1;
        }
        var _task = wrapAsync(task5);
        return initialParams((args, callback) => {
          if (args.length < arity - 1 || callback == null) {
            args.push(callback);
            callback = promiseCallback();
          }
          function taskFn(cb) {
            _task(...args, cb);
          }
          if (opts)
            retry(opts, taskFn, callback);
          else
            retry(taskFn, callback);
          return callback[PROMISE_SYMBOL];
        });
      }
      function series5(tasks, callback) {
        return _parallel(eachOfSeries$1, tasks, callback);
      }
      function some(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
      }
      var some$1 = awaitify(some, 3);
      function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var someLimit$1 = awaitify(someLimit, 4);
      function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var someSeries$1 = awaitify(someSeries, 3);
      function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb) => {
          _iteratee(x, (err, criteria) => {
            if (err)
              return iterCb(err);
            iterCb(err, { value: x, criteria });
          });
        }, (err, results) => {
          if (err)
            return callback(err);
          callback(null, results.sort(comparator).map((v) => v.value));
        });
        function comparator(left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        }
      }
      var sortBy$1 = awaitify(sortBy, 3);
      function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams((args, callback) => {
          var timedOut = false;
          var timer;
          function timeoutCallback() {
            var name = asyncFn.name || "anonymous";
            var error = new Error('Callback function "' + name + '" timed out.');
            error.code = "ETIMEDOUT";
            if (info) {
              error.info = info;
            }
            timedOut = true;
            callback(error);
          }
          args.push((...cbArgs) => {
            if (!timedOut) {
              callback(...cbArgs);
              clearTimeout(timer);
            }
          });
          timer = setTimeout(timeoutCallback, milliseconds);
          fn(...args);
        });
      }
      function range(size) {
        var result = Array(size);
        while (size--) {
          result[size] = size;
        }
        return result;
      }
      function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
      }
      function times(n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback);
      }
      function timesSeries(n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback);
      }
      function transform(coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === "function") {
          callback = iteratee;
          iteratee = accumulator;
          accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);
        eachOf$1(coll, (v, k, cb) => {
          _iteratee(accumulator, v, k, cb);
        }, (err) => callback(err, accumulator));
        return callback[PROMISE_SYMBOL];
      }
      function tryEach(tasks, callback) {
        var error = null;
        var result;
        return eachSeries$1(tasks, (task5, taskCb) => {
          wrapAsync(task5)((err, ...args) => {
            if (err === false)
              return taskCb(err);
            if (args.length < 2) {
              [result] = args;
            } else {
              result = args;
            }
            error = err;
            taskCb(err ? null : {});
          });
        }, () => callback(error, result));
      }
      var tryEach$1 = awaitify(tryEach);
      function unmemoize(fn) {
        return (...args) => {
          return (fn.unmemoized || fn)(...args);
        };
      }
      function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];
        function next(err, ...rest) {
          if (err)
            return callback(err);
          results = rest;
          if (err === false)
            return;
          _test(check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          if (!truth)
            return callback(null, ...results);
          _fn(next);
        }
        return _test(check);
      }
      var whilst$1 = awaitify(whilst, 3);
      function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
      }
      function waterfall(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks))
          return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length)
          return callback();
        var taskIndex = 0;
        function nextTask(args) {
          var task5 = wrapAsync(tasks[taskIndex++]);
          task5(...args, onlyOnce(next));
        }
        function next(err, ...args) {
          if (err === false)
            return;
          if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
          }
          nextTask(args);
        }
        nextTask([]);
      }
      var waterfall$1 = awaitify(waterfall);
      var index = {
        apply,
        applyEach,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo: cargo$1,
        cargoQueue: cargo,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant: constant$1,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$1,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$1,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel: parallel2,
        parallelLimit,
        priorityQueue,
        queue,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$1,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series: series5,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,
        // aliases
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$1,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$1,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
      };
      exports2.all = every$1;
      exports2.allLimit = everyLimit$1;
      exports2.allSeries = everySeries$1;
      exports2.any = some$1;
      exports2.anyLimit = someLimit$1;
      exports2.anySeries = someSeries$1;
      exports2.apply = apply;
      exports2.applyEach = applyEach;
      exports2.applyEachSeries = applyEachSeries;
      exports2.asyncify = asyncify;
      exports2.auto = auto;
      exports2.autoInject = autoInject;
      exports2.cargo = cargo$1;
      exports2.cargoQueue = cargo;
      exports2.compose = compose;
      exports2.concat = concat$1;
      exports2.concatLimit = concatLimit$1;
      exports2.concatSeries = concatSeries$1;
      exports2.constant = constant$1;
      exports2.default = index;
      exports2.detect = detect$1;
      exports2.detectLimit = detectLimit$1;
      exports2.detectSeries = detectSeries$1;
      exports2.dir = dir;
      exports2.doDuring = doWhilst$1;
      exports2.doUntil = doUntil;
      exports2.doWhilst = doWhilst$1;
      exports2.during = whilst$1;
      exports2.each = each;
      exports2.eachLimit = eachLimit$1;
      exports2.eachOf = eachOf$1;
      exports2.eachOfLimit = eachOfLimit$1;
      exports2.eachOfSeries = eachOfSeries$1;
      exports2.eachSeries = eachSeries$1;
      exports2.ensureAsync = ensureAsync;
      exports2.every = every$1;
      exports2.everyLimit = everyLimit$1;
      exports2.everySeries = everySeries$1;
      exports2.filter = filter$1;
      exports2.filterLimit = filterLimit$1;
      exports2.filterSeries = filterSeries$1;
      exports2.find = detect$1;
      exports2.findLimit = detectLimit$1;
      exports2.findSeries = detectSeries$1;
      exports2.flatMap = concat$1;
      exports2.flatMapLimit = concatLimit$1;
      exports2.flatMapSeries = concatSeries$1;
      exports2.foldl = reduce$1;
      exports2.foldr = reduceRight;
      exports2.forEach = each;
      exports2.forEachLimit = eachLimit$1;
      exports2.forEachOf = eachOf$1;
      exports2.forEachOfLimit = eachOfLimit$1;
      exports2.forEachOfSeries = eachOfSeries$1;
      exports2.forEachSeries = eachSeries$1;
      exports2.forever = forever$1;
      exports2.groupBy = groupBy;
      exports2.groupByLimit = groupByLimit$1;
      exports2.groupBySeries = groupBySeries;
      exports2.inject = reduce$1;
      exports2.log = log;
      exports2.map = map$1;
      exports2.mapLimit = mapLimit$1;
      exports2.mapSeries = mapSeries$1;
      exports2.mapValues = mapValues;
      exports2.mapValuesLimit = mapValuesLimit$1;
      exports2.mapValuesSeries = mapValuesSeries;
      exports2.memoize = memoize;
      exports2.nextTick = nextTick;
      exports2.parallel = parallel2;
      exports2.parallelLimit = parallelLimit;
      exports2.priorityQueue = priorityQueue;
      exports2.queue = queue;
      exports2.race = race$1;
      exports2.reduce = reduce$1;
      exports2.reduceRight = reduceRight;
      exports2.reflect = reflect;
      exports2.reflectAll = reflectAll;
      exports2.reject = reject$1;
      exports2.rejectLimit = rejectLimit$1;
      exports2.rejectSeries = rejectSeries$1;
      exports2.retry = retry;
      exports2.retryable = retryable;
      exports2.select = filter$1;
      exports2.selectLimit = filterLimit$1;
      exports2.selectSeries = filterSeries$1;
      exports2.seq = seq;
      exports2.series = series5;
      exports2.setImmediate = setImmediate$1;
      exports2.some = some$1;
      exports2.someLimit = someLimit$1;
      exports2.someSeries = someSeries$1;
      exports2.sortBy = sortBy$1;
      exports2.timeout = timeout;
      exports2.times = times;
      exports2.timesLimit = timesLimit;
      exports2.timesSeries = timesSeries;
      exports2.transform = transform;
      exports2.tryEach = tryEach$1;
      exports2.unmemoize = unmemoize;
      exports2.until = until;
      exports2.waterfall = waterfall$1;
      exports2.whilst = whilst$1;
      exports2.wrapSync = asyncify;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "../../node_modules/process-nextick-args/index.js"(exports, module) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module.exports = { nextTick };
    } else {
      module.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// ../../node_modules/lazystream/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../../node_modules/lazystream/node_modules/isarray/index.js"(exports, module) {
    "use strict";
    var toString2 = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
  }
});

// ../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module) {
    "use strict";
    module.exports = __require("stream");
  }
});

// ../../node_modules/lazystream/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/lazystream/node_modules/safe-buffer/index.js"(exports, module) {
    "use strict";
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "../../node_modules/core-util-is/lib/util.js"(exports) {
    "use strict";
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = __require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// ../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = __require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// ../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy
    };
  }
});

// ../../node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "../../node_modules/util-deprecate/node.js"(exports, module) {
    "use strict";
    module.exports = __require("util").deprecate;
  }
});

// ../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../../node_modules/lazystream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../../node_modules/lazystream/node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    module.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = __require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = __require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// ../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../../node_modules/lazystream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../node_modules/lazystream/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "../../node_modules/lazystream/node_modules/readable-stream/readable.js"(exports, module) {
    "use strict";
    var Stream = __require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module.exports = Stream;
      exports = module.exports = Stream.Readable;
      exports.Readable = Stream.Readable;
      exports.Writable = Stream.Writable;
      exports.Duplex = Stream.Duplex;
      exports.Transform = Stream.Transform;
      exports.PassThrough = Stream.PassThrough;
      exports.Stream = Stream;
    } else {
      exports = module.exports = require_stream_readable();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
    }
  }
});

// ../../node_modules/lazystream/node_modules/readable-stream/passthrough.js
var require_passthrough = __commonJS({
  "../../node_modules/lazystream/node_modules/readable-stream/passthrough.js"(exports, module) {
    "use strict";
    module.exports = require_readable().PassThrough;
  }
});

// ../../node_modules/lazystream/lib/lazystream.js
var require_lazystream = __commonJS({
  "../../node_modules/lazystream/lib/lazystream.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var PassThrough = require_passthrough();
    module.exports = {
      Readable,
      Writable
    };
    util.inherits(Readable, PassThrough);
    util.inherits(Writable, PassThrough);
    function beforeFirstCall(instance, method, callback) {
      instance[method] = function() {
        delete instance[method];
        callback.apply(this, arguments);
        return this[method].apply(this, arguments);
      };
    }
    function Readable(fn, options) {
      if (!(this instanceof Readable))
        return new Readable(fn, options);
      PassThrough.call(this, options);
      beforeFirstCall(this, "_read", function() {
        var source = fn.call(this, options);
        var emit = this.emit.bind(this, "error");
        source.on("error", emit);
        source.pipe(this);
      });
      this.emit("readable");
    }
    function Writable(fn, options) {
      if (!(this instanceof Writable))
        return new Writable(fn, options);
      PassThrough.call(this, options);
      beforeFirstCall(this, "_write", function() {
        var destination = fn.call(this, options);
        var emit = this.emit.bind(this, "error");
        destination.on("error", emit);
        this.pipe(destination);
      });
      this.emit("writable");
    }
  }
});

// ../../node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "../../node_modules/normalize-path/index.js"(exports, module) {
    "use strict";
    module.exports = function(path9, stripTrailing) {
      if (typeof path9 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path9 === "\\" || path9 === "/")
        return "/";
      var len = path9.length;
      if (len <= 1)
        return path9;
      var prefix = "";
      if (len > 4 && path9[3] === "\\") {
        var ch = path9[2];
        if ((ch === "?" || ch === ".") && path9.slice(0, 2) === "\\\\") {
          path9 = path9.slice(2);
          prefix = "//";
        }
      }
      var segs = path9.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// ../../node_modules/lodash/identity.js
var require_identity = __commonJS({
  "../../node_modules/lodash/identity.js"(exports, module) {
    "use strict";
    function identity(value) {
      return value;
    }
    module.exports = identity;
  }
});

// ../../node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "../../node_modules/lodash/_apply.js"(exports, module) {
    "use strict";
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module.exports = apply;
  }
});

// ../../node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "../../node_modules/lodash/_overRest.js"(exports, module) {
    "use strict";
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module.exports = overRest;
  }
});

// ../../node_modules/lodash/constant.js
var require_constant = __commonJS({
  "../../node_modules/lodash/constant.js"(exports, module) {
    "use strict";
    function constant(value) {
      return function() {
        return value;
      };
    }
    module.exports = constant;
  }
});

// ../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/lodash/_freeGlobal.js"(exports, module) {
    "use strict";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// ../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/lodash/_root.js"(exports, module) {
    "use strict";
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// ../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/lodash/_Symbol.js"(exports, module) {
    "use strict";
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// ../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/lodash/_getRawTag.js"(exports, module) {
    "use strict";
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// ../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/lodash/_objectToString.js"(exports, module) {
    "use strict";
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// ../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/lodash/_baseGetTag.js"(exports, module) {
    "use strict";
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/lodash/isObject.js"(exports, module) {
    "use strict";
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject;
  }
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/lodash/isFunction.js"(exports, module) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction;
  }
});

// ../../node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../node_modules/lodash/_coreJsData.js"(exports, module) {
    "use strict";
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// ../../node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../node_modules/lodash/_isMasked.js"(exports, module) {
    "use strict";
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// ../../node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../node_modules/lodash/_toSource.js"(exports, module) {
    "use strict";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// ../../node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../node_modules/lodash/_baseIsNative.js"(exports, module) {
    "use strict";
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// ../../node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../node_modules/lodash/_getValue.js"(exports, module) {
    "use strict";
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// ../../node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../node_modules/lodash/_getNative.js"(exports, module) {
    "use strict";
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// ../../node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/lodash/_defineProperty.js"(exports, module) {
    "use strict";
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module.exports = defineProperty;
  }
});

// ../../node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "../../node_modules/lodash/_baseSetToString.js"(exports, module) {
    "use strict";
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module.exports = baseSetToString;
  }
});

// ../../node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "../../node_modules/lodash/_shortOut.js"(exports, module) {
    "use strict";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module.exports = shortOut;
  }
});

// ../../node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "../../node_modules/lodash/_setToString.js"(exports, module) {
    "use strict";
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module.exports = setToString;
  }
});

// ../../node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "../../node_modules/lodash/_baseRest.js"(exports, module) {
    "use strict";
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module.exports = baseRest;
  }
});

// ../../node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../../node_modules/lodash/eq.js"(exports, module) {
    "use strict";
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// ../../node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../node_modules/lodash/isLength.js"(exports, module) {
    "use strict";
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// ../../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/lodash/isArrayLike.js"(exports, module) {
    "use strict";
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module.exports = isArrayLike;
  }
});

// ../../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/lodash/_isIndex.js"(exports, module) {
    "use strict";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// ../../node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "../../node_modules/lodash/_isIterateeCall.js"(exports, module) {
    "use strict";
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module.exports = isIterateeCall;
  }
});

// ../../node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../node_modules/lodash/_baseTimes.js"(exports, module) {
    "use strict";
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/lodash/isObjectLike.js"(exports, module) {
    "use strict";
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// ../../node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../node_modules/lodash/_baseIsArguments.js"(exports, module) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// ../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/lodash/isArguments.js"(exports, module) {
    "use strict";
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/lodash/isArray.js"(exports, module) {
    "use strict";
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// ../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../node_modules/lodash/stubFalse.js"(exports, module) {
    "use strict";
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// ../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../node_modules/lodash/isBuffer.js"(exports, module) {
    "use strict";
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// ../../node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// ../../node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../node_modules/lodash/_baseUnary.js"(exports, module) {
    "use strict";
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// ../../node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../node_modules/lodash/_nodeUtil.js"(exports, module) {
    "use strict";
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// ../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../node_modules/lodash/isTypedArray.js"(exports, module) {
    "use strict";
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// ../../node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    "use strict";
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// ../../node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../node_modules/lodash/_isPrototype.js"(exports, module) {
    "use strict";
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// ../../node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "../../node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    "use strict";
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = nativeKeysIn;
  }
});

// ../../node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "../../node_modules/lodash/_baseKeysIn.js"(exports, module) {
    "use strict";
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeysIn;
  }
});

// ../../node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "../../node_modules/lodash/keysIn.js"(exports, module) {
    "use strict";
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module.exports = keysIn;
  }
});

// ../../node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "../../node_modules/lodash/defaults.js"(exports, module) {
    "use strict";
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module.exports = defaults;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module) {
    "use strict";
    module.exports = __require("stream");
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = __require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = __require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../node_modules/readable-stream/errors.js
var require_errors = __commonJS({
  "../../node_modules/readable-stream/errors.js"(exports, module) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// ../../node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream2();
    var Buffer2 = __require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy2();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex2();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable2();
    var Writable = require_stream_writable2();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "../../node_modules/safe-buffer/index.js"(exports, module) {
    "use strict";
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS({
  "../../node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve4 = iter[kLastResolve];
      if (resolve4 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve4(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve4, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve4(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve4, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve4, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve4(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve4, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve4(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve4, reject) {
          var data = iterator2[kStream].read();
          if (data) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            resolve4(createIterResult(data, false));
          } else {
            iterator2[kLastResolve] = resolve4;
            iterator2[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator2[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator2[kLastReject];
          if (reject !== null) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            reject(err);
          }
          iterator2[kError] = err;
          return;
        }
        var resolve4 = iterator2[kLastResolve];
        if (resolve4 !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve4(createIterResult(void 0, true));
        }
        iterator2[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator2));
      return iterator2;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
    "use strict";
    function asyncGeneratorStep(gen, resolve4, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve4(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve4, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve4, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve4, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator2;
      if (iterable && typeof iterable.next === "function") {
        iterator2 = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator2 = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator2 = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator2.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module.exports = from;
  }
});

// ../../node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = __require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream2();
    var Buffer2 = __require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = __require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy2();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder2().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var _require$codes = require_errors().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex2();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../../node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform2();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module.exports = pipeline;
  }
});

// ../../node_modules/readable-stream/readable.js
var require_readable2 = __commonJS({
  "../../node_modules/readable-stream/readable.js"(exports, module) {
    "use strict";
    var Stream = __require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module.exports = Stream.Readable;
      Object.assign(module.exports, Stream);
      module.exports.Stream = Stream;
    } else {
      exports = module.exports = require_stream_readable2();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable2();
      exports.Duplex = require_stream_duplex2();
      exports.Transform = require_stream_transform2();
      exports.PassThrough = require_stream_passthrough2();
      exports.finished = require_end_of_stream();
      exports.pipeline = require_pipeline();
    }
  }
});

// ../../node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../../node_modules/lodash/_arrayPush.js"(exports, module) {
    "use strict";
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module.exports = arrayPush;
  }
});

// ../../node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "../../node_modules/lodash/_isFlattenable.js"(exports, module) {
    "use strict";
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module.exports = isFlattenable;
  }
});

// ../../node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "../../node_modules/lodash/_baseFlatten.js"(exports, module) {
    "use strict";
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module.exports = baseFlatten;
  }
});

// ../../node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "../../node_modules/lodash/flatten.js"(exports, module) {
    "use strict";
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module.exports = flatten;
  }
});

// ../../node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../node_modules/lodash/_nativeCreate.js"(exports, module) {
    "use strict";
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// ../../node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../node_modules/lodash/_hashClear.js"(exports, module) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// ../../node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../node_modules/lodash/_hashDelete.js"(exports, module) {
    "use strict";
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// ../../node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../node_modules/lodash/_hashGet.js"(exports, module) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// ../../node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../node_modules/lodash/_hashHas.js"(exports, module) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// ../../node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../node_modules/lodash/_hashSet.js"(exports, module) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// ../../node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../node_modules/lodash/_Hash.js"(exports, module) {
    "use strict";
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// ../../node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../node_modules/lodash/_listCacheClear.js"(exports, module) {
    "use strict";
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// ../../node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../node_modules/lodash/_assocIndexOf.js"(exports, module) {
    "use strict";
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// ../../node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../node_modules/lodash/_listCacheDelete.js"(exports, module) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// ../../node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../node_modules/lodash/_listCacheGet.js"(exports, module) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// ../../node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../node_modules/lodash/_listCacheHas.js"(exports, module) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// ../../node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../node_modules/lodash/_listCacheSet.js"(exports, module) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// ../../node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../node_modules/lodash/_ListCache.js"(exports, module) {
    "use strict";
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// ../../node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../node_modules/lodash/_Map.js"(exports, module) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// ../../node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../node_modules/lodash/_mapCacheClear.js"(exports, module) {
    "use strict";
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// ../../node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../node_modules/lodash/_isKeyable.js"(exports, module) {
    "use strict";
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// ../../node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../node_modules/lodash/_getMapData.js"(exports, module) {
    "use strict";
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// ../../node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// ../../node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../node_modules/lodash/_mapCacheGet.js"(exports, module) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// ../../node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../node_modules/lodash/_mapCacheHas.js"(exports, module) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// ../../node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../node_modules/lodash/_mapCacheSet.js"(exports, module) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// ../../node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../node_modules/lodash/_MapCache.js"(exports, module) {
    "use strict";
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// ../../node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "../../node_modules/lodash/_setCacheAdd.js"(exports, module) {
    "use strict";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  }
});

// ../../node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "../../node_modules/lodash/_setCacheHas.js"(exports, module) {
    "use strict";
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  }
});

// ../../node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "../../node_modules/lodash/_SetCache.js"(exports, module) {
    "use strict";
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// ../../node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "../../node_modules/lodash/_baseFindIndex.js"(exports, module) {
    "use strict";
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// ../../node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "../../node_modules/lodash/_baseIsNaN.js"(exports, module) {
    "use strict";
    function baseIsNaN(value) {
      return value !== value;
    }
    module.exports = baseIsNaN;
  }
});

// ../../node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "../../node_modules/lodash/_strictIndexOf.js"(exports, module) {
    "use strict";
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// ../../node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "../../node_modules/lodash/_baseIndexOf.js"(exports, module) {
    "use strict";
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// ../../node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "../../node_modules/lodash/_arrayIncludes.js"(exports, module) {
    "use strict";
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module.exports = arrayIncludes;
  }
});

// ../../node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "../../node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    "use strict";
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  }
});

// ../../node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../../node_modules/lodash/_arrayMap.js"(exports, module) {
    "use strict";
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// ../../node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "../../node_modules/lodash/_cacheHas.js"(exports, module) {
    "use strict";
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module.exports = cacheHas;
  }
});

// ../../node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "../../node_modules/lodash/_baseDifference.js"(exports, module) {
    "use strict";
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseDifference;
  }
});

// ../../node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "../../node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    "use strict";
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module.exports = isArrayLikeObject;
  }
});

// ../../node_modules/lodash/difference.js
var require_difference = __commonJS({
  "../../node_modules/lodash/difference.js"(exports, module) {
    "use strict";
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    module.exports = difference;
  }
});

// ../../node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../../node_modules/lodash/_Set.js"(exports, module) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// ../../node_modules/lodash/noop.js
var require_noop = __commonJS({
  "../../node_modules/lodash/noop.js"(exports, module) {
    "use strict";
    function noop2() {
    }
    module.exports = noop2;
  }
});

// ../../node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../../node_modules/lodash/_setToArray.js"(exports, module) {
    "use strict";
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module.exports = setToArray;
  }
});

// ../../node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "../../node_modules/lodash/_createSet.js"(exports, module) {
    "use strict";
    var Set2 = require_Set();
    var noop2 = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values) {
      return new Set2(values);
    };
    module.exports = createSet;
  }
});

// ../../node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "../../node_modules/lodash/_baseUniq.js"(exports, module) {
    "use strict";
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseUniq;
  }
});

// ../../node_modules/lodash/union.js
var require_union = __commonJS({
  "../../node_modules/lodash/union.js"(exports, module) {
    "use strict";
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var baseUniq = require_baseUniq();
    var isArrayLikeObject = require_isArrayLikeObject();
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    module.exports = union;
  }
});

// ../../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/lodash/_overArg.js"(exports, module) {
    "use strict";
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// ../../node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "../../node_modules/lodash/_getPrototype.js"(exports, module) {
    "use strict";
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// ../../node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "../../node_modules/lodash/isPlainObject.js"(exports, module) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject3(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject3;
  }
});

// ../../node_modules/glob/node_modules/minimatch/lib/path.js
var require_path2 = __commonJS({
  "../../node_modules/glob/node_modules/minimatch/lib/path.js"(exports, module) {
    "use strict";
    var isWindows = typeof process === "object" && process && process.platform === "win32";
    module.exports = isWindows ? { sep: "\\" } : { sep: "/" };
  }
});

// ../../node_modules/glob/node_modules/brace-expansion/index.js
var require_brace_expansion3 = __commonJS({
  "../../node_modules/glob/node_modules/brace-expansion/index.js"(exports, module) {
    "use strict";
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand2(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// ../../node_modules/glob/node_modules/minimatch/minimatch.js
var require_minimatch3 = __commonJS({
  "../../node_modules/glob/node_modules/minimatch/minimatch.js"(exports, module) {
    "use strict";
    var minimatch = module.exports = (p, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    module.exports = minimatch;
    var path9 = require_path2();
    minimatch.sep = path9.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR;
    var expand2 = require_brace_expansion3();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      const orig = minimatch;
      const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m.defaults = (options) => orig.defaults(ext(def, options));
      m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m;
    };
    minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand2(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options)
          options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        let re = "";
        let hasMagic = false;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        let dotTravAllowed = pattern.charAt(0) === ".";
        let dotFileAllowed = options.dot || dotTravAllowed;
        const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              if (inClass && pattern.charAt(i + 1) === "-") {
                re += c;
                continue;
              }
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(": {
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              const plEntry = {
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              };
              this.debug(this.pattern, "	", plEntry);
              patternListStack.push(plEntry);
              re += plEntry.open;
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            }
            case ")": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\)";
                continue;
              }
              patternListStack.pop();
              clearStateChar();
              hasMagic = true;
              pl = plEntry;
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(Object.assign(pl, { reEnd: re.length }));
              }
              continue;
            }
            case "|": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              continue;
            }
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                re += c;
              } catch (er) {
                re = re.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = true;
              inClass = false;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.slice(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substring(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const closeParensBefore = nlBefore.split(")").length;
          const openParensBefore = nlBefore.split("(").length - closeParensBefore;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart() + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (options.nocase && !hasMagic) {
          hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        const options = this.options;
        if (path9.sep !== "/") {
          f = f.split(path9.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
    minimatch.Minimatch = Minimatch;
  }
});

// ../../node_modules/glob/common.js
var require_common2 = __commonJS({
  "../../node_modules/glob/common.js"(exports) {
    "use strict";
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs3 = __require("fs");
    var path9 = __require("path");
    var minimatch = require_minimatch3();
    var isAbsolute = __require("path").isAbsolute;
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (self2.windowsPathsNoEscape) {
        pattern = pattern.replace(/\\/g, "/");
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs3;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = path9.resolve(cwd);
      else {
        self2.cwd = path9.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path9.resolve(self2.cwd, "/");
      self2.root = path9.resolve(self2.root);
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      self2.nomount = !!options.nomount;
      if (process.platform === "win32") {
        self2.root = self2.root.replace(/\\/g, "/");
        self2.cwd = self2.cwd.replace(/\\/g, "/");
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      }
      options.nonegate = true;
      options.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path9.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path9.resolve(self2.cwd, f);
      } else {
        abs = path9.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path10) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path10) || !!(item.gmatcher && item.gmatcher.match(path10));
      });
    }
    function childrenIgnored(self2, path10) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path10));
      });
    }
  }
});

// ../../node_modules/glob/sync.js
var require_sync3 = __commonJS({
  "../../node_modules/glob/sync.js"(exports, module) {
    "use strict";
    module.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch3();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob2().Glob;
    var util = __require("util");
    var path9 = __require("path");
    var assert = __require("assert");
    var isAbsolute = __require("path").isAbsolute;
    var common = require_common2();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path9.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path9.join(this.root, prefix);
        } else {
          prefix = path9.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// ../../node_modules/glob/glob.js
var require_glob2 = __commonJS({
  "../../node_modules/glob/glob.js"(exports, module) {
    "use strict";
    module.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch3();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = __require("events").EventEmitter;
    var path9 = __require("path");
    var assert = __require("assert");
    var isAbsolute = __require("path").isAbsolute;
    var globSync = require_sync3();
    var common = require_common2();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = __require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path9.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path9.join(this.root, prefix);
        } else {
          prefix = path9.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// ../../node_modules/archiver-utils/file.js
var require_file2 = __commonJS({
  "../../node_modules/archiver-utils/file.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path9 = __require("path");
    var flatten = require_flatten();
    var difference = require_difference();
    var union = require_union();
    var isPlainObject3 = require_isPlainObject();
    var glob = require_glob2();
    var file = module.exports = {};
    var pathSeparatorRe = /[\/\\]/g;
    var processPatterns = function(patterns, fn) {
      var result = [];
      flatten(patterns).forEach(function(pattern) {
        var exclusion = pattern.indexOf("!") === 0;
        if (exclusion) {
          pattern = pattern.slice(1);
        }
        var matches = fn(pattern);
        if (exclusion) {
          result = difference(result, matches);
        } else {
          result = union(result, matches);
        }
      });
      return result;
    };
    file.exists = function() {
      var filepath = path9.join.apply(path9, arguments);
      return fs3.existsSync(filepath);
    };
    file.expand = function(...args) {
      var options = isPlainObject3(args[0]) ? args.shift() : {};
      var patterns = Array.isArray(args[0]) ? args[0] : args;
      if (patterns.length === 0) {
        return [];
      }
      var matches = processPatterns(patterns, function(pattern) {
        return glob.sync(pattern, options);
      });
      if (options.filter) {
        matches = matches.filter(function(filepath) {
          filepath = path9.join(options.cwd || "", filepath);
          try {
            if (typeof options.filter === "function") {
              return options.filter(filepath);
            } else {
              return fs3.statSync(filepath)[options.filter]();
            }
          } catch (e) {
            return false;
          }
        });
      }
      return matches;
    };
    file.expandMapping = function(patterns, destBase, options) {
      options = Object.assign({
        rename: function(destBase2, destPath) {
          return path9.join(destBase2 || "", destPath);
        }
      }, options);
      var files = [];
      var fileByDest = {};
      file.expand(options, patterns).forEach(function(src) {
        var destPath = src;
        if (options.flatten) {
          destPath = path9.basename(destPath);
        }
        if (options.ext) {
          destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
        }
        var dest = options.rename(destBase, destPath, options);
        if (options.cwd) {
          src = path9.join(options.cwd, src);
        }
        dest = dest.replace(pathSeparatorRe, "/");
        src = src.replace(pathSeparatorRe, "/");
        if (fileByDest[dest]) {
          fileByDest[dest].src.push(src);
        } else {
          files.push({
            src: [src],
            dest
          });
          fileByDest[dest] = files[files.length - 1];
        }
      });
      return files;
    };
    file.normalizeFilesArray = function(data) {
      var files = [];
      data.forEach(function(obj) {
        var prop;
        if ("src" in obj || "dest" in obj) {
          files.push(obj);
        }
      });
      if (files.length === 0) {
        return [];
      }
      files = _(files).chain().forEach(function(obj) {
        if (!("src" in obj) || !obj.src) {
          return;
        }
        if (Array.isArray(obj.src)) {
          obj.src = flatten(obj.src);
        } else {
          obj.src = [obj.src];
        }
      }).map(function(obj) {
        var expandOptions = Object.assign({}, obj);
        delete expandOptions.src;
        delete expandOptions.dest;
        if (obj.expand) {
          return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
            var result2 = Object.assign({}, obj);
            result2.orig = Object.assign({}, obj);
            result2.src = mapObj.src;
            result2.dest = mapObj.dest;
            ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
              delete result2[prop];
            });
            return result2;
          });
        }
        var result = Object.assign({}, obj);
        result.orig = Object.assign({}, obj);
        if ("src" in result) {
          Object.defineProperty(result, "src", {
            enumerable: true,
            get: function fn() {
              var src;
              if (!("result" in fn)) {
                src = obj.src;
                src = Array.isArray(src) ? flatten(src) : [src];
                fn.result = file.expand(expandOptions, src);
              }
              return fn.result;
            }
          });
        }
        if ("dest" in result) {
          result.dest = obj.dest;
        }
        return result;
      }).flatten().value();
      return files;
    };
  }
});

// ../../node_modules/archiver-utils/index.js
var require_archiver_utils = __commonJS({
  "../../node_modules/archiver-utils/index.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path9 = __require("path");
    var lazystream = require_lazystream();
    var normalizePath = require_normalize_path();
    var defaults = require_defaults();
    var Stream = __require("stream").Stream;
    var PassThrough = require_readable2().PassThrough;
    var utils = module.exports = {};
    utils.file = require_file2();
    utils.collectStream = function(source, callback) {
      var collection = [];
      var size = 0;
      source.on("error", callback);
      source.on("data", function(chunk) {
        collection.push(chunk);
        size += chunk.length;
      });
      source.on("end", function() {
        var buf = Buffer.alloc(size);
        var offset = 0;
        collection.forEach(function(data) {
          data.copy(buf, offset);
          offset += data.length;
        });
        callback(null, buf);
      });
    };
    utils.dateify = function(dateish) {
      dateish = dateish || /* @__PURE__ */ new Date();
      if (dateish instanceof Date) {
        dateish = dateish;
      } else if (typeof dateish === "string") {
        dateish = new Date(dateish);
      } else {
        dateish = /* @__PURE__ */ new Date();
      }
      return dateish;
    };
    utils.defaults = function(object, source, guard) {
      var args = arguments;
      args[0] = args[0] || {};
      return defaults(...args);
    };
    utils.isStream = function(source) {
      return source instanceof Stream;
    };
    utils.lazyReadStream = function(filepath) {
      return new lazystream.Readable(function() {
        return fs3.createReadStream(filepath);
      });
    };
    utils.normalizeInputSource = function(source) {
      if (source === null) {
        return Buffer.alloc(0);
      } else if (typeof source === "string") {
        return Buffer.from(source);
      } else if (utils.isStream(source)) {
        return source.pipe(new PassThrough());
      }
      return source;
    };
    utils.sanitizePath = function(filepath) {
      return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
    };
    utils.trailingSlashIt = function(str) {
      return str.slice(-1) !== "/" ? str + "/" : str;
    };
    utils.unixifyPath = function(filepath) {
      return normalizePath(filepath, false).replace(/^\w+:/, "");
    };
    utils.walkdir = function(dirpath, base, callback) {
      var results = [];
      if (typeof base === "function") {
        callback = base;
        base = dirpath;
      }
      fs3.readdir(dirpath, function(err, list) {
        var i = 0;
        var file;
        var filepath;
        if (err) {
          return callback(err);
        }
        (function next() {
          file = list[i++];
          if (!file) {
            return callback(null, results);
          }
          filepath = path9.join(dirpath, file);
          fs3.stat(filepath, function(err2, stats) {
            results.push({
              path: filepath,
              relative: path9.relative(base, filepath).replace(/\\/g, "/"),
              stats
            });
            if (stats && stats.isDirectory()) {
              utils.walkdir(filepath, base, function(err3, res) {
                if (err3) {
                  return callback(err3);
                }
                res.forEach(function(dirEntry) {
                  results.push(dirEntry);
                });
                next();
              });
            } else {
              next();
            }
          });
        })();
      });
    };
  }
});

// ../../node_modules/archiver/lib/error.js
var require_error = __commonJS({
  "../../node_modules/archiver/lib/error.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var ERROR_CODES = {
      "ABORTED": "archive was aborted",
      "DIRECTORYDIRPATHREQUIRED": "diretory dirpath argument must be a non-empty string value",
      "DIRECTORYFUNCTIONINVALIDDATA": "invalid data returned by directory custom data function",
      "ENTRYNAMEREQUIRED": "entry name must be a non-empty string value",
      "FILEFILEPATHREQUIRED": "file filepath argument must be a non-empty string value",
      "FINALIZING": "archive already finalizing",
      "QUEUECLOSED": "queue closed",
      "NOENDMETHOD": "no suitable finalize/end method defined by module",
      "DIRECTORYNOTSUPPORTED": "support for directory entries not defined by module",
      "FORMATSET": "archive format already set",
      "INPUTSTEAMBUFFERREQUIRED": "input source must be valid Stream or Buffer instance",
      "MODULESET": "module already set",
      "SYMLINKNOTSUPPORTED": "support for symlink entries not defined by module",
      "SYMLINKFILEPATHREQUIRED": "symlink filepath argument must be a non-empty string value",
      "SYMLINKTARGETREQUIRED": "symlink target argument must be a non-empty string value",
      "ENTRYNOTSUPPORTED": "entry not supported"
    };
    function ArchiverError(code, data) {
      Error.captureStackTrace(this, this.constructor);
      this.message = ERROR_CODES[code] || code;
      this.code = code;
      this.data = data;
    }
    util.inherits(ArchiverError, Error);
    exports = module.exports = ArchiverError;
  }
});

// ../../node_modules/archiver/lib/core.js
var require_core4 = __commonJS({
  "../../node_modules/archiver/lib/core.js"(exports, module) {
    "use strict";
    var fs3 = __require("fs");
    var glob = require_readdir_glob();
    var async = require_async2();
    var path9 = __require("path");
    var util = require_archiver_utils();
    var inherits = __require("util").inherits;
    var ArchiverError = require_error();
    var Transform = require_readable2().Transform;
    var win32 = process.platform === "win32";
    var Archiver = function(format, options) {
      if (!(this instanceof Archiver)) {
        return new Archiver(format, options);
      }
      if (typeof format !== "string") {
        options = format;
        format = "zip";
      }
      options = this.options = util.defaults(options, {
        highWaterMark: 1024 * 1024,
        statConcurrency: 4
      });
      Transform.call(this, options);
      this._format = false;
      this._module = false;
      this._pending = 0;
      this._pointer = 0;
      this._entriesCount = 0;
      this._entriesProcessedCount = 0;
      this._fsEntriesTotalBytes = 0;
      this._fsEntriesProcessedBytes = 0;
      this._queue = async.queue(this._onQueueTask.bind(this), 1);
      this._queue.drain(this._onQueueDrain.bind(this));
      this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
      this._statQueue.drain(this._onQueueDrain.bind(this));
      this._state = {
        aborted: false,
        finalize: false,
        finalizing: false,
        finalized: false,
        modulePiped: false
      };
      this._streams = [];
    };
    inherits(Archiver, Transform);
    Archiver.prototype._abort = function() {
      this._state.aborted = true;
      this._queue.kill();
      this._statQueue.kill();
      if (this._queue.idle()) {
        this._shutdown();
      }
    };
    Archiver.prototype._append = function(filepath, data) {
      data = data || {};
      var task5 = {
        source: null,
        filepath
      };
      if (!data.name) {
        data.name = filepath;
      }
      data.sourcePath = filepath;
      task5.data = data;
      this._entriesCount++;
      if (data.stats && data.stats instanceof fs3.Stats) {
        task5 = this._updateQueueTaskWithStats(task5, data.stats);
        if (task5) {
          if (data.stats.size) {
            this._fsEntriesTotalBytes += data.stats.size;
          }
          this._queue.push(task5);
        }
      } else {
        this._statQueue.push(task5);
      }
    };
    Archiver.prototype._finalize = function() {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return;
      }
      this._state.finalizing = true;
      this._moduleFinalize();
      this._state.finalizing = false;
      this._state.finalized = true;
    };
    Archiver.prototype._maybeFinalize = function() {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return false;
      }
      if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
        return true;
      }
      return false;
    };
    Archiver.prototype._moduleAppend = function(source, data, callback) {
      if (this._state.aborted) {
        callback();
        return;
      }
      this._module.append(source, data, function(err) {
        this._task = null;
        if (this._state.aborted) {
          this._shutdown();
          return;
        }
        if (err) {
          this.emit("error", err);
          setImmediate(callback);
          return;
        }
        this.emit("entry", data);
        this._entriesProcessedCount++;
        if (data.stats && data.stats.size) {
          this._fsEntriesProcessedBytes += data.stats.size;
        }
        this.emit("progress", {
          entries: {
            total: this._entriesCount,
            processed: this._entriesProcessedCount
          },
          fs: {
            totalBytes: this._fsEntriesTotalBytes,
            processedBytes: this._fsEntriesProcessedBytes
          }
        });
        setImmediate(callback);
      }.bind(this));
    };
    Archiver.prototype._moduleFinalize = function() {
      if (typeof this._module.finalize === "function") {
        this._module.finalize();
      } else if (typeof this._module.end === "function") {
        this._module.end();
      } else {
        this.emit("error", new ArchiverError("NOENDMETHOD"));
      }
    };
    Archiver.prototype._modulePipe = function() {
      this._module.on("error", this._onModuleError.bind(this));
      this._module.pipe(this);
      this._state.modulePiped = true;
    };
    Archiver.prototype._moduleSupports = function(key) {
      if (!this._module.supports || !this._module.supports[key]) {
        return false;
      }
      return this._module.supports[key];
    };
    Archiver.prototype._moduleUnpipe = function() {
      this._module.unpipe(this);
      this._state.modulePiped = false;
    };
    Archiver.prototype._normalizeEntryData = function(data, stats) {
      data = util.defaults(data, {
        type: "file",
        name: null,
        date: null,
        mode: null,
        prefix: null,
        sourcePath: null,
        stats: false
      });
      if (stats && data.stats === false) {
        data.stats = stats;
      }
      var isDir = data.type === "directory";
      if (data.name) {
        if (typeof data.prefix === "string" && "" !== data.prefix) {
          data.name = data.prefix + "/" + data.name;
          data.prefix = null;
        }
        data.name = util.sanitizePath(data.name);
        if (data.type !== "symlink" && data.name.slice(-1) === "/") {
          isDir = true;
          data.type = "directory";
        } else if (isDir) {
          data.name += "/";
        }
      }
      if (typeof data.mode === "number") {
        if (win32) {
          data.mode &= 511;
        } else {
          data.mode &= 4095;
        }
      } else if (data.stats && data.mode === null) {
        if (win32) {
          data.mode = data.stats.mode & 511;
        } else {
          data.mode = data.stats.mode & 4095;
        }
        if (win32 && isDir) {
          data.mode = 493;
        }
      } else if (data.mode === null) {
        data.mode = isDir ? 493 : 420;
      }
      if (data.stats && data.date === null) {
        data.date = data.stats.mtime;
      } else {
        data.date = util.dateify(data.date);
      }
      return data;
    };
    Archiver.prototype._onModuleError = function(err) {
      this.emit("error", err);
    };
    Archiver.prototype._onQueueDrain = function() {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return;
      }
      if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
      }
    };
    Archiver.prototype._onQueueTask = function(task5, callback) {
      var fullCallback = () => {
        if (task5.data.callback) {
          task5.data.callback();
        }
        callback();
      };
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        fullCallback();
        return;
      }
      this._task = task5;
      this._moduleAppend(task5.source, task5.data, fullCallback);
    };
    Archiver.prototype._onStatQueueTask = function(task5, callback) {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        callback();
        return;
      }
      fs3.lstat(task5.filepath, function(err, stats) {
        if (this._state.aborted) {
          setImmediate(callback);
          return;
        }
        if (err) {
          this._entriesCount--;
          this.emit("warning", err);
          setImmediate(callback);
          return;
        }
        task5 = this._updateQueueTaskWithStats(task5, stats);
        if (task5) {
          if (stats.size) {
            this._fsEntriesTotalBytes += stats.size;
          }
          this._queue.push(task5);
        }
        setImmediate(callback);
      }.bind(this));
    };
    Archiver.prototype._shutdown = function() {
      this._moduleUnpipe();
      this.end();
    };
    Archiver.prototype._transform = function(chunk, encoding, callback) {
      if (chunk) {
        this._pointer += chunk.length;
      }
      callback(null, chunk);
    };
    Archiver.prototype._updateQueueTaskWithStats = function(task5, stats) {
      if (stats.isFile()) {
        task5.data.type = "file";
        task5.data.sourceType = "stream";
        task5.source = util.lazyReadStream(task5.filepath);
      } else if (stats.isDirectory() && this._moduleSupports("directory")) {
        task5.data.name = util.trailingSlashIt(task5.data.name);
        task5.data.type = "directory";
        task5.data.sourcePath = util.trailingSlashIt(task5.filepath);
        task5.data.sourceType = "buffer";
        task5.source = Buffer.concat([]);
      } else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
        var linkPath = fs3.readlinkSync(task5.filepath);
        var dirName = path9.dirname(task5.filepath);
        task5.data.type = "symlink";
        task5.data.linkname = path9.relative(dirName, path9.resolve(dirName, linkPath));
        task5.data.sourceType = "buffer";
        task5.source = Buffer.concat([]);
      } else {
        if (stats.isDirectory()) {
          this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task5.data));
        } else if (stats.isSymbolicLink()) {
          this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task5.data));
        } else {
          this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task5.data));
        }
        return null;
      }
      task5.data = this._normalizeEntryData(task5.data, stats);
      return task5;
    };
    Archiver.prototype.abort = function() {
      if (this._state.aborted || this._state.finalized) {
        return this;
      }
      this._abort();
      return this;
    };
    Archiver.prototype.append = function(source, data) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      data = this._normalizeEntryData(data);
      if (typeof data.name !== "string" || data.name.length === 0) {
        this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
        return this;
      }
      if (data.type === "directory" && !this._moduleSupports("directory")) {
        this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", { name: data.name }));
        return this;
      }
      source = util.normalizeInputSource(source);
      if (Buffer.isBuffer(source)) {
        data.sourceType = "buffer";
      } else if (util.isStream(source)) {
        data.sourceType = "stream";
      } else {
        this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", { name: data.name }));
        return this;
      }
      this._entriesCount++;
      this._queue.push({
        data,
        source
      });
      return this;
    };
    Archiver.prototype.directory = function(dirpath, destpath, data) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      if (typeof dirpath !== "string" || dirpath.length === 0) {
        this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
        return this;
      }
      this._pending++;
      if (destpath === false) {
        destpath = "";
      } else if (typeof destpath !== "string") {
        destpath = dirpath;
      }
      var dataFunction = false;
      if (typeof data === "function") {
        dataFunction = data;
        data = {};
      } else if (typeof data !== "object") {
        data = {};
      }
      var globOptions = {
        stat: true,
        dot: true
      };
      function onGlobEnd() {
        this._pending--;
        this._maybeFinalize();
      }
      function onGlobError(err) {
        this.emit("error", err);
      }
      function onGlobMatch(match) {
        globber.pause();
        var ignoreMatch = false;
        var entryData = Object.assign({}, data);
        entryData.name = match.relative;
        entryData.prefix = destpath;
        entryData.stats = match.stat;
        entryData.callback = globber.resume.bind(globber);
        try {
          if (dataFunction) {
            entryData = dataFunction(entryData);
            if (entryData === false) {
              ignoreMatch = true;
            } else if (typeof entryData !== "object") {
              throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", { dirpath });
            }
          }
        } catch (e) {
          this.emit("error", e);
          return;
        }
        if (ignoreMatch) {
          globber.resume();
          return;
        }
        this._append(match.absolute, entryData);
      }
      var globber = glob(dirpath, globOptions);
      globber.on("error", onGlobError.bind(this));
      globber.on("match", onGlobMatch.bind(this));
      globber.on("end", onGlobEnd.bind(this));
      return this;
    };
    Archiver.prototype.file = function(filepath, data) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      if (typeof filepath !== "string" || filepath.length === 0) {
        this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
        return this;
      }
      this._append(filepath, data);
      return this;
    };
    Archiver.prototype.glob = function(pattern, options, data) {
      this._pending++;
      options = util.defaults(options, {
        stat: true,
        pattern
      });
      function onGlobEnd() {
        this._pending--;
        this._maybeFinalize();
      }
      function onGlobError(err) {
        this.emit("error", err);
      }
      function onGlobMatch(match) {
        globber.pause();
        var entryData = Object.assign({}, data);
        entryData.callback = globber.resume.bind(globber);
        entryData.stats = match.stat;
        entryData.name = match.relative;
        this._append(match.absolute, entryData);
      }
      var globber = glob(options.cwd || ".", options);
      globber.on("error", onGlobError.bind(this));
      globber.on("match", onGlobMatch.bind(this));
      globber.on("end", onGlobEnd.bind(this));
      return this;
    };
    Archiver.prototype.finalize = function() {
      if (this._state.aborted) {
        var abortedError = new ArchiverError("ABORTED");
        this.emit("error", abortedError);
        return Promise.reject(abortedError);
      }
      if (this._state.finalize) {
        var finalizingError = new ArchiverError("FINALIZING");
        this.emit("error", finalizingError);
        return Promise.reject(finalizingError);
      }
      this._state.finalize = true;
      if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
      }
      var self2 = this;
      return new Promise(function(resolve4, reject) {
        var errored;
        self2._module.on("end", function() {
          if (!errored) {
            resolve4();
          }
        });
        self2._module.on("error", function(err) {
          errored = true;
          reject(err);
        });
      });
    };
    Archiver.prototype.setFormat = function(format) {
      if (this._format) {
        this.emit("error", new ArchiverError("FORMATSET"));
        return this;
      }
      this._format = format;
      return this;
    };
    Archiver.prototype.setModule = function(module2) {
      if (this._state.aborted) {
        this.emit("error", new ArchiverError("ABORTED"));
        return this;
      }
      if (this._state.module) {
        this.emit("error", new ArchiverError("MODULESET"));
        return this;
      }
      this._module = module2;
      this._modulePipe();
      return this;
    };
    Archiver.prototype.symlink = function(filepath, target, mode) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      if (typeof filepath !== "string" || filepath.length === 0) {
        this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
        return this;
      }
      if (typeof target !== "string" || target.length === 0) {
        this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", { filepath }));
        return this;
      }
      if (!this._moduleSupports("symlink")) {
        this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", { filepath }));
        return this;
      }
      var data = {};
      data.type = "symlink";
      data.name = filepath.replace(/\\/g, "/");
      data.linkname = target.replace(/\\/g, "/");
      data.sourceType = "buffer";
      if (typeof mode === "number") {
        data.mode = mode;
      }
      this._entriesCount++;
      this._queue.push({
        data,
        source: Buffer.concat([])
      });
      return this;
    };
    Archiver.prototype.pointer = function() {
      return this._pointer;
    };
    Archiver.prototype.use = function(plugin) {
      this._streams.push(plugin);
      return this;
    };
    module.exports = Archiver;
  }
});

// ../../node_modules/compress-commons/lib/archivers/archive-entry.js
var require_archive_entry = __commonJS({
  "../../node_modules/compress-commons/lib/archivers/archive-entry.js"(exports, module) {
    "use strict";
    var ArchiveEntry = module.exports = function() {
    };
    ArchiveEntry.prototype.getName = function() {
    };
    ArchiveEntry.prototype.getSize = function() {
    };
    ArchiveEntry.prototype.getLastModifiedDate = function() {
    };
    ArchiveEntry.prototype.isDirectory = function() {
    };
  }
});

// ../../node_modules/compress-commons/lib/archivers/zip/util.js
var require_util2 = __commonJS({
  "../../node_modules/compress-commons/lib/archivers/zip/util.js"(exports, module) {
    "use strict";
    var util = module.exports = {};
    util.dateToDos = function(d, forceLocalTime) {
      forceLocalTime = forceLocalTime || false;
      var year = forceLocalTime ? d.getFullYear() : d.getUTCFullYear();
      if (year < 1980) {
        return 2162688;
      } else if (year >= 2044) {
        return 2141175677;
      }
      var val = {
        year,
        month: forceLocalTime ? d.getMonth() : d.getUTCMonth(),
        date: forceLocalTime ? d.getDate() : d.getUTCDate(),
        hours: forceLocalTime ? d.getHours() : d.getUTCHours(),
        minutes: forceLocalTime ? d.getMinutes() : d.getUTCMinutes(),
        seconds: forceLocalTime ? d.getSeconds() : d.getUTCSeconds()
      };
      return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
    };
    util.dosToDate = function(dos) {
      return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
    };
    util.fromDosTime = function(buf) {
      return util.dosToDate(buf.readUInt32LE(0));
    };
    util.getEightBytes = function(v) {
      var buf = Buffer.alloc(8);
      buf.writeUInt32LE(v % 4294967296, 0);
      buf.writeUInt32LE(v / 4294967296 | 0, 4);
      return buf;
    };
    util.getShortBytes = function(v) {
      var buf = Buffer.alloc(2);
      buf.writeUInt16LE((v & 65535) >>> 0, 0);
      return buf;
    };
    util.getShortBytesValue = function(buf, offset) {
      return buf.readUInt16LE(offset);
    };
    util.getLongBytes = function(v) {
      var buf = Buffer.alloc(4);
      buf.writeUInt32LE((v & 4294967295) >>> 0, 0);
      return buf;
    };
    util.getLongBytesValue = function(buf, offset) {
      return buf.readUInt32LE(offset);
    };
    util.toDosTime = function(d) {
      return util.getLongBytes(util.dateToDos(d));
    };
  }
});

// ../../node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js
var require_general_purpose_bit = __commonJS({
  "../../node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js"(exports, module) {
    "use strict";
    var zipUtil = require_util2();
    var DATA_DESCRIPTOR_FLAG = 1 << 3;
    var ENCRYPTION_FLAG = 1 << 0;
    var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;
    var SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;
    var STRONG_ENCRYPTION_FLAG = 1 << 6;
    var UFT8_NAMES_FLAG = 1 << 11;
    var GeneralPurposeBit = module.exports = function() {
      if (!(this instanceof GeneralPurposeBit)) {
        return new GeneralPurposeBit();
      }
      this.descriptor = false;
      this.encryption = false;
      this.utf8 = false;
      this.numberOfShannonFanoTrees = 0;
      this.strongEncryption = false;
      this.slidingDictionarySize = 0;
      return this;
    };
    GeneralPurposeBit.prototype.encode = function() {
      return zipUtil.getShortBytes(
        (this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0)
      );
    };
    GeneralPurposeBit.prototype.parse = function(buf, offset) {
      var flag = zipUtil.getShortBytesValue(buf, offset);
      var gbp = new GeneralPurposeBit();
      gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
      gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
      gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
      gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
      gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
      gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
      return gbp;
    };
    GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n) {
      this.numberOfShannonFanoTrees = n;
    };
    GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
      return this.numberOfShannonFanoTrees;
    };
    GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n) {
      this.slidingDictionarySize = n;
    };
    GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
      return this.slidingDictionarySize;
    };
    GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
      this.descriptor = b;
    };
    GeneralPurposeBit.prototype.usesDataDescriptor = function() {
      return this.descriptor;
    };
    GeneralPurposeBit.prototype.useEncryption = function(b) {
      this.encryption = b;
    };
    GeneralPurposeBit.prototype.usesEncryption = function() {
      return this.encryption;
    };
    GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
      this.strongEncryption = b;
    };
    GeneralPurposeBit.prototype.usesStrongEncryption = function() {
      return this.strongEncryption;
    };
    GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
      this.utf8 = b;
    };
    GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
      return this.utf8;
    };
  }
});

// ../../node_modules/compress-commons/lib/archivers/zip/unix-stat.js
var require_unix_stat = __commonJS({
  "../../node_modules/compress-commons/lib/archivers/zip/unix-stat.js"(exports, module) {
    "use strict";
    module.exports = {
      /**
       * Bits used for permissions (and sticky bit)
       */
      PERM_MASK: 4095,
      // 07777
      /**
       * Bits used to indicate the filesystem object type.
       */
      FILE_TYPE_FLAG: 61440,
      // 0170000
      /**
       * Indicates symbolic links.
       */
      LINK_FLAG: 40960,
      // 0120000
      /**
       * Indicates plain files.
       */
      FILE_FLAG: 32768,
      // 0100000
      /**
       * Indicates directories.
       */
      DIR_FLAG: 16384,
      // 040000
      // ----------------------------------------------------------
      // somewhat arbitrary choices that are quite common for shared
      // installations
      // -----------------------------------------------------------
      /**
       * Default permissions for symbolic links.
       */
      DEFAULT_LINK_PERM: 511,
      // 0777
      /**
       * Default permissions for directories.
       */
      DEFAULT_DIR_PERM: 493,
      // 0755
      /**
       * Default permissions for plain files.
       */
      DEFAULT_FILE_PERM: 420
      // 0644
    };
  }
});

// ../../node_modules/compress-commons/lib/archivers/zip/constants.js
var require_constants = __commonJS({
  "../../node_modules/compress-commons/lib/archivers/zip/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      WORD: 4,
      DWORD: 8,
      EMPTY: Buffer.alloc(0),
      SHORT: 2,
      SHORT_MASK: 65535,
      SHORT_SHIFT: 16,
      SHORT_ZERO: Buffer.from(Array(2)),
      LONG: 4,
      LONG_ZERO: Buffer.from(Array(4)),
      MIN_VERSION_INITIAL: 10,
      MIN_VERSION_DATA_DESCRIPTOR: 20,
      MIN_VERSION_ZIP64: 45,
      VERSION_MADEBY: 45,
      METHOD_STORED: 0,
      METHOD_DEFLATED: 8,
      PLATFORM_UNIX: 3,
      PLATFORM_FAT: 0,
      SIG_LFH: 67324752,
      SIG_DD: 134695760,
      SIG_CFH: 33639248,
      SIG_EOCD: 101010256,
      SIG_ZIP64_EOCD: 101075792,
      SIG_ZIP64_EOCD_LOC: 117853008,
      ZIP64_MAGIC_SHORT: 65535,
      ZIP64_MAGIC: 4294967295,
      ZIP64_EXTRA_ID: 1,
      ZLIB_NO_COMPRESSION: 0,
      ZLIB_BEST_SPEED: 1,
      ZLIB_BEST_COMPRESSION: 9,
      ZLIB_DEFAULT_COMPRESSION: -1,
      MODE_MASK: 4095,
      DEFAULT_FILE_MODE: 33188,
      // 010644 = -rw-r--r-- = S_IFREG | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH
      DEFAULT_DIR_MODE: 16877,
      // 040755 = drwxr-xr-x = S_IFDIR | S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH
      EXT_FILE_ATTR_DIR: 1106051088,
      // 010173200020 = drwxr-xr-x = (((S_IFDIR | 0755) << 16) | S_DOS_D)
      EXT_FILE_ATTR_FILE: 2175008800,
      // 020151000040 = -rw-r--r-- = (((S_IFREG | 0644) << 16) | S_DOS_A) >>> 0
      // Unix file types
      S_IFMT: 61440,
      // 0170000 type of file mask
      S_IFIFO: 4096,
      // 010000 named pipe (fifo)
      S_IFCHR: 8192,
      // 020000 character special
      S_IFDIR: 16384,
      // 040000 directory
      S_IFBLK: 24576,
      // 060000 block special
      S_IFREG: 32768,
      // 0100000 regular
      S_IFLNK: 40960,
      // 0120000 symbolic link
      S_IFSOCK: 49152,
      // 0140000 socket
      // DOS file type flags
      S_DOS_A: 32,
      // 040 Archive
      S_DOS_D: 16,
      // 020 Directory
      S_DOS_V: 8,
      // 010 Volume
      S_DOS_S: 4,
      // 04 System
      S_DOS_H: 2,
      // 02 Hidden
      S_DOS_R: 1
      // 01 Read Only
    };
  }
});

// ../../node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js
var require_zip_archive_entry = __commonJS({
  "../../node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js"(exports, module) {
    "use strict";
    var inherits = __require("util").inherits;
    var normalizePath = require_normalize_path();
    var ArchiveEntry = require_archive_entry();
    var GeneralPurposeBit = require_general_purpose_bit();
    var UnixStat = require_unix_stat();
    var constants = require_constants();
    var zipUtil = require_util2();
    var ZipArchiveEntry = module.exports = function(name) {
      if (!(this instanceof ZipArchiveEntry)) {
        return new ZipArchiveEntry(name);
      }
      ArchiveEntry.call(this);
      this.platform = constants.PLATFORM_FAT;
      this.method = -1;
      this.name = null;
      this.size = 0;
      this.csize = 0;
      this.gpb = new GeneralPurposeBit();
      this.crc = 0;
      this.time = -1;
      this.minver = constants.MIN_VERSION_INITIAL;
      this.mode = -1;
      this.extra = null;
      this.exattr = 0;
      this.inattr = 0;
      this.comment = null;
      if (name) {
        this.setName(name);
      }
    };
    inherits(ZipArchiveEntry, ArchiveEntry);
    ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
      return this.getExtra();
    };
    ZipArchiveEntry.prototype.getComment = function() {
      return this.comment !== null ? this.comment : "";
    };
    ZipArchiveEntry.prototype.getCompressedSize = function() {
      return this.csize;
    };
    ZipArchiveEntry.prototype.getCrc = function() {
      return this.crc;
    };
    ZipArchiveEntry.prototype.getExternalAttributes = function() {
      return this.exattr;
    };
    ZipArchiveEntry.prototype.getExtra = function() {
      return this.extra !== null ? this.extra : constants.EMPTY;
    };
    ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
      return this.gpb;
    };
    ZipArchiveEntry.prototype.getInternalAttributes = function() {
      return this.inattr;
    };
    ZipArchiveEntry.prototype.getLastModifiedDate = function() {
      return this.getTime();
    };
    ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
      return this.getExtra();
    };
    ZipArchiveEntry.prototype.getMethod = function() {
      return this.method;
    };
    ZipArchiveEntry.prototype.getName = function() {
      return this.name;
    };
    ZipArchiveEntry.prototype.getPlatform = function() {
      return this.platform;
    };
    ZipArchiveEntry.prototype.getSize = function() {
      return this.size;
    };
    ZipArchiveEntry.prototype.getTime = function() {
      return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
    };
    ZipArchiveEntry.prototype.getTimeDos = function() {
      return this.time !== -1 ? this.time : 0;
    };
    ZipArchiveEntry.prototype.getUnixMode = function() {
      return this.platform !== constants.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants.SHORT_SHIFT & constants.SHORT_MASK;
    };
    ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
      return this.minver;
    };
    ZipArchiveEntry.prototype.setComment = function(comment) {
      if (Buffer.byteLength(comment) !== comment.length) {
        this.getGeneralPurposeBit().useUTF8ForNames(true);
      }
      this.comment = comment;
    };
    ZipArchiveEntry.prototype.setCompressedSize = function(size) {
      if (size < 0) {
        throw new Error("invalid entry compressed size");
      }
      this.csize = size;
    };
    ZipArchiveEntry.prototype.setCrc = function(crc) {
      if (crc < 0) {
        throw new Error("invalid entry crc32");
      }
      this.crc = crc;
    };
    ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
      this.exattr = attr >>> 0;
    };
    ZipArchiveEntry.prototype.setExtra = function(extra) {
      this.extra = extra;
    };
    ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
      if (!(gpb instanceof GeneralPurposeBit)) {
        throw new Error("invalid entry GeneralPurposeBit");
      }
      this.gpb = gpb;
    };
    ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
      this.inattr = attr;
    };
    ZipArchiveEntry.prototype.setMethod = function(method) {
      if (method < 0) {
        throw new Error("invalid entry compression method");
      }
      this.method = method;
    };
    ZipArchiveEntry.prototype.setName = function(name, prependSlash = false) {
      name = normalizePath(name, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
      if (prependSlash) {
        name = `/${name}`;
      }
      if (Buffer.byteLength(name) !== name.length) {
        this.getGeneralPurposeBit().useUTF8ForNames(true);
      }
      this.name = name;
    };
    ZipArchiveEntry.prototype.setPlatform = function(platform) {
      this.platform = platform;
    };
    ZipArchiveEntry.prototype.setSize = function(size) {
      if (size < 0) {
        throw new Error("invalid entry size");
      }
      this.size = size;
    };
    ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
      if (!(time instanceof Date)) {
        throw new Error("invalid entry time");
      }
      this.time = zipUtil.dateToDos(time, forceLocalTime);
    };
    ZipArchiveEntry.prototype.setUnixMode = function(mode) {
      mode |= this.isDirectory() ? constants.S_IFDIR : constants.S_IFREG;
      var extattr = 0;
      extattr |= mode << constants.SHORT_SHIFT | (this.isDirectory() ? constants.S_DOS_D : constants.S_DOS_A);
      this.setExternalAttributes(extattr);
      this.mode = mode & constants.MODE_MASK;
      this.platform = constants.PLATFORM_UNIX;
    };
    ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
      this.minver = minver;
    };
    ZipArchiveEntry.prototype.isDirectory = function() {
      return this.getName().slice(-1) === "/";
    };
    ZipArchiveEntry.prototype.isUnixSymlink = function() {
      return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
    };
    ZipArchiveEntry.prototype.isZip64 = function() {
      return this.csize > constants.ZIP64_MAGIC || this.size > constants.ZIP64_MAGIC;
    };
  }
});

// ../../node_modules/compress-commons/lib/util/index.js
var require_util3 = __commonJS({
  "../../node_modules/compress-commons/lib/util/index.js"(exports, module) {
    "use strict";
    var Stream = __require("stream").Stream;
    var PassThrough = require_readable2().PassThrough;
    var util = module.exports = {};
    util.isStream = function(source) {
      return source instanceof Stream;
    };
    util.normalizeInputSource = function(source) {
      if (source === null) {
        return Buffer.alloc(0);
      } else if (typeof source === "string") {
        return Buffer.from(source);
      } else if (util.isStream(source) && !source._readableState) {
        var normalized = new PassThrough();
        source.pipe(normalized);
        return normalized;
      }
      return source;
    };
  }
});

// ../../node_modules/compress-commons/lib/archivers/archive-output-stream.js
var require_archive_output_stream = __commonJS({
  "../../node_modules/compress-commons/lib/archivers/archive-output-stream.js"(exports, module) {
    "use strict";
    var inherits = __require("util").inherits;
    var Transform = require_readable2().Transform;
    var ArchiveEntry = require_archive_entry();
    var util = require_util3();
    var ArchiveOutputStream = module.exports = function(options) {
      if (!(this instanceof ArchiveOutputStream)) {
        return new ArchiveOutputStream(options);
      }
      Transform.call(this, options);
      this.offset = 0;
      this._archive = {
        finish: false,
        finished: false,
        processing: false
      };
    };
    inherits(ArchiveOutputStream, Transform);
    ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {
    };
    ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {
    };
    ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
      if (err) {
        this.emit("error", err);
      }
    };
    ArchiveOutputStream.prototype._finish = function(ae) {
    };
    ArchiveOutputStream.prototype._normalizeEntry = function(ae) {
    };
    ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
      callback(null, chunk);
    };
    ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
      source = source || null;
      if (typeof callback !== "function") {
        callback = this._emitErrorCallback.bind(this);
      }
      if (!(ae instanceof ArchiveEntry)) {
        callback(new Error("not a valid instance of ArchiveEntry"));
        return;
      }
      if (this._archive.finish || this._archive.finished) {
        callback(new Error("unacceptable entry after finish"));
        return;
      }
      if (this._archive.processing) {
        callback(new Error("already processing an entry"));
        return;
      }
      this._archive.processing = true;
      this._normalizeEntry(ae);
      this._entry = ae;
      source = util.normalizeInputSource(source);
      if (Buffer.isBuffer(source)) {
        this._appendBuffer(ae, source, callback);
      } else if (util.isStream(source)) {
        this._appendStream(ae, source, callback);
      } else {
        this._archive.processing = false;
        callback(new Error("input source must be valid Stream or Buffer instance"));
        return;
      }
      return this;
    };
    ArchiveOutputStream.prototype.finish = function() {
      if (this._archive.processing) {
        this._archive.finish = true;
        return;
      }
      this._finish();
    };
    ArchiveOutputStream.prototype.getBytesWritten = function() {
      return this.offset;
    };
    ArchiveOutputStream.prototype.write = function(chunk, cb) {
      if (chunk) {
        this.offset += chunk.length;
      }
      return Transform.prototype.write.call(this, chunk, cb);
    };
  }
});

// ../../node_modules/crc-32/crc32.js
var require_crc32 = __commonJS({
  "../../node_modules/crc-32/crc32.js"(exports) {
    "use strict";
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module2 = {};
            factory(module2);
            return module2;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "1.2.2";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T0 = signed_crc_table();
      function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n = 0; n != 256; ++n)
          table[n] = T[n];
        for (n = 0; n != 256; ++n) {
          v = T[n];
          for (c = 256 + n; c < 4096; c += 256)
            v = table[c] = v >>> 8 ^ T[v & 255];
        }
        var out = [];
        for (n = 1; n != 16; ++n)
          out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = bstr.length; i < L; )
          C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
        return ~C;
      }
      function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i = 0;
        for (; i < L; )
          C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
        L += 15;
        while (i < L)
          C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
        return ~C;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T0[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          }
        }
        return ~C;
      }
      CRC322.table = T0;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// ../../node_modules/crc32-stream/lib/crc32-stream.js
var require_crc32_stream = __commonJS({
  "../../node_modules/crc32-stream/lib/crc32-stream.js"(exports, module) {
    "use strict";
    var { Transform } = require_readable2();
    var crc32 = require_crc32();
    var CRC32Stream = class extends Transform {
      constructor(options) {
        super(options);
        this.checksum = Buffer.allocUnsafe(4);
        this.checksum.writeInt32BE(0, 0);
        this.rawSize = 0;
      }
      _transform(chunk, encoding, callback) {
        if (chunk) {
          this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
          this.rawSize += chunk.length;
        }
        callback(null, chunk);
      }
      digest(encoding) {
        const checksum = Buffer.allocUnsafe(4);
        checksum.writeUInt32BE(this.checksum >>> 0, 0);
        return encoding ? checksum.toString(encoding) : checksum;
      }
      hex() {
        return this.digest("hex").toUpperCase();
      }
      size() {
        return this.rawSize;
      }
    };
    module.exports = CRC32Stream;
  }
});

// ../../node_modules/crc32-stream/lib/deflate-crc32-stream.js
var require_deflate_crc32_stream = __commonJS({
  "../../node_modules/crc32-stream/lib/deflate-crc32-stream.js"(exports, module) {
    "use strict";
    var { DeflateRaw } = __require("zlib");
    var crc32 = require_crc32();
    var DeflateCRC32Stream = class extends DeflateRaw {
      constructor(options) {
        super(options);
        this.checksum = Buffer.allocUnsafe(4);
        this.checksum.writeInt32BE(0, 0);
        this.rawSize = 0;
        this.compressedSize = 0;
      }
      push(chunk, encoding) {
        if (chunk) {
          this.compressedSize += chunk.length;
        }
        return super.push(chunk, encoding);
      }
      _transform(chunk, encoding, callback) {
        if (chunk) {
          this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
          this.rawSize += chunk.length;
        }
        super._transform(chunk, encoding, callback);
      }
      digest(encoding) {
        const checksum = Buffer.allocUnsafe(4);
        checksum.writeUInt32BE(this.checksum >>> 0, 0);
        return encoding ? checksum.toString(encoding) : checksum;
      }
      hex() {
        return this.digest("hex").toUpperCase();
      }
      size(compressed = false) {
        if (compressed) {
          return this.compressedSize;
        } else {
          return this.rawSize;
        }
      }
    };
    module.exports = DeflateCRC32Stream;
  }
});

// ../../node_modules/crc32-stream/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/crc32-stream/lib/index.js"(exports, module) {
    "use strict";
    module.exports = {
      CRC32Stream: require_crc32_stream(),
      DeflateCRC32Stream: require_deflate_crc32_stream()
    };
  }
});

// ../../node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js
var require_zip_archive_output_stream = __commonJS({
  "../../node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js"(exports, module) {
    "use strict";
    var inherits = __require("util").inherits;
    var crc32 = require_crc32();
    var { CRC32Stream } = require_lib3();
    var { DeflateCRC32Stream } = require_lib3();
    var ArchiveOutputStream = require_archive_output_stream();
    var ZipArchiveEntry = require_zip_archive_entry();
    var GeneralPurposeBit = require_general_purpose_bit();
    var constants = require_constants();
    var util = require_util3();
    var zipUtil = require_util2();
    var ZipArchiveOutputStream = module.exports = function(options) {
      if (!(this instanceof ZipArchiveOutputStream)) {
        return new ZipArchiveOutputStream(options);
      }
      options = this.options = this._defaults(options);
      ArchiveOutputStream.call(this, options);
      this._entry = null;
      this._entries = [];
      this._archive = {
        centralLength: 0,
        centralOffset: 0,
        comment: "",
        finish: false,
        finished: false,
        processing: false,
        forceZip64: options.forceZip64,
        forceLocalTime: options.forceLocalTime
      };
    };
    inherits(ZipArchiveOutputStream, ArchiveOutputStream);
    ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
      this._entries.push(ae);
      if (ae.getGeneralPurposeBit().usesDataDescriptor()) {
        this._writeDataDescriptor(ae);
      }
      this._archive.processing = false;
      this._entry = null;
      if (this._archive.finish && !this._archive.finished) {
        this._finish();
      }
    };
    ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
      if (source.length === 0) {
        ae.setMethod(constants.METHOD_STORED);
      }
      var method = ae.getMethod();
      if (method === constants.METHOD_STORED) {
        ae.setSize(source.length);
        ae.setCompressedSize(source.length);
        ae.setCrc(crc32.buf(source) >>> 0);
      }
      this._writeLocalFileHeader(ae);
      if (method === constants.METHOD_STORED) {
        this.write(source);
        this._afterAppend(ae);
        callback(null, ae);
        return;
      } else if (method === constants.METHOD_DEFLATED) {
        this._smartStream(ae, callback).end(source);
        return;
      } else {
        callback(new Error("compression method " + method + " not implemented"));
        return;
      }
    };
    ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
      ae.getGeneralPurposeBit().useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
      this._writeLocalFileHeader(ae);
      var smart = this._smartStream(ae, callback);
      source.once("error", function(err) {
        smart.emit("error", err);
        smart.end();
      });
      source.pipe(smart);
    };
    ZipArchiveOutputStream.prototype._defaults = function(o) {
      if (typeof o !== "object") {
        o = {};
      }
      if (typeof o.zlib !== "object") {
        o.zlib = {};
      }
      if (typeof o.zlib.level !== "number") {
        o.zlib.level = constants.ZLIB_BEST_SPEED;
      }
      o.forceZip64 = !!o.forceZip64;
      o.forceLocalTime = !!o.forceLocalTime;
      return o;
    };
    ZipArchiveOutputStream.prototype._finish = function() {
      this._archive.centralOffset = this.offset;
      this._entries.forEach(function(ae) {
        this._writeCentralFileHeader(ae);
      }.bind(this));
      this._archive.centralLength = this.offset - this._archive.centralOffset;
      if (this.isZip64()) {
        this._writeCentralDirectoryZip64();
      }
      this._writeCentralDirectoryEnd();
      this._archive.processing = false;
      this._archive.finish = true;
      this._archive.finished = true;
      this.end();
    };
    ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
      if (ae.getMethod() === -1) {
        ae.setMethod(constants.METHOD_DEFLATED);
      }
      if (ae.getMethod() === constants.METHOD_DEFLATED) {
        ae.getGeneralPurposeBit().useDataDescriptor(true);
        ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
      }
      if (ae.getTime() === -1) {
        ae.setTime(/* @__PURE__ */ new Date(), this._archive.forceLocalTime);
      }
      ae._offsets = {
        file: 0,
        data: 0,
        contents: 0
      };
    };
    ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
      var deflate = ae.getMethod() === constants.METHOD_DEFLATED;
      var process3 = deflate ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream();
      var error = null;
      function handleStuff() {
        var digest = process3.digest().readUInt32BE(0);
        ae.setCrc(digest);
        ae.setSize(process3.size());
        ae.setCompressedSize(process3.size(true));
        this._afterAppend(ae);
        callback(error, ae);
      }
      process3.once("end", handleStuff.bind(this));
      process3.once("error", function(err) {
        error = err;
      });
      process3.pipe(this, { end: false });
      return process3;
    };
    ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
      var records = this._entries.length;
      var size = this._archive.centralLength;
      var offset = this._archive.centralOffset;
      if (this.isZip64()) {
        records = constants.ZIP64_MAGIC_SHORT;
        size = constants.ZIP64_MAGIC;
        offset = constants.ZIP64_MAGIC;
      }
      this.write(zipUtil.getLongBytes(constants.SIG_EOCD));
      this.write(constants.SHORT_ZERO);
      this.write(constants.SHORT_ZERO);
      this.write(zipUtil.getShortBytes(records));
      this.write(zipUtil.getShortBytes(records));
      this.write(zipUtil.getLongBytes(size));
      this.write(zipUtil.getLongBytes(offset));
      var comment = this.getComment();
      var commentLength = Buffer.byteLength(comment);
      this.write(zipUtil.getShortBytes(commentLength));
      this.write(comment);
    };
    ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
      this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD));
      this.write(zipUtil.getEightBytes(44));
      this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
      this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
      this.write(zipUtil.getEightBytes(this._entries.length));
      this.write(zipUtil.getEightBytes(this._entries.length));
      this.write(zipUtil.getEightBytes(this._archive.centralLength));
      this.write(zipUtil.getEightBytes(this._archive.centralOffset));
      this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC));
      this.write(constants.LONG_ZERO);
      this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
      this.write(zipUtil.getLongBytes(1));
    };
    ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
      var gpb = ae.getGeneralPurposeBit();
      var method = ae.getMethod();
      var fileOffset = ae._offsets.file;
      var size = ae.getSize();
      var compressedSize = ae.getCompressedSize();
      if (ae.isZip64() || fileOffset > constants.ZIP64_MAGIC) {
        size = constants.ZIP64_MAGIC;
        compressedSize = constants.ZIP64_MAGIC;
        fileOffset = constants.ZIP64_MAGIC;
        ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
        var extraBuf = Buffer.concat([
          zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID),
          zipUtil.getShortBytes(24),
          zipUtil.getEightBytes(ae.getSize()),
          zipUtil.getEightBytes(ae.getCompressedSize()),
          zipUtil.getEightBytes(ae._offsets.file)
        ], 28);
        ae.setExtra(extraBuf);
      }
      this.write(zipUtil.getLongBytes(constants.SIG_CFH));
      this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY));
      this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
      this.write(gpb.encode());
      this.write(zipUtil.getShortBytes(method));
      this.write(zipUtil.getLongBytes(ae.getTimeDos()));
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      this.write(zipUtil.getLongBytes(compressedSize));
      this.write(zipUtil.getLongBytes(size));
      var name = ae.getName();
      var comment = ae.getComment();
      var extra = ae.getCentralDirectoryExtra();
      if (gpb.usesUTF8ForNames()) {
        name = Buffer.from(name);
        comment = Buffer.from(comment);
      }
      this.write(zipUtil.getShortBytes(name.length));
      this.write(zipUtil.getShortBytes(extra.length));
      this.write(zipUtil.getShortBytes(comment.length));
      this.write(constants.SHORT_ZERO);
      this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
      this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
      this.write(zipUtil.getLongBytes(fileOffset));
      this.write(name);
      this.write(extra);
      this.write(comment);
    };
    ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
      this.write(zipUtil.getLongBytes(constants.SIG_DD));
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      if (ae.isZip64()) {
        this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
        this.write(zipUtil.getEightBytes(ae.getSize()));
      } else {
        this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
        this.write(zipUtil.getLongBytes(ae.getSize()));
      }
    };
    ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
      var gpb = ae.getGeneralPurposeBit();
      var method = ae.getMethod();
      var name = ae.getName();
      var extra = ae.getLocalFileDataExtra();
      if (ae.isZip64()) {
        gpb.useDataDescriptor(true);
        ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
      }
      if (gpb.usesUTF8ForNames()) {
        name = Buffer.from(name);
      }
      ae._offsets.file = this.offset;
      this.write(zipUtil.getLongBytes(constants.SIG_LFH));
      this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
      this.write(gpb.encode());
      this.write(zipUtil.getShortBytes(method));
      this.write(zipUtil.getLongBytes(ae.getTimeDos()));
      ae._offsets.data = this.offset;
      if (gpb.usesDataDescriptor()) {
        this.write(constants.LONG_ZERO);
        this.write(constants.LONG_ZERO);
        this.write(constants.LONG_ZERO);
      } else {
        this.write(zipUtil.getLongBytes(ae.getCrc()));
        this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
        this.write(zipUtil.getLongBytes(ae.getSize()));
      }
      this.write(zipUtil.getShortBytes(name.length));
      this.write(zipUtil.getShortBytes(extra.length));
      this.write(name);
      this.write(extra);
      ae._offsets.contents = this.offset;
    };
    ZipArchiveOutputStream.prototype.getComment = function(comment) {
      return this._archive.comment !== null ? this._archive.comment : "";
    };
    ZipArchiveOutputStream.prototype.isZip64 = function() {
      return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;
    };
    ZipArchiveOutputStream.prototype.setComment = function(comment) {
      this._archive.comment = comment;
    };
  }
});

// ../../node_modules/compress-commons/lib/compress-commons.js
var require_compress_commons = __commonJS({
  "../../node_modules/compress-commons/lib/compress-commons.js"(exports, module) {
    "use strict";
    module.exports = {
      ArchiveEntry: require_archive_entry(),
      ZipArchiveEntry: require_zip_archive_entry(),
      ArchiveOutputStream: require_archive_output_stream(),
      ZipArchiveOutputStream: require_zip_archive_output_stream()
    };
  }
});

// ../../node_modules/zip-stream/index.js
var require_zip_stream = __commonJS({
  "../../node_modules/zip-stream/index.js"(exports, module) {
    "use strict";
    var inherits = __require("util").inherits;
    var ZipArchiveOutputStream = require_compress_commons().ZipArchiveOutputStream;
    var ZipArchiveEntry = require_compress_commons().ZipArchiveEntry;
    var util = require_archiver_utils();
    var ZipStream = module.exports = function(options) {
      if (!(this instanceof ZipStream)) {
        return new ZipStream(options);
      }
      options = this.options = options || {};
      options.zlib = options.zlib || {};
      ZipArchiveOutputStream.call(this, options);
      if (typeof options.level === "number" && options.level >= 0) {
        options.zlib.level = options.level;
        delete options.level;
      }
      if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) {
        options.store = true;
      }
      options.namePrependSlash = options.namePrependSlash || false;
      if (options.comment && options.comment.length > 0) {
        this.setComment(options.comment);
      }
    };
    inherits(ZipStream, ZipArchiveOutputStream);
    ZipStream.prototype._normalizeFileData = function(data) {
      data = util.defaults(data, {
        type: "file",
        name: null,
        namePrependSlash: this.options.namePrependSlash,
        linkname: null,
        date: null,
        mode: null,
        store: this.options.store,
        comment: ""
      });
      var isDir = data.type === "directory";
      var isSymlink = data.type === "symlink";
      if (data.name) {
        data.name = util.sanitizePath(data.name);
        if (!isSymlink && data.name.slice(-1) === "/") {
          isDir = true;
          data.type = "directory";
        } else if (isDir) {
          data.name += "/";
        }
      }
      if (isDir || isSymlink) {
        data.store = true;
      }
      data.date = util.dateify(data.date);
      return data;
    };
    ZipStream.prototype.entry = function(source, data, callback) {
      if (typeof callback !== "function") {
        callback = this._emitErrorCallback.bind(this);
      }
      data = this._normalizeFileData(data);
      if (data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
        callback(new Error(data.type + " entries not currently supported"));
        return;
      }
      if (typeof data.name !== "string" || data.name.length === 0) {
        callback(new Error("entry name must be a non-empty string value"));
        return;
      }
      if (data.type === "symlink" && typeof data.linkname !== "string") {
        callback(new Error("entry linkname must be a non-empty string value when type equals symlink"));
        return;
      }
      var entry = new ZipArchiveEntry(data.name);
      entry.setTime(data.date, this.options.forceLocalTime);
      if (data.namePrependSlash) {
        entry.setName(data.name, true);
      }
      if (data.store) {
        entry.setMethod(0);
      }
      if (data.comment.length > 0) {
        entry.setComment(data.comment);
      }
      if (data.type === "symlink" && typeof data.mode !== "number") {
        data.mode = 40960;
      }
      if (typeof data.mode === "number") {
        if (data.type === "symlink") {
          data.mode |= 40960;
        }
        entry.setUnixMode(data.mode);
      }
      if (data.type === "symlink" && typeof data.linkname === "string") {
        source = Buffer.from(data.linkname);
      }
      return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
    };
    ZipStream.prototype.finalize = function() {
      this.finish();
    };
  }
});

// ../../node_modules/archiver/lib/plugins/zip.js
var require_zip = __commonJS({
  "../../node_modules/archiver/lib/plugins/zip.js"(exports, module) {
    "use strict";
    var engine = require_zip_stream();
    var util = require_archiver_utils();
    var Zip2 = function(options) {
      if (!(this instanceof Zip2)) {
        return new Zip2(options);
      }
      options = this.options = util.defaults(options, {
        comment: "",
        forceUTC: false,
        namePrependSlash: false,
        store: false
      });
      this.supports = {
        directory: true,
        symlink: true
      };
      this.engine = new engine(options);
    };
    Zip2.prototype.append = function(source, data, callback) {
      this.engine.entry(source, data, callback);
    };
    Zip2.prototype.finalize = function() {
      this.engine.finalize();
    };
    Zip2.prototype.on = function() {
      return this.engine.on.apply(this.engine, arguments);
    };
    Zip2.prototype.pipe = function() {
      return this.engine.pipe.apply(this.engine, arguments);
    };
    Zip2.prototype.unpipe = function() {
      return this.engine.unpipe.apply(this.engine, arguments);
    };
    module.exports = Zip2;
  }
});

// ../../node_modules/queue-tick/queue-microtask.js
var require_queue_microtask = __commonJS({
  "../../node_modules/queue-tick/queue-microtask.js"(exports, module) {
    "use strict";
    module.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
  }
});

// ../../node_modules/queue-tick/process-next-tick.js
var require_process_next_tick = __commonJS({
  "../../node_modules/queue-tick/process-next-tick.js"(exports, module) {
    "use strict";
    module.exports = typeof process !== "undefined" && typeof process.nextTick === "function" ? process.nextTick.bind(process) : require_queue_microtask();
  }
});

// ../../node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS({
  "../../node_modules/fast-fifo/fixed-size.js"(exports, module) {
    "use strict";
    module.exports = class FixedFIFO {
      constructor(hwm) {
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
          throw new Error("Max size for a FixedFIFO should be a power of two");
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
      }
      clear() {
        this.top = this.btm = 0;
        this.next = null;
        this.buffer.fill(void 0);
      }
      push(data) {
        if (this.buffer[this.top] !== void 0)
          return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
      }
      shift() {
        const last = this.buffer[this.btm];
        if (last === void 0)
          return void 0;
        this.buffer[this.btm] = void 0;
        this.btm = this.btm + 1 & this.mask;
        return last;
      }
      peek() {
        return this.buffer[this.btm];
      }
      isEmpty() {
        return this.buffer[this.btm] === void 0;
      }
    };
  }
});

// ../../node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS({
  "../../node_modules/fast-fifo/index.js"(exports, module) {
    "use strict";
    var FixedFIFO = require_fixed_size();
    module.exports = class FastFIFO {
      constructor(hwm) {
        this.hwm = hwm || 16;
        this.head = new FixedFIFO(this.hwm);
        this.tail = this.head;
        this.length = 0;
      }
      clear() {
        this.head = this.tail;
        this.head.clear();
        this.length = 0;
      }
      push(val) {
        this.length++;
        if (!this.head.push(val)) {
          const prev = this.head;
          this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
          this.head.push(val);
        }
      }
      shift() {
        if (this.length !== 0)
          this.length--;
        const val = this.tail.shift();
        if (val === void 0 && this.tail.next) {
          const next = this.tail.next;
          this.tail.next = null;
          this.tail = next;
          return this.tail.shift();
        }
        return val;
      }
      peek() {
        const val = this.tail.peek();
        if (val === void 0 && this.tail.next)
          return this.tail.next.peek();
        return val;
      }
      isEmpty() {
        return this.length === 0;
      }
    };
  }
});

// ../../node_modules/b4a/index.js
var require_b4a = __commonJS({
  "../../node_modules/b4a/index.js"(exports, module) {
    "use strict";
    function isBuffer(value) {
      return Buffer.isBuffer(value) || value instanceof Uint8Array;
    }
    function isEncoding(encoding) {
      return Buffer.isEncoding(encoding);
    }
    function alloc(size, fill2, encoding) {
      return Buffer.alloc(size, fill2, encoding);
    }
    function allocUnsafe(size) {
      return Buffer.allocUnsafe(size);
    }
    function allocUnsafeSlow(size) {
      return Buffer.allocUnsafeSlow(size);
    }
    function byteLength(string, encoding) {
      return Buffer.byteLength(string, encoding);
    }
    function compare(a, b) {
      return Buffer.compare(a, b);
    }
    function concat(buffers, totalLength) {
      return Buffer.concat(buffers, totalLength);
    }
    function copy(source, target, targetStart, start, end) {
      return toBuffer(source).copy(target, targetStart, start, end);
    }
    function equals(a, b) {
      return toBuffer(a).equals(b);
    }
    function fill(buffer, value, offset, end, encoding) {
      return toBuffer(buffer).fill(value, offset, end, encoding);
    }
    function from(value, encodingOrOffset, length) {
      return Buffer.from(value, encodingOrOffset, length);
    }
    function includes(buffer, value, byteOffset, encoding) {
      return toBuffer(buffer).includes(value, byteOffset, encoding);
    }
    function indexOf(buffer, value, byfeOffset, encoding) {
      return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
    }
    function lastIndexOf(buffer, value, byteOffset, encoding) {
      return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
    }
    function swap16(buffer) {
      return toBuffer(buffer).swap16();
    }
    function swap32(buffer) {
      return toBuffer(buffer).swap32();
    }
    function swap64(buffer) {
      return toBuffer(buffer).swap64();
    }
    function toBuffer(buffer) {
      if (Buffer.isBuffer(buffer))
        return buffer;
      return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    function toString2(buffer, encoding, start, end) {
      return toBuffer(buffer).toString(encoding, start, end);
    }
    function write(buffer, string, offset, length, encoding) {
      return toBuffer(buffer).write(string, offset, length, encoding);
    }
    function writeDoubleLE(buffer, value, offset) {
      return toBuffer(buffer).writeDoubleLE(value, offset);
    }
    function writeFloatLE(buffer, value, offset) {
      return toBuffer(buffer).writeFloatLE(value, offset);
    }
    function writeUInt32LE(buffer, value, offset) {
      return toBuffer(buffer).writeUInt32LE(value, offset);
    }
    function writeInt32LE(buffer, value, offset) {
      return toBuffer(buffer).writeInt32LE(value, offset);
    }
    function readDoubleLE(buffer, offset) {
      return toBuffer(buffer).readDoubleLE(offset);
    }
    function readFloatLE(buffer, offset) {
      return toBuffer(buffer).readFloatLE(offset);
    }
    function readUInt32LE(buffer, offset) {
      return toBuffer(buffer).readUInt32LE(offset);
    }
    function readInt32LE(buffer, offset) {
      return toBuffer(buffer).readInt32LE(offset);
    }
    function writeDoubleBE(buffer, value, offset) {
      return toBuffer(buffer).writeDoubleBE(value, offset);
    }
    function writeFloatBE(buffer, value, offset) {
      return toBuffer(buffer).writeFloatBE(value, offset);
    }
    function writeUInt32BE(buffer, value, offset) {
      return toBuffer(buffer).writeUInt32BE(value, offset);
    }
    function writeInt32BE(buffer, value, offset) {
      return toBuffer(buffer).writeInt32BE(value, offset);
    }
    function readDoubleBE(buffer, offset) {
      return toBuffer(buffer).readDoubleBE(offset);
    }
    function readFloatBE(buffer, offset) {
      return toBuffer(buffer).readFloatBE(offset);
    }
    function readUInt32BE(buffer, offset) {
      return toBuffer(buffer).readUInt32BE(offset);
    }
    function readInt32BE(buffer, offset) {
      return toBuffer(buffer).readInt32BE(offset);
    }
    module.exports = {
      isBuffer,
      isEncoding,
      alloc,
      allocUnsafe,
      allocUnsafeSlow,
      byteLength,
      compare,
      concat,
      copy,
      equals,
      fill,
      from,
      includes,
      indexOf,
      lastIndexOf,
      swap16,
      swap32,
      swap64,
      toBuffer,
      toString: toString2,
      write,
      writeDoubleLE,
      writeFloatLE,
      writeUInt32LE,
      writeInt32LE,
      readDoubleLE,
      readFloatLE,
      readUInt32LE,
      readInt32LE,
      writeDoubleBE,
      writeFloatBE,
      writeUInt32BE,
      writeInt32BE,
      readDoubleBE,
      readFloatBE,
      readUInt32BE,
      readInt32BE
    };
  }
});

// ../../node_modules/text-decoder/lib/pass-through-decoder.js
var require_pass_through_decoder = __commonJS({
  "../../node_modules/text-decoder/lib/pass-through-decoder.js"(exports, module) {
    "use strict";
    var b4a = require_b4a();
    module.exports = class PassThroughDecoder {
      constructor(encoding) {
        this.encoding = encoding;
      }
      get remaining() {
        return 0;
      }
      decode(tail) {
        return b4a.toString(tail, this.encoding);
      }
      flush() {
        return "";
      }
    };
  }
});

// ../../node_modules/text-decoder/lib/utf8-decoder.js
var require_utf8_decoder = __commonJS({
  "../../node_modules/text-decoder/lib/utf8-decoder.js"(exports, module) {
    "use strict";
    var b4a = require_b4a();
    module.exports = class UTF8Decoder {
      constructor() {
        this.codePoint = 0;
        this.bytesSeen = 0;
        this.bytesNeeded = 0;
        this.lowerBoundary = 128;
        this.upperBoundary = 191;
      }
      get remaining() {
        return this.bytesSeen;
      }
      decode(data) {
        if (this.bytesNeeded === 0) {
          let isBoundary = true;
          for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {
            isBoundary = data[i] <= 127;
          }
          if (isBoundary)
            return b4a.toString(data, "utf8");
        }
        let result = "";
        for (let i = 0, n = data.byteLength; i < n; i++) {
          const byte = data[i];
          if (this.bytesNeeded === 0) {
            if (byte <= 127) {
              result += String.fromCharCode(byte);
            } else {
              this.bytesSeen = 1;
              if (byte >= 194 && byte <= 223) {
                this.bytesNeeded = 2;
                this.codePoint = byte & 31;
              } else if (byte >= 224 && byte <= 239) {
                if (byte === 224)
                  this.lowerBoundary = 160;
                else if (byte === 237)
                  this.upperBoundary = 159;
                this.bytesNeeded = 3;
                this.codePoint = byte & 15;
              } else if (byte >= 240 && byte <= 244) {
                if (byte === 240)
                  this.lowerBoundary = 144;
                if (byte === 244)
                  this.upperBoundary = 143;
                this.bytesNeeded = 4;
                this.codePoint = byte & 7;
              } else {
                result += "\uFFFD";
              }
            }
            continue;
          }
          if (byte < this.lowerBoundary || byte > this.upperBoundary) {
            this.codePoint = 0;
            this.bytesNeeded = 0;
            this.bytesSeen = 0;
            this.lowerBoundary = 128;
            this.upperBoundary = 191;
            result += "\uFFFD";
            continue;
          }
          this.lowerBoundary = 128;
          this.upperBoundary = 191;
          this.codePoint = this.codePoint << 6 | byte & 63;
          this.bytesSeen++;
          if (this.bytesSeen !== this.bytesNeeded)
            continue;
          result += String.fromCodePoint(this.codePoint);
          this.codePoint = 0;
          this.bytesNeeded = 0;
          this.bytesSeen = 0;
        }
        return result;
      }
      flush() {
        const result = this.bytesNeeded > 0 ? "\uFFFD" : "";
        this.codePoint = 0;
        this.bytesNeeded = 0;
        this.bytesSeen = 0;
        this.lowerBoundary = 128;
        this.upperBoundary = 191;
        return result;
      }
    };
  }
});

// ../../node_modules/text-decoder/index.js
var require_text_decoder = __commonJS({
  "../../node_modules/text-decoder/index.js"(exports, module) {
    "use strict";
    var PassThroughDecoder = require_pass_through_decoder();
    var UTF8Decoder = require_utf8_decoder();
    module.exports = class TextDecoder {
      constructor(encoding = "utf8") {
        this.encoding = normalizeEncoding(encoding);
        switch (this.encoding) {
          case "utf8":
            this.decoder = new UTF8Decoder();
            break;
          case "utf16le":
          case "base64":
            throw new Error("Unsupported encoding: " + this.encoding);
          default:
            this.decoder = new PassThroughDecoder(this.encoding);
        }
      }
      get remaining() {
        return this.decoder.remaining;
      }
      push(data) {
        if (typeof data === "string")
          return data;
        return this.decoder.decode(data);
      }
      // For Node.js compatibility
      write(data) {
        return this.push(data);
      }
      end(data) {
        let result = "";
        if (data)
          result = this.push(data);
        result += this.decoder.flush();
        return result;
      }
    };
    function normalizeEncoding(encoding) {
      encoding = encoding.toLowerCase();
      switch (encoding) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return encoding;
        default:
          throw new Error("Unknown encoding: " + encoding);
      }
    }
  }
});

// ../../node_modules/streamx/index.js
var require_streamx = __commonJS({
  "../../node_modules/streamx/index.js"(exports, module) {
    "use strict";
    var { EventEmitter } = __require("events");
    var STREAM_DESTROYED = new Error("Stream was destroyed");
    var PREMATURE_CLOSE = new Error("Premature close");
    var queueTick = require_process_next_tick();
    var FIFO = require_fast_fifo();
    var TextDecoder = require_text_decoder();
    var MAX = (1 << 29) - 1;
    var OPENING = 1;
    var PREDESTROYING = 2;
    var DESTROYING = 4;
    var DESTROYED = 8;
    var NOT_OPENING = MAX ^ OPENING;
    var NOT_PREDESTROYING = MAX ^ PREDESTROYING;
    var READ_ACTIVE = 1 << 4;
    var READ_UPDATING = 2 << 4;
    var READ_PRIMARY = 4 << 4;
    var READ_QUEUED = 8 << 4;
    var READ_RESUMED = 16 << 4;
    var READ_PIPE_DRAINED = 32 << 4;
    var READ_ENDING = 64 << 4;
    var READ_EMIT_DATA = 128 << 4;
    var READ_EMIT_READABLE = 256 << 4;
    var READ_EMITTED_READABLE = 512 << 4;
    var READ_DONE = 1024 << 4;
    var READ_NEXT_TICK = 2048 << 4;
    var READ_NEEDS_PUSH = 4096 << 4;
    var READ_READ_AHEAD = 8192 << 4;
    var READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
    var READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;
    var READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
    var READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
    var READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;
    var READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
    var READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
    var READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
    var READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
    var READ_PAUSED = MAX ^ READ_RESUMED;
    var READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
    var READ_NOT_ENDING = MAX ^ READ_ENDING;
    var READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;
    var READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
    var READ_NOT_UPDATING = MAX ^ READ_UPDATING;
    var READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;
    var READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;
    var WRITE_ACTIVE = 1 << 18;
    var WRITE_UPDATING = 2 << 18;
    var WRITE_PRIMARY = 4 << 18;
    var WRITE_QUEUED = 8 << 18;
    var WRITE_UNDRAINED = 16 << 18;
    var WRITE_DONE = 32 << 18;
    var WRITE_EMIT_DRAIN = 64 << 18;
    var WRITE_NEXT_TICK = 128 << 18;
    var WRITE_WRITING = 256 << 18;
    var WRITE_FINISHING = 512 << 18;
    var WRITE_CORKED = 1024 << 18;
    var WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);
    var WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
    var WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING);
    var WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
    var WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
    var WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
    var WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;
    var WRITE_NOT_CORKED = MAX ^ WRITE_CORKED;
    var ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
    var NOT_ACTIVE = MAX ^ ACTIVE;
    var DONE = READ_DONE | WRITE_DONE;
    var DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;
    var OPEN_STATUS = DESTROY_STATUS | OPENING;
    var AUTO_DESTROY = DESTROY_STATUS | DONE;
    var NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
    var ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;
    var TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;
    var IS_OPENING = OPEN_STATUS | TICKING;
    var READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
    var READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
    var READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
    var READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
    var SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;
    var READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
    var READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;
    var READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING;
    var WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
    var WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
    var WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
    var WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
    var WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED;
    var WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
    var WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;
    var WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
    var WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
    var WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;
    var WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS;
    var asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");
    var WritableState = class {
      constructor(stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {
        this.stream = stream;
        this.queue = new FIFO();
        this.highWaterMark = highWaterMark;
        this.buffered = 0;
        this.error = null;
        this.pipeline = null;
        this.drains = null;
        this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
        this.map = mapWritable || map;
        this.afterWrite = afterWrite.bind(this);
        this.afterUpdateNextTick = updateWriteNT.bind(this);
      }
      get ended() {
        return (this.stream._duplexState & WRITE_DONE) !== 0;
      }
      push(data) {
        if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0)
          return false;
        if (this.map !== null)
          data = this.map(data);
        this.buffered += this.byteLength(data);
        this.queue.push(data);
        if (this.buffered < this.highWaterMark) {
          this.stream._duplexState |= WRITE_QUEUED;
          return true;
        }
        this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
        return false;
      }
      shift() {
        const data = this.queue.shift();
        this.buffered -= this.byteLength(data);
        if (this.buffered === 0)
          this.stream._duplexState &= WRITE_NOT_QUEUED;
        return data;
      }
      end(data) {
        if (typeof data === "function")
          this.stream.once("finish", data);
        else if (data !== void 0 && data !== null)
          this.push(data);
        this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
      }
      autoBatch(data, cb) {
        const buffer = [];
        const stream = this.stream;
        buffer.push(data);
        while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
          buffer.push(stream._writableState.shift());
        }
        if ((stream._duplexState & OPEN_STATUS) !== 0)
          return cb(null);
        stream._writev(buffer, cb);
      }
      update() {
        const stream = this.stream;
        stream._duplexState |= WRITE_UPDATING;
        do {
          while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
            const data = this.shift();
            stream._duplexState |= WRITE_ACTIVE_AND_WRITING;
            stream._write(data, this.afterWrite);
          }
          if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0)
            this.updateNonPrimary();
        } while (this.continueUpdate() === true);
        stream._duplexState &= WRITE_NOT_UPDATING;
      }
      updateNonPrimary() {
        const stream = this.stream;
        if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
          stream._duplexState = stream._duplexState | WRITE_ACTIVE;
          stream._final(afterFinal.bind(this));
          return;
        }
        if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
          if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
            stream._duplexState |= ACTIVE;
            stream._destroy(afterDestroy.bind(this));
          }
          return;
        }
        if ((stream._duplexState & IS_OPENING) === OPENING) {
          stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
          stream._open(afterOpen.bind(this));
        }
      }
      continueUpdate() {
        if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0)
          return false;
        this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
        return true;
      }
      updateCallback() {
        if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY)
          this.update();
        else
          this.updateNextTick();
      }
      updateNextTick() {
        if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0)
          return;
        this.stream._duplexState |= WRITE_NEXT_TICK;
        if ((this.stream._duplexState & WRITE_UPDATING) === 0)
          queueTick(this.afterUpdateNextTick);
      }
    };
    var ReadableState = class {
      constructor(stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {
        this.stream = stream;
        this.queue = new FIFO();
        this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;
        this.buffered = 0;
        this.readAhead = highWaterMark > 0;
        this.error = null;
        this.pipeline = null;
        this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
        this.map = mapReadable || map;
        this.pipeTo = null;
        this.afterRead = afterRead.bind(this);
        this.afterUpdateNextTick = updateReadNT.bind(this);
      }
      get ended() {
        return (this.stream._duplexState & READ_DONE) !== 0;
      }
      pipe(pipeTo, cb) {
        if (this.pipeTo !== null)
          throw new Error("Can only pipe to one destination");
        if (typeof cb !== "function")
          cb = null;
        this.stream._duplexState |= READ_PIPE_DRAINED;
        this.pipeTo = pipeTo;
        this.pipeline = new Pipeline(this.stream, pipeTo, cb);
        if (cb)
          this.stream.on("error", noop2);
        if (isStreamx(pipeTo)) {
          pipeTo._writableState.pipeline = this.pipeline;
          if (cb)
            pipeTo.on("error", noop2);
          pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
        } else {
          const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
          const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
          pipeTo.on("error", onerror);
          pipeTo.on("close", onclose);
          pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
        }
        pipeTo.on("drain", afterDrain.bind(this));
        this.stream.emit("piping", pipeTo);
        pipeTo.emit("pipe", this.stream);
      }
      push(data) {
        const stream = this.stream;
        if (data === null) {
          this.highWaterMark = 0;
          stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
          return false;
        }
        if (this.map !== null) {
          data = this.map(data);
          if (data === null) {
            stream._duplexState &= READ_PUSHED;
            return this.buffered < this.highWaterMark;
          }
        }
        this.buffered += this.byteLength(data);
        this.queue.push(data);
        stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
        return this.buffered < this.highWaterMark;
      }
      shift() {
        const data = this.queue.shift();
        this.buffered -= this.byteLength(data);
        if (this.buffered === 0)
          this.stream._duplexState &= READ_NOT_QUEUED;
        return data;
      }
      unshift(data) {
        const pending = [this.map !== null ? this.map(data) : data];
        while (this.buffered > 0)
          pending.push(this.shift());
        for (let i = 0; i < pending.length - 1; i++) {
          const data2 = pending[i];
          this.buffered += this.byteLength(data2);
          this.queue.push(data2);
        }
        this.push(pending[pending.length - 1]);
      }
      read() {
        const stream = this.stream;
        if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
          const data = this.shift();
          if (this.pipeTo !== null && this.pipeTo.write(data) === false)
            stream._duplexState &= READ_PIPE_NOT_DRAINED;
          if ((stream._duplexState & READ_EMIT_DATA) !== 0)
            stream.emit("data", data);
          return data;
        }
        if (this.readAhead === false) {
          stream._duplexState |= READ_READ_AHEAD;
          this.updateNextTick();
        }
        return null;
      }
      drain() {
        const stream = this.stream;
        while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
          const data = this.shift();
          if (this.pipeTo !== null && this.pipeTo.write(data) === false)
            stream._duplexState &= READ_PIPE_NOT_DRAINED;
          if ((stream._duplexState & READ_EMIT_DATA) !== 0)
            stream.emit("data", data);
        }
      }
      update() {
        const stream = this.stream;
        stream._duplexState |= READ_UPDATING;
        do {
          this.drain();
          while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {
            stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;
            stream._read(this.afterRead);
            this.drain();
          }
          if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
            stream._duplexState |= READ_EMITTED_READABLE;
            stream.emit("readable");
          }
          if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0)
            this.updateNonPrimary();
        } while (this.continueUpdate() === true);
        stream._duplexState &= READ_NOT_UPDATING;
      }
      updateNonPrimary() {
        const stream = this.stream;
        if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
          stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
          stream.emit("end");
          if ((stream._duplexState & AUTO_DESTROY) === DONE)
            stream._duplexState |= DESTROYING;
          if (this.pipeTo !== null)
            this.pipeTo.end();
        }
        if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
          if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
            stream._duplexState |= ACTIVE;
            stream._destroy(afterDestroy.bind(this));
          }
          return;
        }
        if ((stream._duplexState & IS_OPENING) === OPENING) {
          stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
          stream._open(afterOpen.bind(this));
        }
      }
      continueUpdate() {
        if ((this.stream._duplexState & READ_NEXT_TICK) === 0)
          return false;
        this.stream._duplexState &= READ_NOT_NEXT_TICK;
        return true;
      }
      updateCallback() {
        if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY)
          this.update();
        else
          this.updateNextTick();
      }
      updateNextTickIfOpen() {
        if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0)
          return;
        this.stream._duplexState |= READ_NEXT_TICK;
        if ((this.stream._duplexState & READ_UPDATING) === 0)
          queueTick(this.afterUpdateNextTick);
      }
      updateNextTick() {
        if ((this.stream._duplexState & READ_NEXT_TICK) !== 0)
          return;
        this.stream._duplexState |= READ_NEXT_TICK;
        if ((this.stream._duplexState & READ_UPDATING) === 0)
          queueTick(this.afterUpdateNextTick);
      }
    };
    var TransformState = class {
      constructor(stream) {
        this.data = null;
        this.afterTransform = afterTransform.bind(stream);
        this.afterFinal = null;
      }
    };
    var Pipeline = class {
      constructor(src, dst, cb) {
        this.from = src;
        this.to = dst;
        this.afterPipe = cb;
        this.error = null;
        this.pipeToFinished = false;
      }
      finished() {
        this.pipeToFinished = true;
      }
      done(stream, err) {
        if (err)
          this.error = err;
        if (stream === this.to) {
          this.to = null;
          if (this.from !== null) {
            if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
              this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
            }
            return;
          }
        }
        if (stream === this.from) {
          this.from = null;
          if (this.to !== null) {
            if ((stream._duplexState & READ_DONE) === 0) {
              this.to.destroy(this.error || new Error("Readable stream closed before ending"));
            }
            return;
          }
        }
        if (this.afterPipe !== null)
          this.afterPipe(this.error);
        this.to = this.from = this.afterPipe = null;
      }
    };
    function afterDrain() {
      this.stream._duplexState |= READ_PIPE_DRAINED;
      this.updateCallback();
    }
    function afterFinal(err) {
      const stream = this.stream;
      if (err)
        stream.destroy(err);
      if ((stream._duplexState & DESTROY_STATUS) === 0) {
        stream._duplexState |= WRITE_DONE;
        stream.emit("finish");
      }
      if ((stream._duplexState & AUTO_DESTROY) === DONE) {
        stream._duplexState |= DESTROYING;
      }
      stream._duplexState &= WRITE_NOT_FINISHING;
      if ((stream._duplexState & WRITE_UPDATING) === 0)
        this.update();
      else
        this.updateNextTick();
    }
    function afterDestroy(err) {
      const stream = this.stream;
      if (!err && this.error !== STREAM_DESTROYED)
        err = this.error;
      if (err)
        stream.emit("error", err);
      stream._duplexState |= DESTROYED;
      stream.emit("close");
      const rs = stream._readableState;
      const ws = stream._writableState;
      if (rs !== null && rs.pipeline !== null)
        rs.pipeline.done(stream, err);
      if (ws !== null) {
        while (ws.drains !== null && ws.drains.length > 0)
          ws.drains.shift().resolve(false);
        if (ws.pipeline !== null)
          ws.pipeline.done(stream, err);
      }
    }
    function afterWrite(err) {
      const stream = this.stream;
      if (err)
        stream.destroy(err);
      stream._duplexState &= WRITE_NOT_ACTIVE;
      if (this.drains !== null)
        tickDrains(this.drains);
      if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
        stream._duplexState &= WRITE_DRAINED;
        if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
          stream.emit("drain");
        }
      }
      this.updateCallback();
    }
    function afterRead(err) {
      if (err)
        this.stream.destroy(err);
      this.stream._duplexState &= READ_NOT_ACTIVE;
      if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0)
        this.stream._duplexState &= READ_NO_READ_AHEAD;
      this.updateCallback();
    }
    function updateReadNT() {
      if ((this.stream._duplexState & READ_UPDATING) === 0) {
        this.stream._duplexState &= READ_NOT_NEXT_TICK;
        this.update();
      }
    }
    function updateWriteNT() {
      if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
        this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
        this.update();
      }
    }
    function tickDrains(drains) {
      for (let i = 0; i < drains.length; i++) {
        if (--drains[i].writes === 0) {
          drains.shift().resolve(true);
          i--;
        }
      }
    }
    function afterOpen(err) {
      const stream = this.stream;
      if (err)
        stream.destroy(err);
      if ((stream._duplexState & DESTROYING) === 0) {
        if ((stream._duplexState & READ_PRIMARY_STATUS) === 0)
          stream._duplexState |= READ_PRIMARY;
        if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0)
          stream._duplexState |= WRITE_PRIMARY;
        stream.emit("open");
      }
      stream._duplexState &= NOT_ACTIVE;
      if (stream._writableState !== null) {
        stream._writableState.updateCallback();
      }
      if (stream._readableState !== null) {
        stream._readableState.updateCallback();
      }
    }
    function afterTransform(err, data) {
      if (data !== void 0 && data !== null)
        this.push(data);
      this._writableState.afterWrite(err);
    }
    function newListener(name) {
      if (this._readableState !== null) {
        if (name === "data") {
          this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;
          this._readableState.updateNextTick();
        }
        if (name === "readable") {
          this._duplexState |= READ_EMIT_READABLE;
          this._readableState.updateNextTick();
        }
      }
      if (this._writableState !== null) {
        if (name === "drain") {
          this._duplexState |= WRITE_EMIT_DRAIN;
          this._writableState.updateNextTick();
        }
      }
    }
    var Stream = class extends EventEmitter {
      constructor(opts) {
        super();
        this._duplexState = 0;
        this._readableState = null;
        this._writableState = null;
        if (opts) {
          if (opts.open)
            this._open = opts.open;
          if (opts.destroy)
            this._destroy = opts.destroy;
          if (opts.predestroy)
            this._predestroy = opts.predestroy;
          if (opts.signal) {
            opts.signal.addEventListener("abort", abort.bind(this));
          }
        }
        this.on("newListener", newListener);
      }
      _open(cb) {
        cb(null);
      }
      _destroy(cb) {
        cb(null);
      }
      _predestroy() {
      }
      get readable() {
        return this._readableState !== null ? true : void 0;
      }
      get writable() {
        return this._writableState !== null ? true : void 0;
      }
      get destroyed() {
        return (this._duplexState & DESTROYED) !== 0;
      }
      get destroying() {
        return (this._duplexState & DESTROY_STATUS) !== 0;
      }
      destroy(err) {
        if ((this._duplexState & DESTROY_STATUS) === 0) {
          if (!err)
            err = STREAM_DESTROYED;
          this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
          if (this._readableState !== null) {
            this._readableState.highWaterMark = 0;
            this._readableState.error = err;
          }
          if (this._writableState !== null) {
            this._writableState.highWaterMark = 0;
            this._writableState.error = err;
          }
          this._duplexState |= PREDESTROYING;
          this._predestroy();
          this._duplexState &= NOT_PREDESTROYING;
          if (this._readableState !== null)
            this._readableState.updateNextTick();
          if (this._writableState !== null)
            this._writableState.updateNextTick();
        }
      }
    };
    var Readable = class _Readable extends Stream {
      constructor(opts) {
        super(opts);
        this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;
        this._readableState = new ReadableState(this, opts);
        if (opts) {
          if (this._readableState.readAhead === false)
            this._duplexState &= READ_NO_READ_AHEAD;
          if (opts.read)
            this._read = opts.read;
          if (opts.eagerOpen)
            this._readableState.updateNextTick();
          if (opts.encoding)
            this.setEncoding(opts.encoding);
        }
      }
      setEncoding(encoding) {
        const dec = new TextDecoder(encoding);
        const map = this._readableState.map || echo;
        this._readableState.map = mapOrSkip;
        return this;
        function mapOrSkip(data) {
          const next = dec.push(data);
          return next === "" && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next);
        }
      }
      _read(cb) {
        cb(null);
      }
      pipe(dest, cb) {
        this._readableState.updateNextTick();
        this._readableState.pipe(dest, cb);
        return dest;
      }
      read() {
        this._readableState.updateNextTick();
        return this._readableState.read();
      }
      push(data) {
        this._readableState.updateNextTickIfOpen();
        return this._readableState.push(data);
      }
      unshift(data) {
        this._readableState.updateNextTickIfOpen();
        return this._readableState.unshift(data);
      }
      resume() {
        this._duplexState |= READ_RESUMED_READ_AHEAD;
        this._readableState.updateNextTick();
        return this;
      }
      pause() {
        this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;
        return this;
      }
      static _fromAsyncIterator(ite, opts) {
        let destroy;
        const rs = new _Readable({
          ...opts,
          read(cb) {
            ite.next().then(push).then(cb.bind(null, null)).catch(cb);
          },
          predestroy() {
            destroy = ite.return();
          },
          destroy(cb) {
            if (!destroy)
              return cb(null);
            destroy.then(cb.bind(null, null)).catch(cb);
          }
        });
        return rs;
        function push(data) {
          if (data.done)
            rs.push(null);
          else
            rs.push(data.value);
        }
      }
      static from(data, opts) {
        if (isReadStreamx(data))
          return data;
        if (data[asyncIterator])
          return this._fromAsyncIterator(data[asyncIterator](), opts);
        if (!Array.isArray(data))
          data = data === void 0 ? [] : [data];
        let i = 0;
        return new _Readable({
          ...opts,
          read(cb) {
            this.push(i === data.length ? null : data[i++]);
            cb(null);
          }
        });
      }
      static isBackpressured(rs) {
        return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
      }
      static isPaused(rs) {
        return (rs._duplexState & READ_RESUMED) === 0;
      }
      [asyncIterator]() {
        const stream = this;
        let error = null;
        let promiseResolve = null;
        let promiseReject = null;
        this.on("error", (err) => {
          error = err;
        });
        this.on("readable", onreadable);
        this.on("close", onclose);
        return {
          [asyncIterator]() {
            return this;
          },
          next() {
            return new Promise(function(resolve4, reject) {
              promiseResolve = resolve4;
              promiseReject = reject;
              const data = stream.read();
              if (data !== null)
                ondata(data);
              else if ((stream._duplexState & DESTROYED) !== 0)
                ondata(null);
            });
          },
          return() {
            return destroy(null);
          },
          throw(err) {
            return destroy(err);
          }
        };
        function onreadable() {
          if (promiseResolve !== null)
            ondata(stream.read());
        }
        function onclose() {
          if (promiseResolve !== null)
            ondata(null);
        }
        function ondata(data) {
          if (promiseReject === null)
            return;
          if (error)
            promiseReject(error);
          else if (data === null && (stream._duplexState & READ_DONE) === 0)
            promiseReject(STREAM_DESTROYED);
          else
            promiseResolve({ value: data, done: data === null });
          promiseReject = promiseResolve = null;
        }
        function destroy(err) {
          stream.destroy(err);
          return new Promise((resolve4, reject) => {
            if (stream._duplexState & DESTROYED)
              return resolve4({ value: void 0, done: true });
            stream.once("close", function() {
              if (err)
                reject(err);
              else
                resolve4({ value: void 0, done: true });
            });
          });
        }
      }
    };
    var Writable = class extends Stream {
      constructor(opts) {
        super(opts);
        this._duplexState |= OPENING | READ_DONE;
        this._writableState = new WritableState(this, opts);
        if (opts) {
          if (opts.writev)
            this._writev = opts.writev;
          if (opts.write)
            this._write = opts.write;
          if (opts.final)
            this._final = opts.final;
          if (opts.eagerOpen)
            this._writableState.updateNextTick();
        }
      }
      cork() {
        this._duplexState |= WRITE_CORKED;
      }
      uncork() {
        this._duplexState &= WRITE_NOT_CORKED;
        this._writableState.updateNextTick();
      }
      _writev(batch, cb) {
        cb(null);
      }
      _write(data, cb) {
        this._writableState.autoBatch(data, cb);
      }
      _final(cb) {
        cb(null);
      }
      static isBackpressured(ws) {
        return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
      }
      static drained(ws) {
        if (ws.destroyed)
          return Promise.resolve(false);
        const state = ws._writableState;
        const pending = isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;
        const writes = pending + (ws._duplexState & WRITE_WRITING ? 1 : 0);
        if (writes === 0)
          return Promise.resolve(true);
        if (state.drains === null)
          state.drains = [];
        return new Promise((resolve4) => {
          state.drains.push({ writes, resolve: resolve4 });
        });
      }
      write(data) {
        this._writableState.updateNextTick();
        return this._writableState.push(data);
      }
      end(data) {
        this._writableState.updateNextTick();
        this._writableState.end(data);
        return this;
      }
    };
    var Duplex = class extends Readable {
      // and Writable
      constructor(opts) {
        super(opts);
        this._duplexState = OPENING | this._duplexState & READ_READ_AHEAD;
        this._writableState = new WritableState(this, opts);
        if (opts) {
          if (opts.writev)
            this._writev = opts.writev;
          if (opts.write)
            this._write = opts.write;
          if (opts.final)
            this._final = opts.final;
        }
      }
      cork() {
        this._duplexState |= WRITE_CORKED;
      }
      uncork() {
        this._duplexState &= WRITE_NOT_CORKED;
        this._writableState.updateNextTick();
      }
      _writev(batch, cb) {
        cb(null);
      }
      _write(data, cb) {
        this._writableState.autoBatch(data, cb);
      }
      _final(cb) {
        cb(null);
      }
      write(data) {
        this._writableState.updateNextTick();
        return this._writableState.push(data);
      }
      end(data) {
        this._writableState.updateNextTick();
        this._writableState.end(data);
        return this;
      }
    };
    var Transform = class extends Duplex {
      constructor(opts) {
        super(opts);
        this._transformState = new TransformState(this);
        if (opts) {
          if (opts.transform)
            this._transform = opts.transform;
          if (opts.flush)
            this._flush = opts.flush;
        }
      }
      _write(data, cb) {
        if (this._readableState.buffered >= this._readableState.highWaterMark) {
          this._transformState.data = data;
        } else {
          this._transform(data, this._transformState.afterTransform);
        }
      }
      _read(cb) {
        if (this._transformState.data !== null) {
          const data = this._transformState.data;
          this._transformState.data = null;
          cb(null);
          this._transform(data, this._transformState.afterTransform);
        } else {
          cb(null);
        }
      }
      destroy(err) {
        super.destroy(err);
        if (this._transformState.data !== null) {
          this._transformState.data = null;
          this._transformState.afterTransform();
        }
      }
      _transform(data, cb) {
        cb(null, data);
      }
      _flush(cb) {
        cb(null);
      }
      _final(cb) {
        this._transformState.afterFinal = cb;
        this._flush(transformAfterFlush.bind(this));
      }
    };
    var PassThrough = class extends Transform {
    };
    function transformAfterFlush(err, data) {
      const cb = this._transformState.afterFinal;
      if (err)
        return cb(err);
      if (data !== null && data !== void 0)
        this.push(data);
      this.push(null);
      cb(null);
    }
    function pipelinePromise(...streams) {
      return new Promise((resolve4, reject) => {
        return pipeline(...streams, (err) => {
          if (err)
            return reject(err);
          resolve4();
        });
      });
    }
    function pipeline(stream, ...streams) {
      const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
      const done = all.length && typeof all[all.length - 1] === "function" ? all.pop() : null;
      if (all.length < 2)
        throw new Error("Pipeline requires at least 2 streams");
      let src = all[0];
      let dest = null;
      let error = null;
      for (let i = 1; i < all.length; i++) {
        dest = all[i];
        if (isStreamx(src)) {
          src.pipe(dest, onerror);
        } else {
          errorHandle(src, true, i > 1, onerror);
          src.pipe(dest);
        }
        src = dest;
      }
      if (done) {
        let fin = false;
        const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);
        dest.on("error", (err) => {
          if (error === null)
            error = err;
        });
        dest.on("finish", () => {
          fin = true;
          if (!autoDestroy)
            done(error);
        });
        if (autoDestroy) {
          dest.on("close", () => done(error || (fin ? null : PREMATURE_CLOSE)));
        }
      }
      return dest;
      function errorHandle(s, rd, wr, onerror2) {
        s.on("error", onerror2);
        s.on("close", onclose);
        function onclose() {
          if (rd && s._readableState && !s._readableState.ended)
            return onerror2(PREMATURE_CLOSE);
          if (wr && s._writableState && !s._writableState.ended)
            return onerror2(PREMATURE_CLOSE);
        }
      }
      function onerror(err) {
        if (!err || error)
          return;
        error = err;
        for (const s of all) {
          s.destroy(err);
        }
      }
    }
    function echo(s) {
      return s;
    }
    function isStream(stream) {
      return !!stream._readableState || !!stream._writableState;
    }
    function isStreamx(stream) {
      return typeof stream._duplexState === "number" && isStream(stream);
    }
    function isEnded(stream) {
      return !!stream._readableState && stream._readableState.ended;
    }
    function isFinished(stream) {
      return !!stream._writableState && stream._writableState.ended;
    }
    function getStreamError(stream, opts = {}) {
      const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;
      return !opts.all && err === STREAM_DESTROYED ? null : err;
    }
    function isReadStreamx(stream) {
      return isStreamx(stream) && stream.readable;
    }
    function isDisturbed(stream) {
      return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0;
    }
    function isTypedArray(data) {
      return typeof data === "object" && data !== null && typeof data.byteLength === "number";
    }
    function defaultByteLength(data) {
      return isTypedArray(data) ? data.byteLength : 1024;
    }
    function noop2() {
    }
    function abort() {
      this.destroy(new Error("Stream aborted."));
    }
    function isWritev(s) {
      return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev;
    }
    module.exports = {
      pipeline,
      pipelinePromise,
      isStream,
      isStreamx,
      isEnded,
      isFinished,
      isDisturbed,
      getStreamError,
      Stream,
      Writable,
      Readable,
      Duplex,
      Transform,
      // Export PassThrough for compatibility with Node.js core's stream module
      PassThrough
    };
  }
});

// ../../node_modules/tar-stream/headers.js
var require_headers = __commonJS({
  "../../node_modules/tar-stream/headers.js"(exports) {
    "use strict";
    var b4a = require_b4a();
    var ZEROS = "0000000000000000000";
    var SEVENS = "7777777777777777777";
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR_MAGIC = b4a.from([117, 115, 116, 97, 114, 0]);
    var USTAR_VER = b4a.from([ZERO_OFFSET, ZERO_OFFSET]);
    var GNU_MAGIC = b4a.from([117, 115, 116, 97, 114, 32]);
    var GNU_VER = b4a.from([32, 0]);
    var MASK = 4095;
    var MAGIC_OFFSET = 257;
    var VERSION_OFFSET = 263;
    exports.decodeLongPath = function decodeLongPath(buf, encoding) {
      return decodeStr(buf, 0, buf.length, encoding);
    };
    exports.encodePax = function encodePax(opts) {
      let result = "";
      if (opts.name)
        result += addLength(" path=" + opts.name + "\n");
      if (opts.linkname)
        result += addLength(" linkpath=" + opts.linkname + "\n");
      const pax = opts.pax;
      if (pax) {
        for (const key in pax) {
          result += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
      return b4a.from(result);
    };
    exports.decodePax = function decodePax(buf) {
      const result = {};
      while (buf.length) {
        let i = 0;
        while (i < buf.length && buf[i] !== 32)
          i++;
        const len = parseInt(b4a.toString(buf.subarray(0, i)), 10);
        if (!len)
          return result;
        const b = b4a.toString(buf.subarray(i + 1, len - 1));
        const keyIndex = b.indexOf("=");
        if (keyIndex === -1)
          return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.subarray(len);
      }
      return result;
    };
    exports.encode = function encode(opts) {
      const buf = b4a.alloc(512);
      let name = opts.name;
      let prefix = "";
      if (opts.typeflag === 5 && name[name.length - 1] !== "/")
        name += "/";
      if (b4a.byteLength(name) !== name.length)
        return null;
      while (b4a.byteLength(name) > 100) {
        const i = name.indexOf("/");
        if (i === -1)
          return null;
        prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
      }
      if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155)
        return null;
      if (opts.linkname && b4a.byteLength(opts.linkname) > 100)
        return null;
      b4a.write(buf, name);
      b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100);
      b4a.write(buf, encodeOct(opts.uid, 6), 108);
      b4a.write(buf, encodeOct(opts.gid, 6), 116);
      encodeSize(opts.size, buf, 124);
      b4a.write(buf, encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
      buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
      if (opts.linkname)
        b4a.write(buf, opts.linkname, 157);
      b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET);
      b4a.copy(USTAR_VER, buf, VERSION_OFFSET);
      if (opts.uname)
        b4a.write(buf, opts.uname, 265);
      if (opts.gname)
        b4a.write(buf, opts.gname, 297);
      b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329);
      b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337);
      if (prefix)
        b4a.write(buf, prefix, 345);
      b4a.write(buf, encodeOct(cksum(buf), 6), 148);
      return buf;
    };
    exports.decode = function decode(buf, filenameEncoding, allowUnknownFormat) {
      let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
      let name = decodeStr(buf, 0, 100, filenameEncoding);
      const mode = decodeOct(buf, 100, 8);
      const uid = decodeOct(buf, 108, 8);
      const gid = decodeOct(buf, 116, 8);
      const size = decodeOct(buf, 124, 12);
      const mtime = decodeOct(buf, 136, 12);
      const type = toType(typeflag);
      const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
      const uname = decodeStr(buf, 265, 32);
      const gname = decodeStr(buf, 297, 32);
      const devmajor = decodeOct(buf, 329, 8);
      const devminor = decodeOct(buf, 337, 8);
      const c = cksum(buf);
      if (c === 8 * 32)
        return null;
      if (c !== decodeOct(buf, 148, 8))
        throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
      if (isUSTAR(buf)) {
        if (buf[345])
          name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
      } else if (isGNU(buf)) {
      } else {
        if (!allowUnknownFormat) {
          throw new Error("Invalid tar header: unknown format.");
        }
      }
      if (typeflag === 0 && name && name[name.length - 1] === "/")
        typeflag = 5;
      return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1e3 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor,
        pax: null
      };
    };
    function isUSTAR(buf) {
      return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6));
    }
    function isGNU(buf) {
      return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) && b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2));
    }
    function clamp(index, len, defaultValue) {
      if (typeof index !== "number")
        return defaultValue;
      index = ~~index;
      if (index >= len)
        return len;
      if (index >= 0)
        return index;
      index += len;
      if (index >= 0)
        return index;
      return 0;
    }
    function toType(flag) {
      switch (flag) {
        case 0:
          return "file";
        case 1:
          return "link";
        case 2:
          return "symlink";
        case 3:
          return "character-device";
        case 4:
          return "block-device";
        case 5:
          return "directory";
        case 6:
          return "fifo";
        case 7:
          return "contiguous-file";
        case 72:
          return "pax-header";
        case 55:
          return "pax-global-header";
        case 27:
          return "gnu-long-link-path";
        case 28:
        case 30:
          return "gnu-long-path";
      }
      return null;
    }
    function toTypeflag(flag) {
      switch (flag) {
        case "file":
          return 0;
        case "link":
          return 1;
        case "symlink":
          return 2;
        case "character-device":
          return 3;
        case "block-device":
          return 4;
        case "directory":
          return 5;
        case "fifo":
          return 6;
        case "contiguous-file":
          return 7;
        case "pax-header":
          return 72;
      }
      return 0;
    }
    function indexOf(block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block[offset] === num)
          return offset;
      }
      return end;
    }
    function cksum(block) {
      let sum = 8 * 32;
      for (let i = 0; i < 148; i++)
        sum += block[i];
      for (let j = 156; j < 512; j++)
        sum += block[j];
      return sum;
    }
    function encodeOct(val, n) {
      val = val.toString(8);
      if (val.length > n)
        return SEVENS.slice(0, n) + " ";
      return ZEROS.slice(0, n - val.length) + val + " ";
    }
    function encodeSizeBin(num, buf, off) {
      buf[off] = 128;
      for (let i = 11; i > 0; i--) {
        buf[off + i] = num & 255;
        num = Math.floor(num / 256);
      }
    }
    function encodeSize(num, buf, off) {
      if (num.toString(8).length > 11) {
        encodeSizeBin(num, buf, off);
      } else {
        b4a.write(buf, encodeOct(num, 11), off);
      }
    }
    function parse256(buf) {
      let positive;
      if (buf[0] === 128)
        positive = true;
      else if (buf[0] === 255)
        positive = false;
      else
        return null;
      const tuple = [];
      let i;
      for (i = buf.length - 1; i > 0; i--) {
        const byte = buf[i];
        if (positive)
          tuple.push(byte);
        else
          tuple.push(255 - byte);
      }
      let sum = 0;
      const l = tuple.length;
      for (i = 0; i < l; i++) {
        sum += tuple[i] * Math.pow(256, i);
      }
      return positive ? sum : -1 * sum;
    }
    function decodeOct(val, offset, length) {
      val = val.subarray(offset, offset + length);
      offset = 0;
      if (val[offset] & 128) {
        return parse256(val);
      } else {
        while (offset < val.length && val[offset] === 32)
          offset++;
        const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while (offset < end && val[offset] === 0)
          offset++;
        if (end === offset)
          return 0;
        return parseInt(b4a.toString(val.subarray(offset, end)), 8);
      }
    }
    function decodeStr(val, offset, length, encoding) {
      return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding);
    }
    function addLength(str) {
      const len = b4a.byteLength(str);
      let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
      if (len + digits >= Math.pow(10, digits))
        digits++;
      return len + digits + str;
    }
  }
});

// ../../node_modules/tar-stream/extract.js
var require_extract = __commonJS({
  "../../node_modules/tar-stream/extract.js"(exports, module) {
    "use strict";
    var { Writable, Readable, getStreamError } = require_streamx();
    var FIFO = require_fast_fifo();
    var b4a = require_b4a();
    var headers = require_headers();
    var EMPTY = b4a.alloc(0);
    var BufferList = class {
      constructor() {
        this.buffered = 0;
        this.shifted = 0;
        this.queue = new FIFO();
        this._offset = 0;
      }
      push(buffer) {
        this.buffered += buffer.byteLength;
        this.queue.push(buffer);
      }
      shiftFirst(size) {
        return this._buffered === 0 ? null : this._next(size);
      }
      shift(size) {
        if (size > this.buffered)
          return null;
        if (size === 0)
          return EMPTY;
        let chunk = this._next(size);
        if (size === chunk.byteLength)
          return chunk;
        const chunks = [chunk];
        while ((size -= chunk.byteLength) > 0) {
          chunk = this._next(size);
          chunks.push(chunk);
        }
        return b4a.concat(chunks);
      }
      _next(size) {
        const buf = this.queue.peek();
        const rem = buf.byteLength - this._offset;
        if (size >= rem) {
          const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf;
          this.queue.shift();
          this._offset = 0;
          this.buffered -= rem;
          this.shifted += rem;
          return sub;
        }
        this.buffered -= size;
        this.shifted += size;
        return buf.subarray(this._offset, this._offset += size);
      }
    };
    var Source = class extends Readable {
      constructor(self2, header, offset) {
        super();
        this.header = header;
        this.offset = offset;
        this._parent = self2;
      }
      _read(cb) {
        if (this.header.size === 0) {
          this.push(null);
        }
        if (this._parent._stream === this) {
          this._parent._update();
        }
        cb(null);
      }
      _predestroy() {
        this._parent.destroy(getStreamError(this));
      }
      _detach() {
        if (this._parent._stream === this) {
          this._parent._stream = null;
          this._parent._missing = overflow(this.header.size);
          this._parent._update();
        }
      }
      _destroy(cb) {
        this._detach();
        cb(null);
      }
    };
    var Extract = class extends Writable {
      constructor(opts) {
        super(opts);
        if (!opts)
          opts = {};
        this._buffer = new BufferList();
        this._offset = 0;
        this._header = null;
        this._stream = null;
        this._missing = 0;
        this._longHeader = false;
        this._callback = noop2;
        this._locked = false;
        this._finished = false;
        this._pax = null;
        this._paxGlobal = null;
        this._gnuLongPath = null;
        this._gnuLongLinkPath = null;
        this._filenameEncoding = opts.filenameEncoding || "utf-8";
        this._allowUnknownFormat = !!opts.allowUnknownFormat;
        this._unlockBound = this._unlock.bind(this);
      }
      _unlock(err) {
        this._locked = false;
        if (err) {
          this.destroy(err);
          this._continueWrite(err);
          return;
        }
        this._update();
      }
      _consumeHeader() {
        if (this._locked)
          return false;
        this._offset = this._buffer.shifted;
        try {
          this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat);
        } catch (err) {
          this._continueWrite(err);
          return false;
        }
        if (!this._header)
          return true;
        switch (this._header.type) {
          case "gnu-long-path":
          case "gnu-long-link-path":
          case "pax-global-header":
          case "pax-header":
            this._longHeader = true;
            this._missing = this._header.size;
            return true;
        }
        this._locked = true;
        this._applyLongHeaders();
        if (this._header.size === 0 || this._header.type === "directory") {
          this.emit("entry", this._header, this._createStream(), this._unlockBound);
          return true;
        }
        this._stream = this._createStream();
        this._missing = this._header.size;
        this.emit("entry", this._header, this._stream, this._unlockBound);
        return true;
      }
      _applyLongHeaders() {
        if (this._gnuLongPath) {
          this._header.name = this._gnuLongPath;
          this._gnuLongPath = null;
        }
        if (this._gnuLongLinkPath) {
          this._header.linkname = this._gnuLongLinkPath;
          this._gnuLongLinkPath = null;
        }
        if (this._pax) {
          if (this._pax.path)
            this._header.name = this._pax.path;
          if (this._pax.linkpath)
            this._header.linkname = this._pax.linkpath;
          if (this._pax.size)
            this._header.size = parseInt(this._pax.size, 10);
          this._header.pax = this._pax;
          this._pax = null;
        }
      }
      _decodeLongHeader(buf) {
        switch (this._header.type) {
          case "gnu-long-path":
            this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding);
            break;
          case "gnu-long-link-path":
            this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding);
            break;
          case "pax-global-header":
            this._paxGlobal = headers.decodePax(buf);
            break;
          case "pax-header":
            this._pax = this._paxGlobal === null ? headers.decodePax(buf) : Object.assign({}, this._paxGlobal, headers.decodePax(buf));
            break;
        }
      }
      _consumeLongHeader() {
        this._longHeader = false;
        this._missing = overflow(this._header.size);
        const buf = this._buffer.shift(this._header.size);
        try {
          this._decodeLongHeader(buf);
        } catch (err) {
          this._continueWrite(err);
          return false;
        }
        return true;
      }
      _consumeStream() {
        const buf = this._buffer.shiftFirst(this._missing);
        if (buf === null)
          return false;
        this._missing -= buf.byteLength;
        const drained = this._stream.push(buf);
        if (this._missing === 0) {
          this._stream.push(null);
          if (drained)
            this._stream._detach();
          return drained && this._locked === false;
        }
        return drained;
      }
      _createStream() {
        return new Source(this, this._header, this._offset);
      }
      _update() {
        while (this._buffer.buffered > 0 && !this.destroying) {
          if (this._missing > 0) {
            if (this._stream !== null) {
              if (this._consumeStream() === false)
                return;
              continue;
            }
            if (this._longHeader === true) {
              if (this._missing > this._buffer.buffered)
                break;
              if (this._consumeLongHeader() === false)
                return false;
              continue;
            }
            const ignore = this._buffer.shiftFirst(this._missing);
            if (ignore !== null)
              this._missing -= ignore.byteLength;
            continue;
          }
          if (this._buffer.buffered < 512)
            break;
          if (this._stream !== null || this._consumeHeader() === false)
            return;
        }
        this._continueWrite(null);
      }
      _continueWrite(err) {
        const cb = this._callback;
        this._callback = noop2;
        cb(err);
      }
      _write(data, cb) {
        this._callback = cb;
        this._buffer.push(data);
        this._update();
      }
      _final(cb) {
        this._finished = this._missing === 0 && this._buffer.buffered === 0;
        cb(this._finished ? null : new Error("Unexpected end of data"));
      }
      _predestroy() {
        this._continueWrite(null);
      }
      _destroy(cb) {
        if (this._stream)
          this._stream.destroy(getStreamError(this));
        cb(null);
      }
      [Symbol.asyncIterator]() {
        let error = null;
        let promiseResolve = null;
        let promiseReject = null;
        let entryStream = null;
        let entryCallback = null;
        const extract = this;
        this.on("entry", onentry);
        this.on("error", (err) => {
          error = err;
        });
        this.on("close", onclose);
        return {
          [Symbol.asyncIterator]() {
            return this;
          },
          next() {
            return new Promise(onnext);
          },
          return() {
            return destroy(null);
          },
          throw(err) {
            return destroy(err);
          }
        };
        function consumeCallback(err) {
          if (!entryCallback)
            return;
          const cb = entryCallback;
          entryCallback = null;
          cb(err);
        }
        function onnext(resolve4, reject) {
          if (error) {
            return reject(error);
          }
          if (entryStream) {
            resolve4({ value: entryStream, done: false });
            entryStream = null;
            return;
          }
          promiseResolve = resolve4;
          promiseReject = reject;
          consumeCallback(null);
          if (extract._finished && promiseResolve) {
            promiseResolve({ value: void 0, done: true });
            promiseResolve = promiseReject = null;
          }
        }
        function onentry(header, stream, callback) {
          entryCallback = callback;
          stream.on("error", noop2);
          if (promiseResolve) {
            promiseResolve({ value: stream, done: false });
            promiseResolve = promiseReject = null;
          } else {
            entryStream = stream;
          }
        }
        function onclose() {
          consumeCallback(error);
          if (!promiseResolve)
            return;
          if (error)
            promiseReject(error);
          else
            promiseResolve({ value: void 0, done: true });
          promiseResolve = promiseReject = null;
        }
        function destroy(err) {
          extract.destroy(err);
          consumeCallback(err);
          return new Promise((resolve4, reject) => {
            if (extract.destroyed)
              return resolve4({ value: void 0, done: true });
            extract.once("close", function() {
              if (err)
                reject(err);
              else
                resolve4({ value: void 0, done: true });
            });
          });
        }
      }
    };
    module.exports = function extract(opts) {
      return new Extract(opts);
    };
    function noop2() {
    }
    function overflow(size) {
      size &= 511;
      return size && 512 - size;
    }
  }
});

// ../../node_modules/tar-stream/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/tar-stream/constants.js"(exports, module) {
    "use strict";
    var constants = {
      // just for envs without fs
      S_IFMT: 61440,
      S_IFDIR: 16384,
      S_IFCHR: 8192,
      S_IFBLK: 24576,
      S_IFIFO: 4096,
      S_IFLNK: 40960
    };
    try {
      module.exports = __require("fs").constants || constants;
    } catch {
      module.exports = constants;
    }
  }
});

// ../../node_modules/tar-stream/pack.js
var require_pack = __commonJS({
  "../../node_modules/tar-stream/pack.js"(exports, module) {
    "use strict";
    var { Readable, Writable, getStreamError } = require_streamx();
    var b4a = require_b4a();
    var constants = require_constants2();
    var headers = require_headers();
    var DMODE = 493;
    var FMODE = 420;
    var END_OF_TAR = b4a.alloc(1024);
    var Sink = class extends Writable {
      constructor(pack, header, callback) {
        super({ mapWritable, eagerOpen: true });
        this.written = 0;
        this.header = header;
        this._callback = callback;
        this._linkname = null;
        this._isLinkname = header.type === "symlink" && !header.linkname;
        this._isVoid = header.type !== "file" && header.type !== "contiguous-file";
        this._finished = false;
        this._pack = pack;
        this._openCallback = null;
        if (this._pack._stream === null)
          this._pack._stream = this;
        else
          this._pack._pending.push(this);
      }
      _open(cb) {
        this._openCallback = cb;
        if (this._pack._stream === this)
          this._continueOpen();
      }
      _continuePack(err) {
        if (this._callback === null)
          return;
        const callback = this._callback;
        this._callback = null;
        callback(err);
      }
      _continueOpen() {
        if (this._pack._stream === null)
          this._pack._stream = this;
        const cb = this._openCallback;
        this._openCallback = null;
        if (cb === null)
          return;
        if (this._pack.destroying)
          return cb(new Error("pack stream destroyed"));
        if (this._pack._finalized)
          return cb(new Error("pack stream is already finalized"));
        this._pack._stream = this;
        if (!this._isLinkname) {
          this._pack._encode(this.header);
        }
        if (this._isVoid) {
          this._finish();
          this._continuePack(null);
        }
        cb(null);
      }
      _write(data, cb) {
        if (this._isLinkname) {
          this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data;
          return cb(null);
        }
        if (this._isVoid) {
          if (data.byteLength > 0) {
            return cb(new Error("No body allowed for this entry"));
          }
          return cb();
        }
        this.written += data.byteLength;
        if (this._pack.push(data))
          return cb();
        this._pack._drain = cb;
      }
      _finish() {
        if (this._finished)
          return;
        this._finished = true;
        if (this._isLinkname) {
          this.header.linkname = this._linkname ? b4a.toString(this._linkname, "utf-8") : "";
          this._pack._encode(this.header);
        }
        overflow(this._pack, this.header.size);
        this._pack._done(this);
      }
      _final(cb) {
        if (this.written !== this.header.size) {
          return cb(new Error("Size mismatch"));
        }
        this._finish();
        cb(null);
      }
      _getError() {
        return getStreamError(this) || new Error("tar entry destroyed");
      }
      _predestroy() {
        this._pack.destroy(this._getError());
      }
      _destroy(cb) {
        this._pack._done(this);
        this._continuePack(this._finished ? null : this._getError());
        cb();
      }
    };
    var Pack = class extends Readable {
      constructor(opts) {
        super(opts);
        this._drain = noop2;
        this._finalized = false;
        this._finalizing = false;
        this._pending = [];
        this._stream = null;
      }
      entry(header, buffer, callback) {
        if (this._finalized || this.destroying)
          throw new Error("already finalized or destroyed");
        if (typeof buffer === "function") {
          callback = buffer;
          buffer = null;
        }
        if (!callback)
          callback = noop2;
        if (!header.size || header.type === "symlink")
          header.size = 0;
        if (!header.type)
          header.type = modeToType(header.mode);
        if (!header.mode)
          header.mode = header.type === "directory" ? DMODE : FMODE;
        if (!header.uid)
          header.uid = 0;
        if (!header.gid)
          header.gid = 0;
        if (!header.mtime)
          header.mtime = /* @__PURE__ */ new Date();
        if (typeof buffer === "string")
          buffer = b4a.from(buffer);
        const sink = new Sink(this, header, callback);
        if (b4a.isBuffer(buffer)) {
          header.size = buffer.byteLength;
          sink.write(buffer);
          sink.end();
          return sink;
        }
        if (sink._isVoid) {
          return sink;
        }
        return sink;
      }
      finalize() {
        if (this._stream || this._pending.length > 0) {
          this._finalizing = true;
          return;
        }
        if (this._finalized)
          return;
        this._finalized = true;
        this.push(END_OF_TAR);
        this.push(null);
      }
      _done(stream) {
        if (stream !== this._stream)
          return;
        this._stream = null;
        if (this._finalizing)
          this.finalize();
        if (this._pending.length)
          this._pending.shift()._continueOpen();
      }
      _encode(header) {
        if (!header.pax) {
          const buf = headers.encode(header);
          if (buf) {
            this.push(buf);
            return;
          }
        }
        this._encodePax(header);
      }
      _encodePax(header) {
        const paxHeader = headers.encodePax({
          name: header.name,
          linkname: header.linkname,
          pax: header.pax
        });
        const newHeader = {
          name: "PaxHeader",
          mode: header.mode,
          uid: header.uid,
          gid: header.gid,
          size: paxHeader.byteLength,
          mtime: header.mtime,
          type: "pax-header",
          linkname: header.linkname && "PaxHeader",
          uname: header.uname,
          gname: header.gname,
          devmajor: header.devmajor,
          devminor: header.devminor
        };
        this.push(headers.encode(newHeader));
        this.push(paxHeader);
        overflow(this, paxHeader.byteLength);
        newHeader.size = header.size;
        newHeader.type = header.type;
        this.push(headers.encode(newHeader));
      }
      _doDrain() {
        const drain = this._drain;
        this._drain = noop2;
        drain();
      }
      _predestroy() {
        const err = getStreamError(this);
        if (this._stream)
          this._stream.destroy(err);
        while (this._pending.length) {
          const stream = this._pending.shift();
          stream.destroy(err);
          stream._continueOpen();
        }
        this._doDrain();
      }
      _read(cb) {
        this._doDrain();
        cb();
      }
    };
    module.exports = function pack(opts) {
      return new Pack(opts);
    };
    function modeToType(mode) {
      switch (mode & constants.S_IFMT) {
        case constants.S_IFBLK:
          return "block-device";
        case constants.S_IFCHR:
          return "character-device";
        case constants.S_IFDIR:
          return "directory";
        case constants.S_IFIFO:
          return "fifo";
        case constants.S_IFLNK:
          return "symlink";
      }
      return "file";
    }
    function noop2() {
    }
    function overflow(self2, size) {
      size &= 511;
      if (size)
        self2.push(END_OF_TAR.subarray(0, 512 - size));
    }
    function mapWritable(buf) {
      return b4a.isBuffer(buf) ? buf : b4a.from(buf);
    }
  }
});

// ../../node_modules/tar-stream/index.js
var require_tar_stream = __commonJS({
  "../../node_modules/tar-stream/index.js"(exports) {
    "use strict";
    exports.extract = require_extract();
    exports.pack = require_pack();
  }
});

// ../../node_modules/archiver/lib/plugins/tar.js
var require_tar = __commonJS({
  "../../node_modules/archiver/lib/plugins/tar.js"(exports, module) {
    "use strict";
    var zlib = __require("zlib");
    var engine = require_tar_stream();
    var util = require_archiver_utils();
    var Tar = function(options) {
      if (!(this instanceof Tar)) {
        return new Tar(options);
      }
      options = this.options = util.defaults(options, {
        gzip: false
      });
      if (typeof options.gzipOptions !== "object") {
        options.gzipOptions = {};
      }
      this.supports = {
        directory: true,
        symlink: true
      };
      this.engine = engine.pack(options);
      this.compressor = false;
      if (options.gzip) {
        this.compressor = zlib.createGzip(options.gzipOptions);
        this.compressor.on("error", this._onCompressorError.bind(this));
      }
    };
    Tar.prototype._onCompressorError = function(err) {
      this.engine.emit("error", err);
    };
    Tar.prototype.append = function(source, data, callback) {
      var self2 = this;
      data.mtime = data.date;
      function append(err, sourceBuffer) {
        if (err) {
          callback(err);
          return;
        }
        self2.engine.entry(data, sourceBuffer, function(err2) {
          callback(err2, data);
        });
      }
      if (data.sourceType === "buffer") {
        append(null, source);
      } else if (data.sourceType === "stream" && data.stats) {
        data.size = data.stats.size;
        var entry = self2.engine.entry(data, function(err) {
          callback(err, data);
        });
        source.pipe(entry);
      } else if (data.sourceType === "stream") {
        util.collectStream(source, append);
      }
    };
    Tar.prototype.finalize = function() {
      this.engine.finalize();
    };
    Tar.prototype.on = function() {
      return this.engine.on.apply(this.engine, arguments);
    };
    Tar.prototype.pipe = function(destination, options) {
      if (this.compressor) {
        return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
      } else {
        return this.engine.pipe.apply(this.engine, arguments);
      }
    };
    Tar.prototype.unpipe = function() {
      if (this.compressor) {
        return this.compressor.unpipe.apply(this.compressor, arguments);
      } else {
        return this.engine.unpipe.apply(this.engine, arguments);
      }
    };
    module.exports = Tar;
  }
});

// ../../node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "../../node_modules/buffer-crc32/index.js"(exports, module) {
    "use strict";
    var Buffer2 = __require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module.exports = crc32;
  }
});

// ../../node_modules/archiver/lib/plugins/json.js
var require_json2 = __commonJS({
  "../../node_modules/archiver/lib/plugins/json.js"(exports, module) {
    "use strict";
    var inherits = __require("util").inherits;
    var Transform = require_readable2().Transform;
    var crc32 = require_buffer_crc32();
    var util = require_archiver_utils();
    var Json = function(options) {
      if (!(this instanceof Json)) {
        return new Json(options);
      }
      options = this.options = util.defaults(options, {});
      Transform.call(this, options);
      this.supports = {
        directory: true,
        symlink: true
      };
      this.files = [];
    };
    inherits(Json, Transform);
    Json.prototype._transform = function(chunk, encoding, callback) {
      callback(null, chunk);
    };
    Json.prototype._writeStringified = function() {
      var fileString = JSON.stringify(this.files);
      this.write(fileString);
    };
    Json.prototype.append = function(source, data, callback) {
      var self2 = this;
      data.crc32 = 0;
      function onend(err, sourceBuffer) {
        if (err) {
          callback(err);
          return;
        }
        data.size = sourceBuffer.length || 0;
        data.crc32 = crc32.unsigned(sourceBuffer);
        self2.files.push(data);
        callback(null, data);
      }
      if (data.sourceType === "buffer") {
        onend(null, source);
      } else if (data.sourceType === "stream") {
        util.collectStream(source, onend);
      }
    };
    Json.prototype.finalize = function() {
      this._writeStringified();
      this.end();
    };
    module.exports = Json;
  }
});

// ../../node_modules/archiver/index.js
var require_archiver = __commonJS({
  "../../node_modules/archiver/index.js"(exports, module) {
    "use strict";
    var Archiver = require_core4();
    var formats = {};
    var vending = function(format, options) {
      return vending.create(format, options);
    };
    vending.create = function(format, options) {
      if (formats[format]) {
        var instance = new Archiver(format, options);
        instance.setFormat(format);
        instance.setModule(new formats[format](options));
        return instance;
      } else {
        throw new Error("create(" + format + "): format not registered");
      }
    };
    vending.registerFormat = function(format, module2) {
      if (formats[format]) {
        throw new Error("register(" + format + "): format already registered");
      }
      if (typeof module2 !== "function") {
        throw new Error("register(" + format + "): format module invalid");
      }
      if (typeof module2.prototype.append !== "function" || typeof module2.prototype.finalize !== "function") {
        throw new Error("register(" + format + "): format module missing methods");
      }
      formats[format] = module2;
    };
    vending.isRegisteredFormat = function(format) {
      if (formats[format]) {
        return true;
      }
      return false;
    };
    vending.registerFormat("zip", require_zip());
    vending.registerFormat("tar", require_tar());
    vending.registerFormat("json", require_json2());
    module.exports = vending;
  }
});

// ../../node_modules/yazl/index.js
var require_yazl = __commonJS({
  "../../node_modules/yazl/index.js"(exports) {
    "use strict";
    var fs3 = __require("fs");
    var Transform = __require("stream").Transform;
    var PassThrough = __require("stream").PassThrough;
    var zlib = __require("zlib");
    var util = __require("util");
    var EventEmitter = __require("events").EventEmitter;
    var crc32 = require_buffer_crc32();
    exports.ZipFile = ZipFile;
    exports.dateToDosDateTime = dateToDosDateTime;
    util.inherits(ZipFile, EventEmitter);
    function ZipFile() {
      this.outputStream = new PassThrough();
      this.entries = [];
      this.outputStreamCursor = 0;
      this.ended = false;
      this.allDone = false;
      this.forceZip64Eocd = false;
    }
    ZipFile.prototype.addFile = function(realPath, metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (options == null)
        options = {};
      var entry = new Entry(metadataPath, false, options);
      self2.entries.push(entry);
      fs3.stat(realPath, function(err, stats) {
        if (err)
          return self2.emit("error", err);
        if (!stats.isFile())
          return self2.emit("error", new Error("not a file: " + realPath));
        entry.uncompressedSize = stats.size;
        if (options.mtime == null)
          entry.setLastModDate(stats.mtime);
        if (options.mode == null)
          entry.setFileAttributesMode(stats.mode);
        entry.setFileDataPumpFunction(function() {
          var readStream = fs3.createReadStream(realPath);
          entry.state = Entry.FILE_DATA_IN_PROGRESS;
          readStream.on("error", function(err2) {
            self2.emit("error", err2);
          });
          pumpFileDataReadStream(self2, entry, readStream);
        });
        pumpEntries(self2);
      });
    };
    ZipFile.prototype.addReadStream = function(readStream, metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (options == null)
        options = {};
      var entry = new Entry(metadataPath, false, options);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        entry.state = Entry.FILE_DATA_IN_PROGRESS;
        pumpFileDataReadStream(self2, entry, readStream);
      });
      pumpEntries(self2);
    };
    ZipFile.prototype.addBuffer = function(buffer, metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (buffer.length > 1073741823)
        throw new Error("buffer too large: " + buffer.length + " > 1073741823");
      if (options == null)
        options = {};
      if (options.size != null)
        throw new Error("options.size not allowed");
      var entry = new Entry(metadataPath, false, options);
      entry.uncompressedSize = buffer.length;
      entry.crc32 = crc32.unsigned(buffer);
      entry.crcAndFileSizeKnown = true;
      self2.entries.push(entry);
      if (!entry.compress) {
        setCompressedBuffer(buffer);
      } else {
        zlib.deflateRaw(buffer, function(err, compressedBuffer) {
          setCompressedBuffer(compressedBuffer);
        });
      }
      function setCompressedBuffer(compressedBuffer) {
        entry.compressedSize = compressedBuffer.length;
        entry.setFileDataPumpFunction(function() {
          writeToOutputStream(self2, compressedBuffer);
          writeToOutputStream(self2, entry.getDataDescriptor());
          entry.state = Entry.FILE_DATA_DONE;
          setImmediate(function() {
            pumpEntries(self2);
          });
        });
        pumpEntries(self2);
      }
    };
    ZipFile.prototype.addEmptyDirectory = function(metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, true);
      if (options == null)
        options = {};
      if (options.size != null)
        throw new Error("options.size not allowed");
      if (options.compress != null)
        throw new Error("options.compress not allowed");
      var entry = new Entry(metadataPath, true, options);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
      pumpEntries(self2);
    };
    var eocdrSignatureBuffer = bufferFrom([80, 75, 5, 6]);
    ZipFile.prototype.end = function(options, finalSizeCallback) {
      if (typeof options === "function") {
        finalSizeCallback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (this.ended)
        return;
      this.ended = true;
      this.finalSizeCallback = finalSizeCallback;
      this.forceZip64Eocd = !!options.forceZip64Format;
      if (options.comment) {
        if (typeof options.comment === "string") {
          this.comment = encodeCp437(options.comment);
        } else {
          this.comment = options.comment;
        }
        if (this.comment.length > 65535)
          throw new Error("comment is too large");
        if (bufferIncludes(this.comment, eocdrSignatureBuffer))
          throw new Error("comment contains end of central directory record signature");
      } else {
        this.comment = EMPTY_BUFFER;
      }
      pumpEntries(this);
    };
    function writeToOutputStream(self2, buffer) {
      self2.outputStream.write(buffer);
      self2.outputStreamCursor += buffer.length;
    }
    function pumpFileDataReadStream(self2, entry, readStream) {
      var crc32Watcher = new Crc32Watcher();
      var uncompressedSizeCounter = new ByteCounter();
      var compressor = entry.compress ? new zlib.DeflateRaw() : new PassThrough();
      var compressedSizeCounter = new ByteCounter();
      readStream.pipe(crc32Watcher).pipe(uncompressedSizeCounter).pipe(compressor).pipe(compressedSizeCounter).pipe(self2.outputStream, { end: false });
      compressedSizeCounter.on("end", function() {
        entry.crc32 = crc32Watcher.crc32;
        if (entry.uncompressedSize == null) {
          entry.uncompressedSize = uncompressedSizeCounter.byteCount;
        } else {
          if (entry.uncompressedSize !== uncompressedSizeCounter.byteCount)
            return self2.emit("error", new Error("file data stream has unexpected number of bytes"));
        }
        entry.compressedSize = compressedSizeCounter.byteCount;
        self2.outputStreamCursor += entry.compressedSize;
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
    }
    function pumpEntries(self2) {
      if (self2.allDone)
        return;
      if (self2.ended && self2.finalSizeCallback != null) {
        var finalSize = calculateFinalSize(self2);
        if (finalSize != null) {
          self2.finalSizeCallback(finalSize);
          self2.finalSizeCallback = null;
        }
      }
      var entry = getFirstNotDoneEntry();
      function getFirstNotDoneEntry() {
        for (var i = 0; i < self2.entries.length; i++) {
          var entry2 = self2.entries[i];
          if (entry2.state < Entry.FILE_DATA_DONE)
            return entry2;
        }
        return null;
      }
      if (entry != null) {
        if (entry.state < Entry.READY_TO_PUMP_FILE_DATA)
          return;
        if (entry.state === Entry.FILE_DATA_IN_PROGRESS)
          return;
        entry.relativeOffsetOfLocalHeader = self2.outputStreamCursor;
        var localFileHeader = entry.getLocalFileHeader();
        writeToOutputStream(self2, localFileHeader);
        entry.doFileDataPump();
      } else {
        if (self2.ended) {
          self2.offsetOfStartOfCentralDirectory = self2.outputStreamCursor;
          self2.entries.forEach(function(entry2) {
            var centralDirectoryRecord = entry2.getCentralDirectoryRecord();
            writeToOutputStream(self2, centralDirectoryRecord);
          });
          writeToOutputStream(self2, getEndOfCentralDirectoryRecord(self2));
          self2.outputStream.end();
          self2.allDone = true;
        }
      }
    }
    function calculateFinalSize(self2) {
      var pretendOutputCursor = 0;
      var centralDirectorySize = 0;
      for (var i = 0; i < self2.entries.length; i++) {
        var entry = self2.entries[i];
        if (entry.compress)
          return -1;
        if (entry.state >= Entry.READY_TO_PUMP_FILE_DATA) {
          if (entry.uncompressedSize == null)
            return -1;
        } else {
          if (entry.uncompressedSize == null)
            return null;
        }
        entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
        var useZip64Format = entry.useZip64Format();
        pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
        pretendOutputCursor += entry.uncompressedSize;
        if (!entry.crcAndFileSizeKnown) {
          if (useZip64Format) {
            pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
          } else {
            pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
          }
        }
        centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
        if (useZip64Format) {
          centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
        }
      }
      var endOfCentralDirectorySize = 0;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535 || centralDirectorySize >= 65535 || pretendOutputCursor >= 4294967295) {
        endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
      }
      endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length;
      return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
    }
    var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
    var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
    var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
    function getEndOfCentralDirectoryRecord(self2, actuallyJustTellMeHowLongItWouldBe) {
      var needZip64Format = false;
      var normalEntriesLength = self2.entries.length;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535) {
        normalEntriesLength = 65535;
        needZip64Format = true;
      }
      var sizeOfCentralDirectory = self2.outputStreamCursor - self2.offsetOfStartOfCentralDirectory;
      var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
      if (self2.forceZip64Eocd || sizeOfCentralDirectory >= 4294967295) {
        normalSizeOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      var normalOffsetOfStartOfCentralDirectory = self2.offsetOfStartOfCentralDirectory;
      if (self2.forceZip64Eocd || self2.offsetOfStartOfCentralDirectory >= 4294967295) {
        normalOffsetOfStartOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      if (actuallyJustTellMeHowLongItWouldBe) {
        if (needZip64Format) {
          return ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE + END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        } else {
          return END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        }
      }
      var eocdrBuffer = bufferAlloc(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length);
      eocdrBuffer.writeUInt32LE(101010256, 0);
      eocdrBuffer.writeUInt16LE(0, 4);
      eocdrBuffer.writeUInt16LE(0, 6);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
      eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
      eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
      eocdrBuffer.writeUInt16LE(self2.comment.length, 20);
      self2.comment.copy(eocdrBuffer, 22);
      if (!needZip64Format)
        return eocdrBuffer;
      var zip64EocdrBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
      zip64EocdrBuffer.writeUInt32LE(101075792, 0);
      writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
      zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
      zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
      zip64EocdrBuffer.writeUInt32LE(0, 16);
      zip64EocdrBuffer.writeUInt32LE(0, 20);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 24);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 32);
      writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
      writeUInt64LE(zip64EocdrBuffer, self2.offsetOfStartOfCentralDirectory, 48);
      var zip64EocdlBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
      zip64EocdlBuffer.writeUInt32LE(117853008, 0);
      zip64EocdlBuffer.writeUInt32LE(0, 4);
      writeUInt64LE(zip64EocdlBuffer, self2.outputStreamCursor, 8);
      zip64EocdlBuffer.writeUInt32LE(1, 16);
      return Buffer.concat([
        zip64EocdrBuffer,
        zip64EocdlBuffer,
        eocdrBuffer
      ]);
    }
    function validateMetadataPath(metadataPath, isDirectory) {
      if (metadataPath === "")
        throw new Error("empty metadataPath");
      metadataPath = metadataPath.replace(/\\/g, "/");
      if (/^[a-zA-Z]:/.test(metadataPath) || /^\//.test(metadataPath))
        throw new Error("absolute path: " + metadataPath);
      if (metadataPath.split("/").indexOf("..") !== -1)
        throw new Error("invalid relative path: " + metadataPath);
      var looksLikeDirectory = /\/$/.test(metadataPath);
      if (isDirectory) {
        if (!looksLikeDirectory)
          metadataPath += "/";
      } else {
        if (looksLikeDirectory)
          throw new Error("file path cannot end with '/': " + metadataPath);
      }
      return metadataPath;
    }
    var EMPTY_BUFFER = bufferAlloc(0);
    function Entry(metadataPath, isDirectory, options) {
      this.utf8FileName = bufferFrom(metadataPath);
      if (this.utf8FileName.length > 65535)
        throw new Error("utf8 file name too long. " + utf8FileName.length + " > 65535");
      this.isDirectory = isDirectory;
      this.state = Entry.WAITING_FOR_METADATA;
      this.setLastModDate(options.mtime != null ? options.mtime : /* @__PURE__ */ new Date());
      if (options.mode != null) {
        this.setFileAttributesMode(options.mode);
      } else {
        this.setFileAttributesMode(isDirectory ? 16893 : 33204);
      }
      if (isDirectory) {
        this.crcAndFileSizeKnown = true;
        this.crc32 = 0;
        this.uncompressedSize = 0;
        this.compressedSize = 0;
      } else {
        this.crcAndFileSizeKnown = false;
        this.crc32 = null;
        this.uncompressedSize = null;
        this.compressedSize = null;
        if (options.size != null)
          this.uncompressedSize = options.size;
      }
      if (isDirectory) {
        this.compress = false;
      } else {
        this.compress = true;
        if (options.compress != null)
          this.compress = !!options.compress;
      }
      this.forceZip64Format = !!options.forceZip64Format;
      if (options.fileComment) {
        if (typeof options.fileComment === "string") {
          this.fileComment = bufferFrom(options.fileComment, "utf-8");
        } else {
          this.fileComment = options.fileComment;
        }
        if (this.fileComment.length > 65535)
          throw new Error("fileComment is too large");
      } else {
        this.fileComment = EMPTY_BUFFER;
      }
    }
    Entry.WAITING_FOR_METADATA = 0;
    Entry.READY_TO_PUMP_FILE_DATA = 1;
    Entry.FILE_DATA_IN_PROGRESS = 2;
    Entry.FILE_DATA_DONE = 3;
    Entry.prototype.setLastModDate = function(date) {
      var dosDateTime = dateToDosDateTime(date);
      this.lastModFileTime = dosDateTime.time;
      this.lastModFileDate = dosDateTime.date;
    };
    Entry.prototype.setFileAttributesMode = function(mode) {
      if ((mode & 65535) !== mode)
        throw new Error("invalid mode. expected: 0 <= " + mode + " <= 65535");
      this.externalFileAttributes = mode << 16 >>> 0;
    };
    Entry.prototype.setFileDataPumpFunction = function(doFileDataPump) {
      this.doFileDataPump = doFileDataPump;
      this.state = Entry.READY_TO_PUMP_FILE_DATA;
    };
    Entry.prototype.useZip64Format = function() {
      return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
    };
    var LOCAL_FILE_HEADER_FIXED_SIZE = 30;
    var VERSION_NEEDED_TO_EXTRACT_UTF8 = 20;
    var VERSION_NEEDED_TO_EXTRACT_ZIP64 = 45;
    var VERSION_MADE_BY = 3 << 8 | 63;
    var FILE_NAME_IS_UTF8 = 1 << 11;
    var UNKNOWN_CRC32_AND_FILE_SIZES = 1 << 3;
    Entry.prototype.getLocalFileHeader = function() {
      var crc322 = 0;
      var compressedSize = 0;
      var uncompressedSize = 0;
      if (this.crcAndFileSizeKnown) {
        crc322 = this.crc32;
        compressedSize = this.compressedSize;
        uncompressedSize = this.uncompressedSize;
      }
      var fixedSizeStuff = bufferAlloc(LOCAL_FILE_HEADER_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown)
        generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      fixedSizeStuff.writeUInt32LE(67324752, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_UTF8, 4);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 6);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 8);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 12);
      fixedSizeStuff.writeUInt32LE(crc322, 14);
      fixedSizeStuff.writeUInt32LE(compressedSize, 18);
      fixedSizeStuff.writeUInt32LE(uncompressedSize, 22);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 26);
      fixedSizeStuff.writeUInt16LE(0, 28);
      return Buffer.concat([
        fixedSizeStuff,
        // file name (variable size)
        this.utf8FileName
        // extra field (variable size)
        // no extra fields
      ]);
    };
    var DATA_DESCRIPTOR_SIZE = 16;
    var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
    Entry.prototype.getDataDescriptor = function() {
      if (this.crcAndFileSizeKnown) {
        return EMPTY_BUFFER;
      }
      if (!this.useZip64Format()) {
        var buffer = bufferAlloc(DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        buffer.writeUInt32LE(this.compressedSize, 8);
        buffer.writeUInt32LE(this.uncompressedSize, 12);
        return buffer;
      } else {
        var buffer = bufferAlloc(ZIP64_DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        writeUInt64LE(buffer, this.compressedSize, 8);
        writeUInt64LE(buffer, this.uncompressedSize, 16);
        return buffer;
      }
    };
    var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
    var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
    Entry.prototype.getCentralDirectoryRecord = function() {
      var fixedSizeStuff = bufferAlloc(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown)
        generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      var normalCompressedSize = this.compressedSize;
      var normalUncompressedSize = this.uncompressedSize;
      var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
      var versionNeededToExtract;
      var zeiefBuffer;
      if (this.useZip64Format()) {
        normalCompressedSize = 4294967295;
        normalUncompressedSize = 4294967295;
        normalRelativeOffsetOfLocalHeader = 4294967295;
        versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;
        zeiefBuffer = bufferAlloc(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
        zeiefBuffer.writeUInt16LE(1, 0);
        zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
        writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
        writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
        writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
      } else {
        versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
        zeiefBuffer = EMPTY_BUFFER;
      }
      fixedSizeStuff.writeUInt32LE(33639248, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
      fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
      fixedSizeStuff.writeUInt32LE(this.crc32, 16);
      fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
      fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
      fixedSizeStuff.writeUInt16LE(zeiefBuffer.length, 30);
      fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
      fixedSizeStuff.writeUInt16LE(0, 34);
      fixedSizeStuff.writeUInt16LE(0, 36);
      fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
      fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);
      return Buffer.concat([
        fixedSizeStuff,
        // file name (variable size)
        this.utf8FileName,
        // extra field (variable size)
        zeiefBuffer,
        // file comment (variable size)
        this.fileComment
      ]);
    };
    Entry.prototype.getCompressionMethod = function() {
      var NO_COMPRESSION = 0;
      var DEFLATE_COMPRESSION = 8;
      return this.compress ? DEFLATE_COMPRESSION : NO_COMPRESSION;
    };
    function dateToDosDateTime(jsDate) {
      var date = 0;
      date |= jsDate.getDate() & 31;
      date |= (jsDate.getMonth() + 1 & 15) << 5;
      date |= (jsDate.getFullYear() - 1980 & 127) << 9;
      var time = 0;
      time |= Math.floor(jsDate.getSeconds() / 2);
      time |= (jsDate.getMinutes() & 63) << 5;
      time |= (jsDate.getHours() & 31) << 11;
      return { date, time };
    }
    function writeUInt64LE(buffer, n, offset) {
      var high = Math.floor(n / 4294967296);
      var low = n % 4294967296;
      buffer.writeUInt32LE(low, offset);
      buffer.writeUInt32LE(high, offset + 4);
    }
    util.inherits(ByteCounter, Transform);
    function ByteCounter(options) {
      Transform.call(this, options);
      this.byteCount = 0;
    }
    ByteCounter.prototype._transform = function(chunk, encoding, cb) {
      this.byteCount += chunk.length;
      cb(null, chunk);
    };
    util.inherits(Crc32Watcher, Transform);
    function Crc32Watcher(options) {
      Transform.call(this, options);
      this.crc32 = 0;
    }
    Crc32Watcher.prototype._transform = function(chunk, encoding, cb) {
      this.crc32 = crc32.unsigned(chunk, this.crc32);
      cb(null, chunk);
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    if (cp437.length !== 256)
      throw new Error("assertion failure");
    var reverseCp437 = null;
    function encodeCp437(string) {
      if (/^[\x20-\x7e]*$/.test(string)) {
        return bufferFrom(string, "utf-8");
      }
      if (reverseCp437 == null) {
        reverseCp437 = {};
        for (var i = 0; i < cp437.length; i++) {
          reverseCp437[cp437[i]] = i;
        }
      }
      var result = bufferAlloc(string.length);
      for (var i = 0; i < string.length; i++) {
        var b = reverseCp437[string[i]];
        if (b == null)
          throw new Error("character not encodable in CP437: " + JSON.stringify(string[i]));
        result[i] = b;
      }
      return result;
    }
    function bufferAlloc(size) {
      bufferAlloc = modern;
      try {
        return bufferAlloc(size);
      } catch (e) {
        bufferAlloc = legacy;
        return bufferAlloc(size);
      }
      function modern(size2) {
        return Buffer.allocUnsafe(size2);
      }
      function legacy(size2) {
        return new Buffer(size2);
      }
    }
    function bufferFrom(something, encoding) {
      bufferFrom = modern;
      try {
        return bufferFrom(something, encoding);
      } catch (e) {
        bufferFrom = legacy;
        return bufferFrom(something, encoding);
      }
      function modern(something2, encoding2) {
        return Buffer.from(something2, encoding2);
      }
      function legacy(something2, encoding2) {
        return new Buffer(something2, encoding2);
      }
    }
    function bufferIncludes(buffer, content) {
      bufferIncludes = modern;
      try {
        return bufferIncludes(buffer, content);
      } catch (e) {
        bufferIncludes = legacy;
        return bufferIncludes(buffer, content);
      }
      function modern(buffer2, content2) {
        return buffer2.includes(content2);
      }
      function legacy(buffer2, content2) {
        for (var i = 0; i <= buffer2.length - content2.length; i++) {
          for (var j = 0; ; j++) {
            if (j === content2.length)
              return true;
            if (buffer2[i + j] !== content2[j])
              break;
          }
        }
        return false;
      }
    }
  }
});

// ../../node_modules/zip-lib/lib/util.js
var require_util4 = __commonJS({
  "../../node_modules/zip-lib/lib/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readlink = exports.symlink = exports.rmdir = exports.access = exports.readdir = exports.chmod = exports.lstat = exports.stat = exports.realpath = exports.mkdir = exports.unlink = void 0;
    var fs3 = __require("fs");
    var util = __require("util");
    function unlink(path9) {
      return util.promisify(fs3.unlink)(path9);
    }
    exports.unlink = unlink;
    function mkdir(path9, mode) {
      return util.promisify(fs3.mkdir)(path9, mode);
    }
    exports.mkdir = mkdir;
    function realpath(path9) {
      return util.promisify(fs3.realpath)(path9);
    }
    exports.realpath = realpath;
    function stat(path9) {
      return util.promisify(fs3.stat)(path9);
    }
    exports.stat = stat;
    function lstat(path9) {
      return util.promisify(fs3.lstat)(path9);
    }
    exports.lstat = lstat;
    function chmod(path9, mode) {
      return util.promisify(fs3.chmod)(path9, mode);
    }
    exports.chmod = chmod;
    function readdir(path9) {
      return util.promisify(fs3.readdir)(path9);
    }
    exports.readdir = readdir;
    function access(path9, mode) {
      return util.promisify(fs3.access)(path9, mode);
    }
    exports.access = access;
    function rmdir(path9) {
      return util.promisify(fs3.rmdir)(path9);
    }
    exports.rmdir = rmdir;
    function symlink(target, path9, type) {
      return util.promisify(fs3.symlink)(target, path9, type);
    }
    exports.symlink = symlink;
    function readlink(path9) {
      return util.promisify(fs3.readlink)(path9);
    }
    exports.readlink = readlink;
  }
});

// ../../node_modules/zip-lib/lib/fs.js
var require_fs3 = __commonJS({
  "../../node_modules/zip-lib/lib/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isRootPath = exports.rimraf = exports.pathExists = exports.ensureFolder = exports.getFileEntry = exports.readdirp = void 0;
    var path9 = __require("path");
    var util = require_util4();
    async function readdirp(folder) {
      const result = [];
      const files = await util.readdir(folder);
      for (const item of files) {
        const file = path9.join(folder, item);
        const entry = await getFileEntry(file);
        if (!entry.isSymbolicLink && entry.type === "dir") {
          const subFiles = await readdirp(file);
          if (subFiles.length > 0) {
            result.push(...subFiles);
            continue;
          }
        }
        result.push(entry);
      }
      return result;
    }
    exports.readdirp = readdirp;
    async function getFileEntry(target) {
      const stat = await util.lstat(target);
      let isSymbolicLink = false;
      let fileType = "file";
      if (stat.isDirectory()) {
        fileType = "dir";
      } else {
        if (stat.isSymbolicLink()) {
          isSymbolicLink = true;
          const actualStat = await util.stat(target);
          if (actualStat.isDirectory()) {
            fileType = "dir";
          }
        }
      }
      return {
        path: target,
        isSymbolicLink,
        type: fileType,
        mtime: stat.mtime,
        mode: stat.mode
      };
    }
    exports.getFileEntry = getFileEntry;
    async function ensureFolder(folder) {
      if (folder === path9.dirname(folder)) {
        return Promise.resolve();
      }
      try {
        await mkdir(folder);
      } catch (error) {
        if (error.code === "ENOENT") {
          await ensureFolder(path9.dirname(folder));
          return mkdir(folder);
        }
        return Promise.reject(error);
      }
    }
    exports.ensureFolder = ensureFolder;
    async function pathExists(target) {
      try {
        await util.access(target);
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.pathExists = pathExists;
    async function rimraf3(target) {
      if (isRootPath(target)) {
        return Promise.reject(new Error(`Refuse to recursively delete root, path: "${target}"`));
      }
      try {
        const stat = await util.lstat(target);
        if (stat.isDirectory() && !stat.isSymbolicLink()) {
          const children = await util.readdir(target);
          await Promise.all(children.map((child) => rimraf3(path9.join(target, child))));
          await util.rmdir(target);
        } else {
          const mode = stat.mode;
          if (!(mode & 128)) {
            await util.chmod(target, mode | 128);
          }
          return util.unlink(target);
        }
      } catch (error) {
        if (error.code !== "ENOENT") {
          throw error;
        }
      }
    }
    exports.rimraf = rimraf3;
    async function mkdir(folder) {
      try {
        await util.mkdir(folder, 511);
      } catch (error) {
        if (error.code === "ENOENT") {
          return Promise.reject(error);
        }
        try {
          const fileStat = await util.stat(folder);
          if (!fileStat.isDirectory()) {
            return Promise.reject(new Error(`"${folder}" exists and is not a directory.`));
          }
        } catch (statError) {
          throw error;
        }
      }
    }
    var charA = 65;
    var charZ = 90;
    var chara = 97;
    var charz = 122;
    var charColon = 58;
    var charWinSep = 92;
    var cahrUnixSep = 47;
    function isDriveLetter(char0) {
      return char0 >= charA && char0 <= charZ || char0 >= chara && char0 <= charz;
    }
    var winSep = "\\";
    var unixSep = "/";
    function isRootPath(target) {
      if (!target) {
        return false;
      }
      if (target === winSep || target === unixSep) {
        return true;
      }
      if (process.platform === "win32") {
        if (target.length > 3) {
          return false;
        }
        return isDriveLetter(target.charCodeAt(0)) && target.charCodeAt(1) === charColon && (target.length === 2 || target.charCodeAt(2) === charWinSep || target.charCodeAt(2) === cahrUnixSep);
      }
      return false;
    }
    exports.isRootPath = isRootPath;
  }
});

// ../../node_modules/zip-lib/lib/cancelable.js
var require_cancelable = __commonJS({
  "../../node_modules/zip-lib/lib/cancelable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cancelable = exports.CancellationToken = void 0;
    var CancellationToken = class {
      constructor() {
        this._isCancelled = false;
        this._callbacks = /* @__PURE__ */ new Set();
      }
      /**
       * A flag signalling is cancellation has been requested.
       */
      get isCancelled() {
        return this._isCancelled;
      }
      /**
       * Subscribe a callback when cancellation is requested. The callback
       * only ever fires `once` as cancellation can only happen once.
       * @param cb A function will be called when cancellation is requested.
       * @returns A function that Unsubscribe the cancellation callback.
       */
      onCancelled(cb) {
        if (this.isCancelled) {
          cb();
          return () => {
          };
        }
        this._callbacks.add(cb);
        return () => this._callbacks.delete(cb);
      }
      cancel() {
        if (this._isCancelled) {
          return;
        }
        this._isCancelled = true;
        this._callbacks.forEach((cb) => cb());
        this._callbacks.clear();
      }
    };
    exports.CancellationToken = CancellationToken;
    var Cancelable = class {
      /**
       * Ignore any other error if the `cancel` method has been called
       *
       * Error: EBADF: bad file descriptor, read
       * EBADF error may occur when calling the cancel method.
       * see https://travis-ci.org/fpsqdb/zip-lib/jobs/606040627#L124
       * @param error
       */
      wrapError(error, isCanceled) {
        if (isCanceled) {
          return this.canceledError();
        }
        return error;
      }
      /**
       * Returns an error that signals cancellation.
       */
      canceledError() {
        const error = new Error("Canceled");
        error.name = error.message;
        return error;
      }
    };
    exports.Cancelable = Cancelable;
  }
});

// ../../node_modules/zip-lib/lib/zip.js
var require_zip2 = __commonJS({
  "../../node_modules/zip-lib/lib/zip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Zip = void 0;
    var yazl = require_yazl();
    var fs_1 = __require("fs");
    var exfs = require_fs3();
    var path9 = __require("path");
    var util = require_util4();
    var cancelable_1 = require_cancelable();
    var Zip2 = class extends cancelable_1.Cancelable {
      /**
       *
       */
      constructor(options) {
        super();
        this.options = options;
        this.isPipe = false;
        this.zipFiles = [];
        this.zipFolders = [];
      }
      /**
       * Adds a file from the file system at realPath into the zipfile as metadataPath.
       * @param file
       * @param metadataPath Typically metadataPath would be calculated as path.relative(root, realPath).
       * A valid metadataPath must not start with "/" or /[A-Za-z]:\//, and must not contain "..".
       */
      addFile(file, metadataPath) {
        let mpath = metadataPath;
        if (!mpath) {
          mpath = path9.basename(file);
        }
        this.zipFiles.push({
          path: file,
          metadataPath: mpath
        });
      }
      /**
       * Adds a folder from the file system at realPath into the zipfile as metadataPath.
       * @param folder
       * @param metadataPath Typically metadataPath would be calculated as path.relative(root, realPath).
       * A valid metadataPath must not start with "/" or /[A-Za-z]:\//, and must not contain "..".
       */
      addFolder(folder, metadataPath) {
        this.zipFolders.push({
          path: folder,
          metadataPath
        });
      }
      /**
       * Generate zip file.
       * @param zipFile the zip file path.
       */
      async archive(zipFile) {
        if (!zipFile) {
          return Promise.reject(new Error("zipPath must not be empty"));
        }
        const token = new cancelable_1.CancellationToken();
        this.token = token;
        this.isPipe = false;
        await exfs.ensureFolder(path9.dirname(zipFile));
        this.yazlFile = new yazl.ZipFile();
        return new Promise(async (c, e) => {
          this.yazlFile.once("error", (err) => {
            e(this.wrapError(err, token.isCancelled));
          });
          const zip = this.yazlFile;
          if (!token.isCancelled) {
            this.zipStream = (0, fs_1.createWriteStream)(zipFile);
            this.zipStream.once("error", (err) => {
              e(this.wrapError(err, token.isCancelled));
            });
            this.zipStream.once("close", () => {
              if (token.isCancelled) {
                e(this.canceledError());
              } else {
                c(void 0);
              }
            });
            zip.outputStream.once("error", (err) => {
              e(this.wrapError(err, token.isCancelled));
            });
            zip.outputStream.pipe(this.zipStream);
            this.isPipe = true;
          }
          try {
            const files = this.zipFiles;
            for (const file of files) {
              const entry = await exfs.getFileEntry(file.path);
              await this.addEntry(zip, entry, file, token);
            }
            if (this.zipFolders.length > 0) {
              await this.walkDir(this.zipFolders, token);
            }
          } catch (error) {
            e(this.wrapError(error, token.isCancelled));
            return;
          }
          zip.end();
        });
      }
      /**
       * Cancel compression.
       * If the cancel method is called after the archive is complete, nothing will happen.
       */
      cancel() {
        if (this.token) {
          this.token.cancel();
          this.token = null;
        }
        this.stopPipe(this.canceledError());
      }
      async addEntry(zip, entry, file, token) {
        if (entry.isSymbolicLink) {
          if (this.followSymlink()) {
            if (entry.type === "dir") {
              const realPath = await util.realpath(file.path);
              await this.walkDir([{ path: realPath, metadataPath: file.metadataPath }], token);
            } else {
              zip.addFile(file.path, file.metadataPath);
            }
          } else {
            await this.addSymlink(zip, entry, file.metadataPath);
          }
        } else {
          if (entry.type === "dir") {
            zip.addEmptyDirectory(file.metadataPath, {
              mtime: entry.mtime,
              mode: entry.mode
            });
          } else {
            await this.addFileStream(zip, entry, file.metadataPath, token);
          }
        }
      }
      addFileStream(zip, file, metadataPath, token) {
        return new Promise((c, e) => {
          const fileStream = (0, fs_1.createReadStream)(file.path);
          fileStream.once("error", (err) => {
            const wrappedError = this.wrapError(err, token.isCancelled);
            this.stopPipe(wrappedError);
            e(wrappedError);
          });
          fileStream.once("close", () => {
            c();
          });
          zip.addReadStream(fileStream, metadataPath, {
            mode: file.mode,
            mtime: file.mtime
          });
        });
      }
      async addSymlink(zip, file, metadataPath) {
        const linkTarget = await util.readlink(file.path);
        zip.addBuffer(Buffer.from(linkTarget), metadataPath, {
          mtime: file.mtime,
          mode: file.mode
        });
      }
      async walkDir(folders, token) {
        for (const folder of folders) {
          if (token.isCancelled) {
            return;
          }
          const entries = await exfs.readdirp(folder.path);
          if (entries.length > 0) {
            for (const entry of entries) {
              if (token.isCancelled) {
                return;
              }
              const relativePath = path9.relative(folder.path, entry.path);
              const metadataPath = folder.metadataPath ? path9.join(folder.metadataPath, relativePath) : relativePath;
              await this.addEntry(this.yazlFile, entry, { path: entry.path, metadataPath }, token);
            }
          } else {
            if (folder.metadataPath) {
              this.yazlFile.addEmptyDirectory(folder.metadataPath);
            }
          }
        }
      }
      stopPipe(err) {
        if (this.isPipe) {
          this.yazlFile.outputStream.unpipe(this.zipStream);
          this.zipStream.destroy(err);
          this.isPipe = false;
        }
      }
      followSymlink() {
        let followSymlink = false;
        if (this.options && this.options.followSymlinks === true) {
          followSymlink = true;
        }
        return followSymlink;
      }
    };
    exports.Zip = Zip2;
  }
});

// ../../node_modules/pend/index.js
var require_pend = __commonJS({
  "../../node_modules/pend/index.js"(exports, module) {
    "use strict";
    module.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called)
          throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// ../../node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "../../node_modules/fd-slicer/index.js"(exports) {
    "use strict";
    var fs3 = __require("fs");
    var util = __require("util");
    var stream = __require("stream");
    var Readable = stream.Readable;
    var Writable = stream.Writable;
    var PassThrough = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = __require("events").EventEmitter;
    exports.createFromBuffer = createFromBuffer;
    exports.createFromFd = createFromFd;
    exports.BufferSlicer = BufferSlicer;
    exports.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options) {
      options = options || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs3.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs3.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options) {
      return new ReadStream(this, options);
    };
    FdSlicer.prototype.createWriteStream = function(options) {
      return new WriteStream(this, options);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      if (self2.autoClose) {
        fs3.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options) {
      options = options || {};
      Readable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed)
        return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        var buffer = new Buffer(toRead);
        fs3.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options) {
      options = options || {};
      Writable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end == null ? Infinity : +options.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed)
        return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        fs3.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options) {
      EventEmitter.call(this);
      options = options || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var end = position + length;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length;
      this.buffer.copy(buffer, offset, position, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options) {
      options = options || {};
      var readStream = new PassThrough(options);
      readStream.destroyed = false;
      readStream.start = options.start || 0;
      readStream.endOffset = options.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options) {
      var bufferSlicer = this;
      options = options || {};
      var writeStream = new Writable(options);
      writeStream.start = options.start || 0;
      writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed)
          return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options) {
      return new BufferSlicer(buffer, options);
    }
    function createFromFd(fd, options) {
      return new FdSlicer(fd, options);
    }
  }
});

// ../../node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "../../node_modules/yauzl/index.js"(exports) {
    "use strict";
    var fs3 = __require("fs");
    var zlib = __require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = __require("util");
    var EventEmitter = __require("events").EventEmitter;
    var Transform = __require("stream").Transform;
    var PassThrough = __require("stream").PassThrough;
    var Writable = __require("stream").Writable;
    exports.open = open;
    exports.fromFd = fromFd;
    exports.fromBuffer = fromBuffer;
    exports.fromRandomAccessReader = fromRandomAccessReader;
    exports.dosDateTimeToDate = dosDateTimeToDate;
    exports.validateFileName = validateFileName;
    exports.ZipFile = ZipFile;
    exports.Entry = Entry;
    exports.RandomAccessReader = RandomAccessReader;
    function open(path9, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs3.open(path9, "r", function(err, fd) {
        if (err)
          return callback(err);
        fromFd(fd, options, function(err2, zipfile) {
          if (err2)
            fs3.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs3.fstat(fd, function(err, stats) {
        if (err)
          return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options, callback);
      });
    }
    function fromBuffer(buffer, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      var decodeStrings = !!options.decodeStrings;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      if (typeof totalSize !== "number")
        throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err)
          return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256)
            continue;
          var eocdrBuffer = buffer.slice(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2)
              return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3)
                return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries)
        self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose)
        self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError)
        return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries)
        throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose)
            self2.close();
          if (self2.emittedError)
            return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError)
        return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err)
          return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError)
          return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248)
          return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64)
          return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2)
            return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError)
            return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null)
              return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries)
            self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options;
        options = {};
      } else {
        if (options.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options.decrypt !== false)
            throw new Error("invalid options.decrypt value: " + options.decrypt);
          if (entry.isCompressed()) {
            if (options.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options.decompress === false || options.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options.decompress);
          }
        }
        if (options.start != null || options.end != null) {
          if (entry.isCompressed() && options.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options.start != null) {
          relativeStart = options.start;
          if (relativeStart < 0)
            throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize)
            throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
          relativeEnd = options.end;
          if (relativeEnd < 0)
            throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize)
            throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart)
            throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen)
        return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options.decrypt !== false)
          return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err)
            return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options.decompress != null ? options.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed)
                    endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream)
                inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err)
          return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err)
          return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options) {
      var start = options.start;
      var end = options.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet)
        return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i = start; i < end; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function defaultCallback(err) {
      if (err)
        throw err;
    }
  }
});

// ../../node_modules/zip-lib/lib/unzip.js
var require_unzip = __commonJS({
  "../../node_modules/zip-lib/lib/unzip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Unzip = void 0;
    var yauzl = require_yauzl();
    var exfs = require_fs3();
    var fs_1 = __require("fs");
    var path9 = __require("path");
    var util = require_util4();
    var cancelable_1 = require_cancelable();
    var EntryEvent = class {
      /**
       *
       */
      constructor(_entryCount) {
        this._entryCount = _entryCount;
        this._isPrevented = false;
      }
      get entryName() {
        return this._entryName;
      }
      set entryName(name) {
        this._entryName = name;
      }
      get entryCount() {
        return this._entryCount;
      }
      get isPrevented() {
        return this._isPrevented;
      }
      preventDefault() {
        this._isPrevented = true;
      }
      reset() {
        this._isPrevented = false;
      }
    };
    var EntryContext = class {
      constructor(_targetFolder, _realTargetFolder, symlinkAsFileOnWindows) {
        this._targetFolder = _targetFolder;
        this._realTargetFolder = _realTargetFolder;
        this.symlinkAsFileOnWindows = symlinkAsFileOnWindows;
        this._symlinkFileNames = [];
      }
      get decodeEntryFileName() {
        return this._decodeEntryFileName;
      }
      set decodeEntryFileName(name) {
        this._decodeEntryFileName = name;
      }
      get targetFolder() {
        return this._targetFolder;
      }
      get realTargetFolder() {
        return this._realTargetFolder;
      }
      get symlinkFileNames() {
        return this._symlinkFileNames;
      }
      getFilePath() {
        return path9.join(this.targetFolder, this.decodeEntryFileName);
      }
      async isOutsideTargetFolder(tpath) {
        if (this.symlinkFileNames.length === 0) {
          return false;
        }
        if (process.platform === "win32" && this.symlinkAsFileOnWindows) {
          return false;
        }
        for (const fileName of this.symlinkFileNames) {
          if (tpath.includes(fileName)) {
            const realFilePath = await util.realpath(tpath);
            if (realFilePath.indexOf(this.realTargetFolder) !== 0) {
              return true;
            }
          }
        }
        return false;
      }
    };
    var Unzip = class extends cancelable_1.Cancelable {
      /**
       *
       */
      constructor(options) {
        super();
        this.options = options;
      }
      /**
       * Extract the zip file to the specified location.
       * @param zipFile
       * @param targetFolder
       * @param options
       */
      async extract(zipFile, targetFolder) {
        let extractedEntriesCount = 0;
        const token = new cancelable_1.CancellationToken();
        this.token = token;
        if (this.isOverwrite()) {
          await exfs.rimraf(targetFolder);
        }
        if (token.isCancelled) {
          return Promise.reject(this.canceledError());
        }
        await exfs.ensureFolder(targetFolder);
        const realTargetFolder = await util.realpath(targetFolder);
        const zfile = await this.openZip(zipFile, token);
        this.zipFile = zfile;
        zfile.readEntry();
        return new Promise((c, e) => {
          let anyError = null;
          const total = zfile.entryCount;
          zfile.once("error", (err) => {
            this.closeZip();
            e(this.wrapError(err, token.isCancelled));
          });
          zfile.once("close", () => {
            this.zipFile = null;
            if (anyError) {
              e(this.wrapError(anyError, token.isCancelled));
            } else {
              if (token.isCancelled) {
                e(this.canceledError());
              } else if (total === 0) {
                c(void 0);
              }
            }
          });
          if (token.isCancelled) {
            this.closeZip();
            return;
          }
          const entryContext = new EntryContext(targetFolder, realTargetFolder, this.symlinkToFile());
          const entryEvent = new EntryEvent(total);
          zfile.on("entry", async (entry) => {
            const rawName = entry.fileName.toString("utf8");
            const fileName = rawName.replace(/\\/g, "/");
            const errorMessage = yauzl.validateFileName(fileName);
            if (errorMessage != null) {
              anyError = new Error(errorMessage);
              this.closeZip();
              e(anyError);
              return;
            }
            entryEvent.entryName = fileName;
            this.onEntryCallback(entryEvent);
            entryContext.decodeEntryFileName = fileName;
            try {
              if (entryEvent.isPrevented) {
                entryEvent.reset();
                zfile.readEntry();
              } else {
                await this.handleEntry(zfile, entry, entryContext, token);
              }
              extractedEntriesCount++;
              if (extractedEntriesCount === total) {
                c();
              }
            } catch (error) {
              anyError = this.wrapError(error, token.isCancelled);
              this.closeZip();
              e(anyError);
            }
          });
        });
      }
      /**
       * Cancel decompression.
       * If the cancel method is called after the extract is complete, nothing will happen.
       */
      cancel() {
        if (this.token) {
          this.token.cancel();
          this.token = null;
        }
        this.closeZip();
      }
      closeZip() {
        if (this.zipFile) {
          this.zipFile.close();
          this.zipFile = null;
        }
      }
      openZip(zipFile, token) {
        return new Promise((c, e) => {
          yauzl.open(zipFile, {
            lazyEntries: true,
            // see https://github.com/thejoshwolfe/yauzl/issues/84
            decodeStrings: false
          }, (err, zfile) => {
            if (err) {
              e(this.wrapError(err, token.isCancelled));
            } else {
              c(zfile);
            }
          });
        });
      }
      async handleEntry(zfile, entry, entryContext, token) {
        if (/\/$/.test(entryContext.decodeEntryFileName)) {
          await exfs.ensureFolder(entryContext.getFilePath());
          zfile.readEntry();
        } else {
          await this.extractEntry(zfile, entry, entryContext, token);
        }
      }
      openZipFileStream(zfile, entry, token) {
        return new Promise((c, e) => {
          zfile.openReadStream(entry, (err, readStream) => {
            if (err) {
              e(this.wrapError(err, token.isCancelled));
            } else {
              c(readStream);
            }
          });
        });
      }
      async extractEntry(zfile, entry, entryContext, token) {
        const filePath = entryContext.getFilePath();
        const fileDir = path9.dirname(filePath);
        await exfs.ensureFolder(fileDir);
        const outside = await entryContext.isOutsideTargetFolder(fileDir);
        if (outside) {
          const error = new Error(`Refuse to write file outside "${entryContext.targetFolder}", file: "${filePath}"`);
          error.name = "AFWRITE";
          return Promise.reject(error);
        }
        const readStream = await this.openZipFileStream(zfile, entry, token);
        await this.writeEntryToFile(readStream, entry, entryContext, token);
        zfile.readEntry();
      }
      async writeEntryToFile(readStream, entry, entryContext, token) {
        let fileStream;
        token.onCancelled(() => {
          if (fileStream) {
            readStream.unpipe(fileStream);
            fileStream.destroy(this.canceledError());
          }
        });
        return new Promise(async (c, e) => {
          try {
            const filePath = entryContext.getFilePath();
            const mode = this.modeFromEntry(entry);
            const isSymlink = (mode & 61440) === 40960;
            readStream.once("error", (err) => {
              e(this.wrapError(err, token.isCancelled));
            });
            if (isSymlink) {
              entryContext.symlinkFileNames.push(entryContext.decodeEntryFileName);
            }
            if (isSymlink && !this.symlinkToFile()) {
              let linkContent = "";
              readStream.on("data", (chunk) => {
                if (chunk instanceof String) {
                  linkContent += chunk;
                } else {
                  linkContent += chunk.toString();
                }
              });
              readStream.once("end", () => {
                this.createSymlink(linkContent, filePath).then(c, e);
              });
            } else {
              fileStream = (0, fs_1.createWriteStream)(filePath, { mode });
              fileStream.once("close", () => c());
              fileStream.once("error", (err) => {
                e(this.wrapError(err, token.isCancelled));
              });
              readStream.pipe(fileStream);
            }
          } catch (error) {
            e(this.wrapError(error, token.isCancelled));
          }
        });
      }
      modeFromEntry(entry) {
        const attr = entry.externalFileAttributes >> 16 || 33188;
        return [
          448,
          56,
          7
          /* S_IRWXO */
        ].map((mask) => attr & mask).reduce(
          (a, b) => a + b,
          attr & 61440
          /* S_IFMT */
        );
      }
      async createSymlink(linkContent, des) {
        let linkType = "file";
        if (process.platform === "win32") {
          if (/\/$/.test(linkContent)) {
            linkType = "dir";
          } else {
            let targetPath = linkContent;
            if (!path9.isAbsolute(linkContent)) {
              targetPath = path9.join(path9.dirname(des), linkContent);
            }
            try {
              const stat = await util.stat(targetPath);
              if (stat.isDirectory()) {
                linkType = "dir";
              }
            } catch (error) {
            }
          }
        }
        await util.symlink(linkContent, des, linkType);
      }
      isOverwrite() {
        if (this.options && this.options.overwrite) {
          return true;
        }
        return false;
      }
      onEntryCallback(event) {
        if (this.options && this.options.onEntry) {
          this.options.onEntry(event);
        }
      }
      symlinkToFile() {
        let symlinkToFile = false;
        if (process.platform === "win32") {
          if (this.options && this.options.symlinkAsFileOnWindows === false) {
            symlinkToFile = false;
          } else {
            symlinkToFile = true;
          }
        }
        return symlinkToFile;
      }
    };
    exports.Unzip = Unzip;
  }
});

// ../../node_modules/zip-lib/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/zip-lib/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extract = exports.archiveFolder = exports.archiveFile = void 0;
    var zip_1 = require_zip2();
    var unzip_1 = require_unzip();
    __exportStar(require_zip2(), exports);
    __exportStar(require_unzip(), exports);
    function archiveFile(file, zipFile, options) {
      const zip = new zip_1.Zip(options);
      zip.addFile(file);
      return zip.archive(zipFile);
    }
    exports.archiveFile = archiveFile;
    function archiveFolder(folder, zipFile, options) {
      const zip = new zip_1.Zip(options);
      zip.addFolder(folder);
      return zip.archive(zipFile);
    }
    exports.archiveFolder = archiveFolder;
    function extract(zipFile, targetFolder, options) {
      const unzip = new unzip_1.Unzip(options);
      return unzip.extract(zipFile, targetFolder);
    }
    exports.extract = extract;
  }
});

// src/platforms/MinecraftProduct.ts
var MinecraftProduct = /* @__PURE__ */ ((MinecraftProduct2) => {
  MinecraftProduct2["Bedrock"] = "BedrockUWP";
  MinecraftProduct2["Preview"] = "PreviewUWP";
  MinecraftProduct2["Custom"] = "Custom";
  return MinecraftProduct2;
})(MinecraftProduct || {});

// src/setupEnvironment.ts
var import_dotenv = __toESM(require_main());
function setupEnvironment(envPath) {
  import_dotenv.default.config({ path: envPath });
}

// src/tasks/api-extractor.ts
import { Extractor, ExtractorConfig } from "@microsoft/api-extractor";
function apiExtractorTask(jsonFile, localBuild) {
  return () => {
    console.log(`Running a ${localBuild ? "local" : "production"} api extractor build.`);
    const apiExtractorJsonPath = jsonFile;
    const extractorConfig = ExtractorConfig.loadFileAndPrepare(apiExtractorJsonPath);
    const extractorResult = Extractor.invoke(extractorConfig, {
      // Equivalent to the "--local" command-line parameter
      localBuild,
      // Equivalent to the "--verbose" command-line parameter
      showVerboseMessages: true
    });
    if (extractorResult.succeeded) {
      console.log(`API Extractor completed successfully`);
      process.exitCode = 0;
      return Promise.resolve();
    }
    const message = `API Extractor did not complete successfully. ${extractorResult.errorCount} errors found and ${extractorResult.warningCount} warnings found. These must be addressed for the test to succeed.`;
    console.error(message);
    process.exitCode = 1;
    return Promise.reject(new Error(message));
  };
}

// src/tasks/bundle.ts
import esbuild from "esbuild";
import fs from "fs";
import path from "path";
var MAP_EXTENSION = ".map";
function isRequiredToMakeAnyFileChange(sourcemap) {
  return sourcemap !== false && sourcemap !== "inline";
}
function isRequiredToLinkJsFile(sourcemap) {
  return sourcemap === true || sourcemap === "linked";
}
function linkSourceMaps(sourceMapDirectory, outputDirectory, options, outputFiles) {
  const generatedFiles = {};
  for (const element of outputFiles) {
    if (element.path.endsWith(MAP_EXTENSION)) {
      const parsedPath = path.parse(element.path);
      const sourceMapFilePath = path.join(sourceMapDirectory, parsedPath.base);
      const sourceMapContent = JSON.parse(element.text);
      sourceMapContent.file = path.relative(sourceMapDirectory, path.join(outputDirectory, parsedPath.name)).replace(/\\/g, "/");
      generatedFiles[sourceMapFilePath] = JSON.stringify(sourceMapContent);
    } else if (isRequiredToLinkJsFile(options.sourcemap)) {
      const dir = path.parse(element.path).dir;
      const targetSourceMap = path.join(path.relative(dir, sourceMapDirectory), path.parse(element.path).base).replace(/\\/g, "/");
      generatedFiles[element.path] = element.text + `
//# sourceMappingURL=${targetSourceMap}${MAP_EXTENSION}
`;
    } else {
      generatedFiles[element.path] = element.text;
    }
  }
  return generatedFiles;
}
function writeFiles(postProcessOutputFilesResult) {
  fs.mkdirSync(postProcessOutputFilesResult.outputDirectory, { recursive: true });
  if (postProcessOutputFilesResult.sourceMapDirectory !== postProcessOutputFilesResult.outputDirectory) {
    fs.mkdirSync(postProcessOutputFilesResult.sourceMapDirectory, { recursive: true });
  }
  for (const path9 of Object.keys(postProcessOutputFilesResult.generatedFiles)) {
    fs.writeFileSync(path9, postProcessOutputFilesResult.generatedFiles[path9]);
  }
}
function postProcessOutputFiles(options, buildResult) {
  if (!buildResult.outputFiles) {
    return void 0;
  }
  const outputDirectory = path.parse(options.outfile).dir;
  const sourceMapDirectory = path.resolve(options.outputSourcemapPath ?? outputDirectory);
  const generatedFiles = linkSourceMaps(sourceMapDirectory, outputDirectory, options, buildResult.outputFiles);
  return { sourceMapDirectory, outputDirectory, generatedFiles };
}
function bundleTask(options) {
  return () => {
    const isRequiredToMakeChanges = isRequiredToMakeAnyFileChange(options.sourcemap);
    const isRequiredToLinkJs = isRequiredToLinkJsFile(options.sourcemap);
    const buildResult = esbuild.buildSync({
      entryPoints: [options.entryPoint],
      bundle: true,
      format: "esm",
      minifyWhitespace: options.minifyWhitespace,
      outfile: options.outfile,
      sourcemap: isRequiredToLinkJs ? "external" : options.sourcemap,
      external: options.external,
      write: !isRequiredToMakeChanges
    });
    if (buildResult.errors.length === 0) {
      if (isRequiredToMakeChanges) {
        if (!buildResult.outputFiles) {
          process.exitCode = 1;
          return Promise.reject(
            new Error(
              "No output files were generated, check that your entrypoint file is configured correctly."
            )
          );
        }
        const result = postProcessOutputFiles(options, buildResult);
        if (result) {
          writeFiles(result);
        }
      }
      process.exitCode = 0;
      return Promise.resolve();
    }
    process.exitCode = 1;
    return Promise.reject(new Error(buildResult.errors.join("\n")));
  };
}

// src/tasks/clean.ts
var import_rimraf = __toESM(require_rimraf());
import path2 from "path";
var DEFAULT_CLEAN_DIRECTORIES = ["temp", "lib", "dist"];
function cleanTask(dirs) {
  return () => {
    for (const dir of dirs) {
      try {
        console.log(`Cleaning ${dir}`);
        import_rimraf.default.sync(path2.resolve(process.cwd(), dir));
      } catch (_2) {
      }
    }
  };
}

// src/tasks/cleanCollateral.ts
var import_rimraf2 = __toESM(require_rimraf());
import * as fs2 from "fs";
import * as Path from "path";

// src/tasks/helpers/getOrThrowFromProcess.ts
function getOrThrowFromProcess(key, messageOverride) {
  const value = process.env[key];
  if (!value) {
    throw new Error(messageOverride ?? `Missing environment variable ${key}. Make sure to configure project.`);
  }
  return value;
}

// src/tasks/cleanCollateral.ts
var STANDARD_CLEAN_PATHS = [
  "LOCALAPPDATA/Packages/Microsoft.MinecraftUWP_8wekyb3d8bbwe/LocalState/games/com.mojang/development_behavior_packs/PROJECT_NAME",
  "LOCALAPPDATA/Packages/Microsoft.MinecraftUWP_8wekyb3d8bbwe/LocalState/games/com.mojang/development_resource_packs/PROJECT_NAME",
  "LOCALAPPDATA/Packages/Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe/LocalState/games/com.mojang/development_behavior_packs/PROJECT_NAME",
  "LOCALAPPDATA/Packages/Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe/LocalState/games/com.mojang/development_resource_packs/PROJECT_NAME"
];
function cleanCollateralTask(pathsToClean) {
  return () => {
    const projectName = getOrThrowFromProcess("PROJECT_NAME");
    const errorToken = "$ERROR_TOKEN$";
    let appData = process.env.APPDATA;
    if (!appData) {
      console.warn("Proceeding without APPDATA on this platform. File copy will fail if APPDATA is required.");
      appData = errorToken;
    }
    let localAppData = process.env.LOCALAPPDATA;
    if (!localAppData) {
      console.warn(
        "Proceeding without LOCALAPPDATA on this platform. File copy will fail if LOCALAPPDATA is required."
      );
      localAppData = errorToken;
    }
    for (const cleanPathRaw of pathsToClean) {
      const cleanPath = cleanPathRaw.replace("LOCALAPPDATA", localAppData).replace("APPDATA", appData).replace("PROJECT_NAME", projectName);
      if (cleanPath.includes(errorToken)) {
        console.warn(
          `Skipping clean of ${cleanPath} on current platform due to APPDATA or LOCALAPPDATA being missing.`
        );
        continue;
      }
      try {
        const stats = fs2.statSync(cleanPath);
        console.log(`Cleaning ${stats.isDirectory() ? "directory" : "file"} ${Path.resolve(cleanPath)}.`);
        import_rimraf2.default.sync(cleanPath);
      } catch (_2) {
      }
    }
  };
}

// src/tasks/copy.ts
import path5 from "path";

// src/tasks/helpers/copyFiles.ts
var import_node_core_library = __toESM(require_lib2());
import path3 from "path";
function copyFiles(originPaths, outputPath) {
  let destinationPath = path3.resolve(outputPath);
  for (const originPath of originPaths) {
    const inputPath = path3.resolve(originPath);
    const pathStats = import_node_core_library.FileSystem.getLinkStatistics(inputPath);
    if (pathStats.isDirectory()) {
      console.log(`Copying folder ${inputPath} to ${destinationPath}`);
    } else {
      const filename = path3.parse(inputPath).base;
      destinationPath = path3.resolve(destinationPath, filename);
      console.log(`Copying file ${inputPath} to ${destinationPath}`);
    }
    import_node_core_library.FileSystem.copyFiles({
      sourcePath: inputPath,
      destinationPath
    });
  }
}

// src/tasks/helpers/getGameDeploymentRootPaths.ts
import path4, { resolve as resolve2 } from "path";
function getGameDeploymentRootPaths() {
  const localAppDataPath = process.env["LOCALAPPDATA"];
  const customDeploymentPath = process.env["CUSTOM_DEPLOYMENT_PATH"];
  return {
    BedrockUWP: localAppDataPath ? resolve2(localAppDataPath, "Packages/Microsoft.MinecraftUWP_8wekyb3d8bbwe/LocalState/games/com.mojang/") : void 0,
    PreviewUWP: localAppDataPath ? resolve2(
      localAppDataPath,
      "Packages/Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe/LocalState/games/com.mojang/"
    ) : void 0,
    Custom: customDeploymentPath ? customDeploymentPath : void 0
  };
}
function getTargetWorldPath() {
  let deploymentPath = void 0;
  let product;
  try {
    product = getOrThrowFromProcess("MINECRAFT_PRODUCT");
    deploymentPath = getGameDeploymentRootPaths()[product];
  } catch (_2) {
    throw new Error("Unable to get deployment path. Make sure to configure package root correctly.");
  }
  if (deploymentPath === void 0) {
    throw new Error("Deployment path is undefined. Make sure to configure package root correctly.");
  }
  const projectName = getOrThrowFromProcess("PROJECT_NAME");
  const worldsFolderName = product === "Custom" /* Custom */ ? "worlds" : "minecraftWorlds";
  const activeWorldFolderName = product === "Custom" /* Custom */ ? "Bedrock level" : `${projectName}world`;
  return path4.join(deploymentPath, worldsFolderName, activeWorldFolderName);
}

// src/tasks/copy.ts
var BehaviorPacksPath = "development_behavior_packs";
var ResourcePacksPath = "development_resource_packs";
function copyTask(params) {
  return () => {
    const projectName = getOrThrowFromProcess("PROJECT_NAME");
    let deploymentPath = void 0;
    try {
      const product = getOrThrowFromProcess("MINECRAFT_PRODUCT");
      deploymentPath = getGameDeploymentRootPaths()[product];
    } catch (_2) {
      throw new Error("Unable to get deployment path. Make sure to configure package root correctly.");
    }
    if (deploymentPath === void 0) {
      throw new Error("Deployment path is undefined. Make sure to configure package root correctly.");
    }
    copyFiles(params.copyToBehaviorPacks, path5.join(deploymentPath, BehaviorPacksPath, projectName));
    copyFiles(params.copyToScripts, path5.join(deploymentPath, BehaviorPacksPath, projectName, "scripts"));
    if (params.copyToResourcePacks) {
      copyFiles(params.copyToResourcePacks, path5.join(deploymentPath, ResourcePacksPath, projectName));
    }
  };
}

// src/tasks/coreLint.ts
import { execSync } from "child_process";
import { existsSync } from "fs";
import { condition, logger, prettierCheckTask, prettierTask, series, task } from "just-scripts";
import path6 from "path";
import process2 from "process";
var LEGACY_CONFIG_FILES = [".eslintrc.js"];
var FLAT_CONFIG_FILES = ["eslint.config.js", "eslint.config.mjs", "eslint.config.cjs"];
var POSSIBLE_CONFIG_FILES = [...LEGACY_CONFIG_FILES, ...FLAT_CONFIG_FILES];
function getConfigFilePath() {
  for (const file of POSSIBLE_CONFIG_FILES) {
    const configPath = path6.resolve(process2.cwd(), file);
    if (existsSync(configPath)) {
      return configPath;
    }
  }
  return void 0;
}
function eslintTask(files, fix) {
  return () => {
    const configFilePath = getConfigFilePath();
    if (configFilePath) {
      process2.env["ESLINT_USE_FLAT_CONFIG"] = FLAT_CONFIG_FILES.some((file) => configFilePath.endsWith(file)) ? "true" : "false";
      const cmd = [
        "eslint",
        ...files,
        "--config",
        `"${configFilePath}"`,
        ...fix ? ["--fix"] : [],
        "--color"
      ].join(" ");
      logger.info(`Running command: ${cmd}`);
      return execSync(cmd, { stdio: "inherit" });
    }
    return Promise.resolve();
  };
}
function coreLint(files, fix) {
  task("verify-lint", () => {
    if (!getConfigFilePath()) {
      throw new Error(
        `ESLint config file not found at ${process2.cwd()}. Possible values: [${POSSIBLE_CONFIG_FILES.join(
          ", "
        )}]`
      );
    }
  });
  task("eslint", eslintTask(files, fix));
  task("prettier-fix", prettierTask({ files }));
  task("prettier-check", prettierCheckTask({ files }));
  return series(
    "verify-lint",
    "eslint",
    condition("prettier-check", () => !fix),
    condition("prettier-fix", () => !!fix)
  );
}

// ../../node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// ../../node_modules/before-after-hook/lib/register.js
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// ../../node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook2 = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}

// ../../node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// ../../node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// ../../node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_2, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option2) => urlVariableNames.includes(option2)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// ../../node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
  name;
  /**
   * http status code
   */
  status;
  /**
   * Request options that lead to the error.
   */
  request;
  /**
   * Response object if a response was received
   */
  response;
  constructor(message, statusCode, options) {
    super(message);
    this.name = "HttpError";
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
};

// ../../node_modules/@octokit/request/dist-bundle/index.js
var VERSION2 = "0.0.0-development";
var defaults_default = {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`
  }
};
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper(requestOptions) {
  const fetch = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  const log = requestOptions.request?.log || console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  const body = isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(
    Object.entries(requestOptions.headers).map(([name, value]) => [
      name,
      String(value)
    ])
  );
  let fetchResponse;
  try {
    fetchResponse = await fetch(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      // duplex must be set if request.body is ReadableStream or Async Iterables.
      // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
      ...requestOptions.body && { duplex: "half" }
    });
  } catch (error) {
    let message = "Unknown Error";
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError(message, 500, {
      request: requestOptions
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log.warn(
      `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
    );
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError(toErrorMessage(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return response.arrayBuffer();
}
function toErrorMessage(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v) => JSON.stringify(v)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, defaults_default);

// ../../node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  name = "GraphqlResponseError";
  errors;
  data;
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// ../../node_modules/@octokit/auth-token/dist-bundle/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// ../../node_modules/@octokit/core/dist-src/version.js
var VERSION4 = "6.1.2";

// ../../node_modules/@octokit/core/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
var Octokit = class {
  static VERSION = VERSION4;
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  static plugins = [];
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    const currentPlugins = this.plugins;
    const NewOctokit = class extends this {
      static plugins = currentPlugins.concat(
        newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
      );
    };
    return NewOctokit;
  }
  constructor(options = {}) {
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError
      },
      options.log
    );
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
  // assigned during constructor
  request;
  graphql;
  log;
  hook;
  // TODO: type `octokit.auth` based on passed options.authStrategy
  auth;
};

// ../../node_modules/@octokit/plugin-request-log/dist-src/version.js
var VERSION5 = "5.3.1";

// ../../node_modules/@octokit/plugin-request-log/dist-src/index.js
function requestLog(octokit) {
  octokit.hook.wrap("request", (request2, options) => {
    octokit.log.debug("request", options);
    const start = Date.now();
    const requestOptions = octokit.request.endpoint.parse(options);
    const path9 = requestOptions.url.replace(options.baseUrl, "");
    return request2(options).then((response) => {
      const requestId = response.headers["x-github-request-id"];
      octokit.log.info(
        `${requestOptions.method} ${path9} - ${response.status} with id ${requestId} in ${Date.now() - start}ms`
      );
      return response;
    }).catch((error) => {
      const requestId = error.response?.headers["x-github-request-id"] || "UNKNOWN";
      octokit.log.error(
        `${requestOptions.method} ${path9} - ${error.status} with id ${requestId} in ${Date.now() - start}ms`
      );
      throw error;
    });
  });
}
requestLog.VERSION = VERSION5;

// ../../node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js
var VERSION6 = "0.0.0-development";
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }
  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization)
    return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;
  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  return response;
}
function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url)
          return { done: true };
        try {
          const response = await requestMethod({ method, url, headers });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url = ((normalizedResponse.headers.link || "").match(
            /<([^>]+)>;\s*rel="next"/
          ) || [])[1];
          return { value: normalizedResponse };
        } catch (error) {
          if (error.status !== 409)
            throw error;
          url = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}
function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = void 0;
  }
  return gather(
    octokit,
    [],
    iterator(octokit, route, parameters)[Symbol.asyncIterator](),
    mapFn
  );
}
function gather(octokit, results, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    results = results.concat(
      mapFn ? mapFn(result.value, done) : result.value.data
    );
    if (earlyExit) {
      return results;
    }
    return gather(octokit, results, iterator2, mapFn);
  });
}
var composePaginateRest = Object.assign(paginate, {
  iterator
});
function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION6;

// ../../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js
var VERSION7 = "13.2.6";

// ../../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js
var Endpoints = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: [
      "POST /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    addCustomLabelsToSelfHostedRunnerForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    approveWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
    ],
    cancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
    ],
    createEnvironmentVariable: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/variables"
    ],
    createOrUpdateEnvironmentSecret: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    createOrgVariable: ["POST /orgs/{org}/actions/variables"],
    createRegistrationTokenForOrg: [
      "POST /orgs/{org}/actions/runners/registration-token"
    ],
    createRegistrationTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/registration-token"
    ],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/remove-token"
    ],
    createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
    createWorkflowDispatch: [
      "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
    ],
    deleteActionsCacheById: [
      "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
    ],
    deleteActionsCacheByKey: [
      "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
    ],
    deleteArtifact: [
      "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
    ],
    deleteEnvironmentSecret: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    deleteEnvironmentVariable: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    deleteRepoVariable: [
      "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    deleteSelfHostedRunnerFromOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}"
    ],
    deleteSelfHostedRunnerFromRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: [
      "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    disableSelectedRepositoryGithubActionsOrganization: [
      "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    disableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
    ],
    downloadArtifact: [
      "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
    ],
    downloadJobLogsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
    ],
    downloadWorkflowRunAttemptLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
    ],
    downloadWorkflowRunLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    enableSelectedRepositoryGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    enableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
    ],
    forceCancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
    ],
    generateRunnerJitconfigForOrg: [
      "POST /orgs/{org}/actions/runners/generate-jitconfig"
    ],
    generateRunnerJitconfigForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
    ],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: [
      "GET /orgs/{org}/actions/cache/usage-by-repository"
    ],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/selected-actions"
    ],
    getAllowedActionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getCustomOidcSubClaimForRepo: [
      "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    getEnvironmentPublicKey: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key"
    ],
    getEnvironmentSecret: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    getEnvironmentVariable: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    getGithubActionsDefaultWorkflowPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions/workflow"
    ],
    getGithubActionsDefaultWorkflowPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    getGithubActionsPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions"
    ],
    getGithubActionsPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions"
    ],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
    getPendingDeploymentsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    getRepoPermissions: [
      "GET /repos/{owner}/{repo}/actions/permissions",
      {},
      { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
    ],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
    getReviewsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
    ],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/access"
    ],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
    ],
    getWorkflowRunUsage: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
    ],
    getWorkflowUsage: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
    ],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets"
    ],
    listEnvironmentVariables: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/variables"
    ],
    listJobsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
    ],
    listJobsForWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
    ],
    listLabelsForSelfHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    listLabelsForSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listOrgVariables: ["GET /orgs/{org}/actions/variables"],
    listRepoOrganizationSecrets: [
      "GET /repos/{owner}/{repo}/actions/organization-secrets"
    ],
    listRepoOrganizationVariables: [
      "GET /repos/{owner}/{repo}/actions/organization-variables"
    ],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/downloads"
    ],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    listSelectedReposForOrgVariable: [
      "GET /orgs/{org}/actions/variables/{name}/repositories"
    ],
    listSelectedRepositoriesEnabledGithubActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/repositories"
    ],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
    ],
    listWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
    ],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
    ],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgVariable: [
      "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    reviewCustomGatesForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
    ],
    reviewPendingDeploymentsForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    setAllowedActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/selected-actions"
    ],
    setAllowedActionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    setCustomLabelsForSelfHostedRunnerForOrg: [
      "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    setCustomLabelsForSelfHostedRunnerForRepo: [
      "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    setCustomOidcSubClaimForRepo: [
      "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    setGithubActionsDefaultWorkflowPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/workflow"
    ],
    setGithubActionsDefaultWorkflowPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    setGithubActionsPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions"
    ],
    setGithubActionsPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories"
    ],
    setSelectedRepositoriesEnabledGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories"
    ],
    setWorkflowAccessToRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/access"
    ],
    updateEnvironmentVariable: [
      "PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
    updateRepoVariable: [
      "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
    ]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: [
      "DELETE /notifications/threads/{thread_id}/subscription"
    ],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: [
      "GET /notifications/threads/{thread_id}/subscription"
    ],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: [
      "GET /users/{username}/events/orgs/{org}"
    ],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: [
      "GET /users/{username}/received_events/public"
    ],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/notifications"
    ],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: [
      "PUT /notifications/threads/{thread_id}/subscription"
    ],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
    ],
    addRepoToInstallationForAuthenticatedUser: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: [
      "POST /app/installations/{installation_id}/access_tokens"
    ],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: [
      "GET /marketplace_listing/accounts/{account_id}"
    ],
    getSubscriptionPlanForAccountStubbed: [
      "GET /marketplace_listing/stubbed/accounts/{account_id}"
    ],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: [
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
    ],
    listInstallationReposForAuthenticatedUser: [
      "GET /user/installations/{installation_id}/repositories"
    ],
    listInstallationRequestsForAuthenticatedApp: [
      "GET /app/installation-requests"
    ],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: [
      "GET /user/marketplace_purchases/stubbed"
    ],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: [
      "POST /app/hook/deliveries/{delivery_id}/attempts"
    ],
    removeRepoFromInstallation: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: [
      "DELETE /app/installations/{installation_id}/suspended"
    ],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: [
      "GET /users/{username}/settings/billing/actions"
    ],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: [
      "GET /users/{username}/settings/billing/packages"
    ],
    getSharedStorageBillingOrg: [
      "GET /orgs/{org}/settings/billing/shared-storage"
    ],
    getSharedStorageBillingUser: [
      "GET /users/{username}/settings/billing/shared-storage"
    ]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: [
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
    ],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: [
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
    ],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: [
      "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
    ],
    rerequestSuite: [
      "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
    ],
    setSuitesPreferences: [
      "PATCH /repos/{owner}/{repo}/check-suites/preferences"
    ],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    deleteAnalysis: [
      "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
      {},
      { renamedParameters: { alert_id: "alert_number" } }
    ],
    getAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
    ],
    getCodeqlDatabase: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    listAlertInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      {},
      { renamed: ["codeScanning", "listAlertInstances"] }
    ],
    listCodeqlDatabases: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
    ],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
    ],
    updateDefaultSetup: [
      "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
    ],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    checkPermissionsForDevcontainer: [
      "GET /repos/{owner}/{repo}/codespaces/permissions_check"
    ],
    codespaceMachinesForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/machines"
    ],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}"
    ],
    createWithPrForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
    ],
    createWithRepoForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/codespaces"
    ],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: [
      "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    deleteSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}"
    ],
    exportForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/exports"
    ],
    getCodespacesForUserInOrg: [
      "GET /orgs/{org}/members/{username}/codespaces"
    ],
    getExportDetailsForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/exports/{export_id}"
    ],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
    getPublicKeyForAuthenticatedUser: [
      "GET /user/codespaces/secrets/public-key"
    ],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    getSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}"
    ],
    listDevcontainersInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/devcontainers"
    ],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: [
      "GET /orgs/{org}/codespaces",
      {},
      { renamedParameters: { org_id: "org" } }
    ],
    listInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces"
    ],
    listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}/repositories"
    ],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    preFlightWithRepoForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/new"
    ],
    publishForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/publish"
    ],
    removeRepositoryForSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    repoMachinesForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/machines"
    ],
    setRepositoriesForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: [
      "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
    ],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  copilot: {
    addCopilotSeatsForTeams: [
      "POST /orgs/{org}/copilot/billing/selected_teams"
    ],
    addCopilotSeatsForUsers: [
      "POST /orgs/{org}/copilot/billing/selected_users"
    ],
    cancelCopilotSeatAssignmentForTeams: [
      "DELETE /orgs/{org}/copilot/billing/selected_teams"
    ],
    cancelCopilotSeatAssignmentForUsers: [
      "DELETE /orgs/{org}/copilot/billing/selected_users"
    ],
    getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
    getCopilotSeatDetailsForUser: [
      "GET /orgs/{org}/members/{username}/copilot"
    ],
    listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"],
    usageMetricsForEnterprise: ["GET /enterprises/{enterprise}/copilot/usage"],
    usageMetricsForOrg: ["GET /orgs/{org}/copilot/usage"],
    usageMetricsForTeam: ["GET /orgs/{org}/team/{team_slug}/copilot/usage"]
  },
  dependabot: {
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/dependabot/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
    ]
  },
  dependencyGraph: {
    createRepositorySnapshot: [
      "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
    ],
    diffRange: [
      "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
    ],
    exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
  },
  emojis: { get: ["GET /emojis"] },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: [
      "GET /user/interaction-limits",
      {},
      { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
    ],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: [
      "DELETE /repos/{owner}/{repo}/interaction-limits"
    ],
    removeRestrictionsForYourPublicRepos: [
      "DELETE /user/interaction-limits",
      {},
      { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
    ],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: [
      "PUT /user/interaction-limits",
      {},
      { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
    ]
  },
  issues: {
    addAssignees: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    checkUserCanBeAssignedToIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
    ],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
    ],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
    ],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: [
      "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
    ],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
    ],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: [
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
    ],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    removeAssignees: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    removeLabel: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
    ],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: [
      "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
    ]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: [
      "POST /markdown/raw",
      { headers: { "content-type": "text/plain; charset=utf-8" } }
    ]
  },
  meta: {
    get: ["GET /meta"],
    getAllVersions: ["GET /versions"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    deleteArchiveForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/archive"
    ],
    deleteArchiveForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/archive"
    ],
    downloadArchiveForOrg: [
      "GET /orgs/{org}/migrations/{migration_id}/archive"
    ],
    getArchiveForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/archive"
    ],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/repositories"
    ],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: [
      "GET /user/migrations/{migration_id}/repositories",
      {},
      { renamed: ["migrations", "listReposForAuthenticatedUser"] }
    ],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    unlockRepoForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    unlockRepoForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
    ]
  },
  oidc: {
    getOidcCustomSubTemplateForOrg: [
      "GET /orgs/{org}/actions/oidc/customization/sub"
    ],
    updateOidcCustomSubTemplateForOrg: [
      "PUT /orgs/{org}/actions/oidc/customization/sub"
    ]
  },
  orgs: {
    addSecurityManagerTeam: [
      "PUT /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    assignTeamToOrgRole: [
      "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    assignUserToOrgRole: [
      "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: [
      "PUT /orgs/{org}/outside_collaborators/{username}"
    ],
    createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
    createOrUpdateCustomPropertiesValuesForRepos: [
      "PATCH /orgs/{org}/properties/values"
    ],
    createOrUpdateCustomProperty: [
      "PUT /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    createWebhook: ["POST /orgs/{org}/hooks"],
    delete: ["DELETE /orgs/{org}"],
    deleteCustomOrganizationRole: [
      "DELETE /orgs/{org}/organization-roles/{role_id}"
    ],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      "POST /orgs/{org}/{security_product}/{enablement}"
    ],
    get: ["GET /orgs/{org}"],
    getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
    getCustomProperty: [
      "GET /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: [
      "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
    listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
    listOrgRoles: ["GET /orgs/{org}/organization-roles"],
    listOrganizationFineGrainedPermissions: [
      "GET /orgs/{org}/organization-fine-grained-permissions"
    ],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPatGrantRepositories: [
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
    ],
    listPatGrantRequestRepositories: [
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
    ],
    listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
    listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    patchCustomOrganizationRole: [
      "PATCH /orgs/{org}/organization-roles/{role_id}"
    ],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeCustomProperty: [
      "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: [
      "DELETE /orgs/{org}/outside_collaborators/{username}"
    ],
    removePublicMembershipForAuthenticatedUser: [
      "DELETE /orgs/{org}/public_members/{username}"
    ],
    removeSecurityManagerTeam: [
      "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    reviewPatGrantRequest: [
      "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
    ],
    reviewPatGrantRequestsInBulk: [
      "POST /orgs/{org}/personal-access-token-requests"
    ],
    revokeAllOrgRolesTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
    ],
    revokeAllOrgRolesUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}"
    ],
    revokeOrgRoleTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    revokeOrgRoleUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: [
      "PUT /orgs/{org}/public_members/{username}"
    ],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: [
      "PATCH /user/memberships/orgs/{org}"
    ],
    updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
    updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}"
    ],
    deletePackageForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    deletePackageForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}"
    ],
    deletePackageVersionForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      {},
      { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions",
      {},
      {
        renamed: [
          "packages",
          "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
        ]
      }
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions"
    ],
    getPackageForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}"
    ],
    getPackageForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    getPackageForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}"
    ],
    getPackageVersionForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: [
      "GET /user/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForOrganization: [
      "GET /orgs/{org}/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForUser: [
      "GET /users/{username}/docker/conflicts"
    ],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageVersionForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
    createCard: ["POST /projects/columns/{column_id}/cards"],
    createColumn: ["POST /projects/{project_id}/columns"],
    createForAuthenticatedUser: ["POST /user/projects"],
    createForOrg: ["POST /orgs/{org}/projects"],
    createForRepo: ["POST /repos/{owner}/{repo}/projects"],
    delete: ["DELETE /projects/{project_id}"],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
    deleteColumn: ["DELETE /projects/columns/{column_id}"],
    get: ["GET /projects/{project_id}"],
    getCard: ["GET /projects/columns/cards/{card_id}"],
    getColumn: ["GET /projects/columns/{column_id}"],
    getPermissionForUser: [
      "GET /projects/{project_id}/collaborators/{username}/permission"
    ],
    listCards: ["GET /projects/columns/{column_id}/cards"],
    listCollaborators: ["GET /projects/{project_id}/collaborators"],
    listColumns: ["GET /projects/{project_id}/columns"],
    listForOrg: ["GET /orgs/{org}/projects"],
    listForRepo: ["GET /repos/{owner}/{repo}/projects"],
    listForUser: ["GET /users/{username}/projects"],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
    moveColumn: ["POST /projects/columns/{column_id}/moves"],
    removeCollaborator: [
      "DELETE /projects/{project_id}/collaborators/{username}"
    ],
    update: ["PATCH /projects/{project_id}"],
    updateCard: ["PATCH /projects/columns/cards/{card_id}"],
    updateColumn: ["PATCH /projects/columns/{column_id}"]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
    ],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    deletePendingReview: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    deleteReviewComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ],
    dismissReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
    ],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    listReviewComments: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    requestReviewers: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    submitReview: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
    ],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
    ],
    updateReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    updateReviewComment: [
      "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ]
  },
  rateLimit: { get: ["GET /rate_limit"] },
  reactions: {
    createForCommitComment: [
      "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    createForIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
    ],
    createForIssueComment: [
      "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    createForPullRequestReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    createForRelease: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    createForTeamDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    createForTeamDiscussionInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ],
    deleteForCommitComment: [
      "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
    ],
    deleteForIssueComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForPullRequestComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForRelease: [
      "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussion: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussionComment: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
    ],
    listForCommitComment: [
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: [
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    listForPullRequestReviewComment: [
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    listForRelease: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    listForTeamDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    listForTeamDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ]
  },
  repos: {
    acceptInvitation: [
      "PATCH /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
    ],
    acceptInvitationForAuthenticatedUser: [
      "PATCH /user/repository_invitations/{invitation_id}"
    ],
    addAppAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    addTeamAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    addUserAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    cancelPagesDeployment: [
      "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
    ],
    checkAutomatedSecurityFixes: [
      "GET /repos/{owner}/{repo}/automated-security-fixes"
    ],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkPrivateVulnerabilityReporting: [
      "GET /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    checkVulnerabilityAlerts: [
      "GET /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: [
      "GET /repos/{owner}/{repo}/compare/{basehead}"
    ],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: [
      "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    createCommitSignatureProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentBranchPolicy: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    createDeploymentProtectionRule: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    createDeploymentStatus: [
      "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateCustomPropertiesValues: [
      "PATCH /repos/{owner}/{repo}/properties/values"
    ],
    createOrUpdateEnvironment: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createOrgRuleset: ["POST /orgs/{org}/rulesets"],
    createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
    createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
    createUsingTemplate: [
      "POST /repos/{template_owner}/{template_repo}/generate"
    ],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: [
      "DELETE /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
    ],
    declineInvitationForAuthenticatedUser: [
      "DELETE /user/repository_invitations/{invitation_id}"
    ],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    deleteAdminBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    deleteAnEnvironment: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: [
      "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
    ],
    deleteDeploymentBranchPolicy: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: [
      "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: [
      "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    deleteTagProtection: [
      "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
    ],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: [
      "DELETE /repos/{owner}/{repo}/automated-security-fixes"
    ],
    disableDeploymentProtectionRule: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    disablePrivateVulnerabilityReporting: [
      "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    disableVulnerabilityAlerts: [
      "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    downloadArchive: [
      "GET /repos/{owner}/{repo}/zipball/{ref}",
      {},
      { renamed: ["repos", "downloadZipballArchive"] }
    ],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: [
      "PUT /repos/{owner}/{repo}/automated-security-fixes"
    ],
    enablePrivateVulnerabilityReporting: [
      "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    enableVulnerabilityAlerts: [
      "PUT /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    generateReleaseNotes: [
      "POST /repos/{owner}/{repo}/releases/generate-notes"
    ],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    getAdminBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    getAllDeploymentProtectionRules: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
    ],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
    ],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: [
      "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
    ],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getCustomDeploymentProtectionRule: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentBranchPolicy: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    getDeploymentStatus: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
    ],
    getEnvironment: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
    getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
    getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
    getOrgRulesets: ["GET /orgs/{org}/rulesets"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesDeployment: [
      "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
    ],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getRepoRuleSuite: [
      "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
    ],
    getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
    getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
    getStatusChecksProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    getTeamsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
    ],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
    ],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    getWebhookDelivery: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    listActivities: ["GET /repos/{owner}/{repo}/activity"],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
    ],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: [
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listCustomDeploymentRuleIntegrations: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
    ],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentBranchPolicies: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    listDeploymentStatuses: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
    ],
    listReleaseAssets: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
    ],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
    ],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeAppAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    removeCollaborator: [
      "DELETE /repos/{owner}/{repo}/collaborators/{username}"
    ],
    removeStatusCheckContexts: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    removeStatusCheckProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    removeTeamAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    removeUserAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    setAppAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    setStatusCheckContexts: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    setTeamAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    setUserAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateDeploymentBranchPolicy: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: [
      "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
    updatePullRequestReviewProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: [
      "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    updateStatusCheckPotection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
      {},
      { renamed: ["repos", "updateStatusCheckProtection"] }
    ],
    updateStatusCheckProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: [
      "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    uploadReleaseAsset: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
      { baseUrl: "https://uploads.github.com" }
    ]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    getAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/secret-scanning/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ]
  },
  securityAdvisories: {
    createFork: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
    ],
    createPrivateVulnerabilityReport: [
      "POST /repos/{owner}/{repo}/security-advisories/reports"
    ],
    createRepositoryAdvisory: [
      "POST /repos/{owner}/{repo}/security-advisories"
    ],
    createRepositoryAdvisoryCveRequest: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
    ],
    getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
    getRepositoryAdvisory: [
      "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ],
    listGlobalAdvisories: ["GET /advisories"],
    listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
    listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
    updateRepositoryAdvisory: [
      "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    addOrUpdateProjectPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    addOrUpdateRepoPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    checkPermissionsForProjectInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    checkPermissionsForRepoInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    deleteDiscussionInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    getDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    getMembershipForUserInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/invitations"
    ],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    removeProjectInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    removeRepoInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    updateDiscussionCommentInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    updateDiscussionInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: [
      "POST /user/emails",
      {},
      { renamed: ["users", "addEmailForAuthenticatedUser"] }
    ],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: [
      "POST /user/gpg_keys",
      {},
      { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
    ],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: [
      "POST /user/keys",
      {},
      { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
    ],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
    deleteEmailForAuthenticated: [
      "DELETE /user/emails",
      {},
      { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
    ],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: [
      "DELETE /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
    ],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: [
      "DELETE /user/keys/{key_id}",
      {},
      { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
    ],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
    deleteSshSigningKeyForAuthenticatedUser: [
      "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: [
      "GET /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
    ],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: [
      "GET /user/keys/{key_id}",
      {},
      { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
    ],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    getSshSigningKeyForAuthenticatedUser: [
      "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    list: ["GET /users"],
    listBlockedByAuthenticated: [
      "GET /user/blocks",
      {},
      { renamed: ["users", "listBlockedByAuthenticatedUser"] }
    ],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: [
      "GET /user/emails",
      {},
      { renamed: ["users", "listEmailsForAuthenticatedUser"] }
    ],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: [
      "GET /user/following",
      {},
      { renamed: ["users", "listFollowedByAuthenticatedUser"] }
    ],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: [
      "GET /user/gpg_keys",
      {},
      { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
    ],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: [
      "GET /user/public_emails",
      {},
      { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
    ],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: [
      "GET /user/keys",
      {},
      { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
    ],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
    listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
    listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
    listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
    setPrimaryEmailVisibilityForAuthenticated: [
      "PATCH /user/email/visibility",
      {},
      { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: [
      "PATCH /user/email/visibility"
    ],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};
var endpoints_default = Endpoints;

// ../../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js
var endpointMethodsMap = /* @__PURE__ */ new Map();
for (const [scope, endpoints] of Object.entries(endpoints_default)) {
  for (const [methodName, endpoint2] of Object.entries(endpoints)) {
    const [route, defaults, decorations] = endpoint2;
    const [method, url] = route.split(/ /);
    const endpointDefaults = Object.assign(
      {
        method,
        url
      },
      defaults
    );
    if (!endpointMethodsMap.has(scope)) {
      endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
    }
    endpointMethodsMap.get(scope).set(methodName, {
      scope,
      methodName,
      endpointDefaults,
      decorations
    });
  }
}
var handler = {
  has({ scope }, methodName) {
    return endpointMethodsMap.get(scope).has(methodName);
  },
  getOwnPropertyDescriptor(target, methodName) {
    return {
      value: this.get(target, methodName),
      // ensures method is in the cache
      configurable: true,
      writable: true,
      enumerable: true
    };
  },
  defineProperty(target, methodName, descriptor) {
    Object.defineProperty(target.cache, methodName, descriptor);
    return true;
  },
  deleteProperty(target, methodName) {
    delete target.cache[methodName];
    return true;
  },
  ownKeys({ scope }) {
    return [...endpointMethodsMap.get(scope).keys()];
  },
  set(target, methodName, value) {
    return target.cache[methodName] = value;
  },
  get({ octokit, scope, cache }, methodName) {
    if (cache[methodName]) {
      return cache[methodName];
    }
    const method = endpointMethodsMap.get(scope).get(methodName);
    if (!method) {
      return void 0;
    }
    const { endpointDefaults, decorations } = method;
    if (decorations) {
      cache[methodName] = decorate(
        octokit,
        scope,
        methodName,
        endpointDefaults,
        decorations
      );
    } else {
      cache[methodName] = octokit.request.defaults(endpointDefaults);
    }
    return cache[methodName];
  }
};
function endpointsToMethods(octokit) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
  }
  return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  function withDecorations(...args) {
    let options = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: void 0
      });
      return requestWithDefaults(options);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(
        `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
      );
    }
    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options2 = requestWithDefaults.endpoint.merge(...args);
      for (const [name, alias] of Object.entries(
        decorations.renamedParameters
      )) {
        if (name in options2) {
          octokit.log.warn(
            `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
          );
          if (!(alias in options2)) {
            options2[alias] = options2[name];
          }
          delete options2[name];
        }
      }
      return requestWithDefaults(options2);
    }
    return requestWithDefaults(...args);
  }
  return Object.assign(withDecorations, requestWithDefaults);
}

// ../../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js
function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    rest: api
  };
}
restEndpointMethods.VERSION = VERSION7;
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    ...api,
    rest: api
  };
}
legacyRestEndpointMethods.VERSION = VERSION7;

// ../../node_modules/@octokit/rest/dist-src/version.js
var VERSION8 = "21.0.2";

// ../../node_modules/@octokit/rest/dist-src/index.js
var Octokit2 = Octokit.plugin(requestLog, legacyRestEndpointMethods, paginateRest).defaults(
  {
    userAgent: `octokit-rest.js/${VERSION8}`
  }
);

// src/tasks/publishRelease.ts
var import_archiver = __toESM(require_archiver());
import { createWriteStream, readFileSync, unlinkSync } from "node:fs";
import { readFile } from "node:fs/promises";
import { resolve as resolve3 } from "node:path";
function publishReleaseTask(config) {
  return async () => {
    const token = config.token ?? process.env.REPO_PAT;
    if (!token) {
      throw new Error(
        "No repo token is available, pass it in via configuration or set the REPO_PAT environment variable. Unable to create release."
      );
    }
    const packageJson = JSON.parse(readFileSync("./package.json", "utf-8"));
    const publishedVersion = packageJson["version"];
    const name = packageJson["name"];
    const changelog = JSON.parse(readFileSync("./CHANGELOG.json", "utf-8"));
    const firstEntry = changelog["entries"][0];
    if (!firstEntry) {
      throw new Error(
        "No entries found in the CHANGELOG.json file. Did beachball have an error? Unable to create release notes."
      );
    }
    const comments = firstEntry["comments"];
    let body = `${config.message}

# Changes

`;
    for (const [key, value] of Object.entries(comments)) {
      body += `## ${key[0].toUpperCase()}${key.slice(1)}

${value.map((entry) => `- ${entry.author} (${entry.commit}):
${entry.comment}`).join("\n")}

`;
    }
    const octokit = new Octokit2({ auth: token });
    const tagName = `${name}_v${publishedVersion}`;
    const response = await octokit.rest.repos.createRelease({
      owner: config.repoOwner,
      repo: config.repoName,
      tag_name: tagName,
      name: `${name} ${publishedVersion}`,
      body,
      draft: false,
      prerelease: false,
      generate_release_notes: false,
      headers: {
        "X-GitHub-Api-Version": "2022-11-28"
      }
    });
    if (response.status !== 201) {
      throw new Error(`Failed to create release. Status: ${response.status}`);
    }
    const releaseId = response.data.id;
    const releaseFile = `${tagName}.zip`.replaceAll("/", "_").replaceAll("@", "");
    const outputPath = resolve3(`${releaseFile}`);
    const output = createWriteStream(outputPath);
    try {
      const archive = (0, import_archiver.default)("zip", { zlib: { level: 9 } });
      archive.on("error", function(err) {
        throw new Error(`Failed to create archive for release: ${err}`);
      });
      archive.pipe(output);
      archive.glob("**/*", { cwd: resolve3("dist") });
      await archive.finalize();
      output.close();
      const data = await readFile(outputPath);
      const response2 = await octokit.rest.repos.uploadReleaseAsset({
        mediaType: {
          format: "application/zip"
        },
        owner: config.repoOwner,
        repo: config.repoName,
        release_id: releaseId,
        data,
        name: releaseFile,
        headers: {
          "X-GitHub-Api-Version": "2022-11-28"
        }
      });
      if (response2.status !== 201) {
        throw new Error(`Failed to create release. Status: ${response2.status}`);
      }
    } finally {
      unlinkSync(outputPath);
    }
  };
}

// src/tasks/vitest.ts
import { execSync as execSync2 } from "child_process";
function vitestTask() {
  return () => {
    execSync2("vitest", { stdio: "inherit" });
  };
}

// src/tasks/updateWorld.ts
import { condition as condition2, series as series2, task as task2 } from "just-scripts";
var import_node_core_library2 = __toESM(require_lib2());
import path7 from "path";
function updateWorldTask(params) {
  const targetWorldPath = path7.resolve(getTargetWorldPath());
  task2("clean_localmc_world_backup", cleanTask([params.backupPath]));
  task2("backup_localmc_world", () => copyFiles([targetWorldPath], params.backupPath));
  task2("clean_localmc_world", cleanTask([targetWorldPath]));
  task2("deploy_localmc_world", () => copyFiles([params.devWorldPath], targetWorldPath));
  return series2(
    "clean_localmc_world_backup",
    condition2("backup_localmc_world", () => import_node_core_library2.FileSystem.exists(targetWorldPath)),
    "clean_localmc_world",
    "deploy_localmc_world"
  );
}

// src/tasks/watch.ts
import { argv, series as series3, task as task3, watch, logger as logger2, undertaker, option } from "just-scripts";
var WATCH_TASK_NAME = "watch-task";
option("watch");
function watchTask(globs, taskFunction) {
  return () => {
    if (!argv().watch) {
      return taskFunction;
    }
    let taskInProgress = true;
    let pendingWork = false;
    const onFinished = (args) => {
      if (args.name === WATCH_TASK_NAME) {
        if (pendingWork) {
          logger2.info("Processing pending changes...");
          pendingWork = false;
          origTask.call();
        } else {
          logger2.info("Waiting for new changes...");
          taskInProgress = false;
        }
      }
    };
    undertaker.on("start", function(args) {
      if (args.name === WATCH_TASK_NAME) {
        taskInProgress = true;
      }
    });
    undertaker.on("stop", function(args) {
      onFinished(args);
    });
    undertaker.on("error", function(args) {
      onFinished(args);
    });
    task3(WATCH_TASK_NAME, series3(taskFunction));
    let origTask = series3(WATCH_TASK_NAME);
    origTask.call();
    watch(globs, () => {
      if (!taskInProgress) {
        origTask.call();
      } else {
        pendingWork = true;
      }
    });
    return Promise.resolve();
  };
}

// src/tasks/zip.ts
var import_node_core_library3 = __toESM(require_lib2());
var import_zip_lib = __toESM(require_lib4());
import path8 from "path";
import { parallel, series as series4, task as task4 } from "just-scripts";
function addContentsToZip(zipContents, zip) {
  for (const content of zipContents) {
    for (const originPath of content.contents) {
      const inputPath = path8.resolve(originPath);
      const pathStats = import_node_core_library3.FileSystem.getLinkStatistics(inputPath);
      if (pathStats.isDirectory()) {
        console.log(`Adding folder ${inputPath} to package`);
        zip.addFolder(inputPath, content.targetPath);
      } else {
        const metadataPath = content.targetPath ? path8.join(content.targetPath, path8.parse(inputPath).base) : void 0;
        console.log(`Adding file ${inputPath} to package`);
        zip.addFile(inputPath, metadataPath);
      }
    }
  }
}
function zipTask(outputFile, zipContents) {
  return async function zip() {
    if (zipContents.length === 0 || !zipContents.some((content) => content.contents.length > 0)) {
      process.exitCode = 0;
      return Promise.resolve();
    }
    const zip2 = new import_zip_lib.Zip();
    addContentsToZip(zipContents, zip2);
    let isSucceeded = true;
    let errorMessage = "";
    await zip2.archive(outputFile).then(
      function() {
        console.error(`Compressed file created at ${outputFile}`);
      },
      function(err) {
        isSucceeded = false;
        errorMessage = `Compressed file failed to be created at ${outputFile}: ${err}`;
        console.error(errorMessage);
      }
    );
    if (isSucceeded) {
      process.exitCode = 0;
      return Promise.resolve();
    }
    process.exitCode = 1;
    return Promise.reject(new Error(errorMessage));
  };
}
function mcaddonTask(params) {
  const targetFolder = path8.parse(params.outputFile).dir;
  const outputFileName = path8.parse(params.outputFile).name;
  const behaviorPackFile = path8.join(targetFolder, `${outputFileName}_bp.mcpack`);
  const resourcePackFile = path8.join(targetFolder, `${outputFileName}_rp.mcpack`);
  const mcaddonContents = { contents: [behaviorPackFile] };
  if (params.copyToResourcePacks && params.copyToResourcePacks.length > 0) {
    mcaddonContents.contents.push(resourcePackFile);
  }
  task4(
    "packBP",
    zipTask(behaviorPackFile, [
      { contents: params.copyToBehaviorPacks },
      { contents: params.copyToScripts, targetPath: "scripts" }
    ])
  );
  task4("packRP", zipTask(resourcePackFile, [{ contents: params.copyToResourcePacks ?? [] }]));
  task4("packMcaddon", zipTask(params.outputFile, [mcaddonContents]));
  return series4(parallel("packBP", "packRP"), "packMcaddon");
}
export {
  DEFAULT_CLEAN_DIRECTORIES,
  MinecraftProduct,
  STANDARD_CLEAN_PATHS,
  apiExtractorTask,
  bundleTask,
  cleanCollateralTask,
  cleanTask,
  copyFiles,
  copyTask,
  coreLint,
  getGameDeploymentRootPaths,
  getOrThrowFromProcess,
  getTargetWorldPath,
  mcaddonTask,
  postProcessOutputFiles,
  publishReleaseTask,
  setupEnvironment,
  updateWorldTask,
  vitestTask,
  watchTask,
  zipTask
};
/*! Bundled license information:

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

archiver/lib/error.js:
  (**
   * Archiver Core
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)

archiver/lib/core.js:
  (**
   * Archiver Core
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)

crc-32/crc32.js:
  (*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com *)

zip-stream/index.js:
  (**
   * ZipStream
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}
   * @copyright (c) 2014 Chris Talkington, contributors.
   *)

archiver/lib/plugins/zip.js:
  (**
   * ZIP Format Plugin
   *
   * @module plugins/zip
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)

archiver/lib/plugins/tar.js:
  (**
   * TAR Format Plugin
   *
   * @module plugins/tar
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)

archiver/lib/plugins/json.js:
  (**
   * JSON Format Plugin
   *
   * @module plugins/json
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)

archiver/index.js:
  (**
   * Archiver Vending
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   *)
*/
